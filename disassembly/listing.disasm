Disassembly Listing for Auto_02
Generated From:
/home/pele/src/Auto_02/dist/default/production/Auto_02.production.elf
Feb 12, 2017 4:53:08 PM

---  /home/pele/src/Auto_02/src/Wifi.c  -----------------------------------------------------------------
1:                 #include	"WifiDefines.h"
2:                 #include	"Timers.h"
3:                 #include	"Tcp.h"
4:                 
5:                 #ifdef UART4_WIFI
6:                 
7:                 volatile	U16				TimeOut_10mS	= 0, WifiSec = 0, PackRecTimeout = 0;
8:                 static		BAUDRATE		WifiBaudrate	= BaudRate_115200;
9:                 static		WIFI_STATE		WifiState		= WifiState_Idle;
10:                static		char			WifiBuf[512];
11:                static		char*			RecWifiData 	= NULL;
12:                static		TCP_PACKET		PacketIn[2];
13:                //static		TCP_PACKET		PacketOut;
14:                static		FLAGS			Flags;
15:                static	WIFI_ACCESS_POINT	VisibleAPs[MAX_VISIBLE_AP];
16:                static		U16				VisibleApCount;
17:                static		TCP_PACKET*		PacketRec		= NULL;
18:                static		TCP_PACKET*		OutPacket		= NULL;
19:                static		UNI16			OutPacketLen;
20:                static		U8				OkPacket[8];
21:                static		UNI16			Rssi;
22:                
23:                #if	(TEST == WIFI_TEST)
24:                  #include		"Debug.h"
25:                  static char	tmp[80];
26:                #else
27:                  extern void	Usb_SendText (char* str);
28:                  #define		DebugPrint(X)
29:                  #define		DebugSprintf(stream,fmt,a...)
30:                #endif
31:                
32:                inline	void Wifi_ResponseAction	(void);
33:                inline	void Wifi_SaveWisibleSsid	(void);
34:                inline	void Wifi_CheckWisibleSsid	(void);
35:                
36:                void Wifi_On		(void)
37:                {
38:                	#if	(TEST == WIFI_TEST)
39:                		if (WIFI_EN)
0054A8  AB02DC     BTST LATD, #0
0054AA  320006     BRA Z, 0x54B8
40:                		{
41:                			Wifi_Off();
0054AC  07FFF6     RCALL Wifi_Off
42:                			DebugPrint("Turn Wifi module Off");
0054AE  2A84A0     MOV #0xA84A, W0
0054B0  07FF06     RCALL Usb_SendText
43:                			WIFI_LED = LED_STATUS_1;
0054B2  280000     MOV #0x8000, W0
0054B4  8844C0     MOV W0, LedStatus3
44:                			return;
0054B6  370009     BRA 0x54CA
45:                		}
46:                	#endif
47:                
48:                	DebugPrint("Turn Wifi module On");
0054B8  2A85F0     MOV #0xA85F, W0
0054BA  07FF01     RCALL Usb_SendText
49:                	Tcp_PreparePacket((TCP_PACKET*)OkPacket, TYPE_OK_WIFI);	// Prepare OK packet for use in interrupt
0054BC  B3CF11     MOV.B #0xF1, W1
0054BE  217840     MOV #0x1784, W0
0054C0  0703FE     RCALL Tcp_PreparePacket
50:                	WifiState = WifiState_PowerOn;
0054C2  200030     MOV #0x3, W0
0054C4  884930     MOV W0, 0x926
51:                	WIFI_IF = 1;
0054C6  A8208A     BSET IFS3, #1
52:                	WIFI_IE = 1;
0054C8  A8209A     BSET IEC3, #1
53:                }
0054CA  060000     RETURN
54:                
55:                void Wifi_Off		(void)
56:                {
57:                	WIFI_EN		= 0;				// Wifi Power	Off
00549A  A902DC     BCLR LATD, #0
58:                	WIFI_IE		= 0;				// Interrupt	Off
00549C  A9209A     BCLR IEC3, #1
59:                	WifiState	= WifiState_PowerOn;
00549E  200030     MOV #0x3, W0
0054A0  884930     MOV W0, 0x926
60:                	WIFI_LED	= LED_STATUS_1;
0054A2  280000     MOV #0x8000, W0
0054A4  8844C0     MOV W0, LedStatus3
61:                }
0054A6  060000     RETURN
62:                
63:                U8	 Wifi_Connected	(void)
64:                {
65:                	return (Flags.Status == WIFI_STATUS_CONNECTED);
0054CC  B3CF80     MOV.B #0xF8, W0
0054CE  208BF1     MOV #0x8BF, W1
0054D0  784091     MOV.B [W1], W1
0054D2  68C000     XOR.B W1, W0, W0
0054D4  FB8000     ZE W0, W0
0054D6  E90000     DEC W0, W0
0054D8  DE004F     LSR W0, #15, W0
66:                }
0054DA  060000     RETURN
67:                
68:                void Wifi_Reset		(void)
69:                {
70:                	WIFI_RST = !WIFI_RST;
0054DC  204000     MOV #0x400, W0
0054DE  8016C2     MOV TRISD, W2
0054E0  600082     AND W0, W2, W1
0054E2  E90081     DEC W1, W1
0054E4  DE08CF     LSR W1, #15, W1
0054E6  DD08CA     SL W1, #10, W1
0054E8  8016C2     MOV TRISD, W2
0054EA  A1A002     BCLR W2, #10
0054EC  708102     IOR W1, W2, W2
0054EE  8816C2     MOV W2, TRISD
71:                	#if	(TEST == WIFI_TEST)
72:                		if (WIFI_RST)		DebugPrint("RUN Wifi module");
0054F0  B602D8     AND TRISD, WREG
0054F2  320003     BRA Z, 0x54FA
0054F4  2A8730     MOV #0xA873, W0
0054F6  07FEE3     RCALL Usb_SendText
0054F8  370002     BRA 0x54FE
73:                		else				DebugPrint("RESET Wifi module");
0054FA  2A8830     MOV #0xA883, W0
0054FC  07FEE0     RCALL Usb_SendText
74:                	#endif
75:                }
0054FE  060000     RETURN
76:                
77:                U16 Wifi_AUTO		(void)
78:                {
79:                	FL_TEST_MANUAL = !FL_TEST_MANUAL;
005500  804960     MOV SysFlags, W0
005502  600062     AND W0, #0x2, W0
005504  E90000     DEC W0, W0
005506  DE004F     LSR W0, #15, W0
005508  400000     ADD W0, W0, W0
00550A  804961     MOV SysFlags, W1
00550C  A11001     BCLR W1, #1
00550E  700081     IOR W0, W1, W1
005510  884961     MOV W1, SysFlags
80:                	#if	(TEST == WIFI_TEST)
81:                		if (FL_TEST_MANUAL)	DebugPrint("Wifi Manual Mode");
005512  AB292C     BTST SysFlags, #1
005514  320003     BRA Z, 0x551C
005516  2A8950     MOV #0xA895, W0
005518  07FED2     RCALL Usb_SendText
00551A  370002     BRA 0x5520
82:                		else				DebugPrint("Wifi Automatic Mode");
00551C  2A8A60     MOV #0xA8A6, W0
00551E  07FECF     RCALL Usb_SendText
83:                	#endif
84:                	return	Flags.word;
85:                }
005520  8045F0     MOV Flags, W0
005522  060000     RETURN
86:                
87:                #if	(TEST == WIFI_TEST)
88:                	void Wifi_Test		(void)
89:                	{
90:                		if (Uart4_StringReceived())
005524  07D6FC     RCALL Uart4_StringReceived
005526  E00400     CP0.B W0
005528  320004     BRA Z, 0x5532
91:                		{
92:                			Uart4_GetString((P_U8)tmp);
00552A  217340     MOV #0x1734, W0
00552C  07D716     RCALL Uart4_GetString
93:                			DebugPrint(tmp);
00552E  217340     MOV #0x1734, W0
005530  07FEC6     RCALL Usb_SendText
94:                		}
95:                	}
005532  060000     RETURN
96:                
97:                	void Wifi_SendCommand		(char* str)
98:                	{
99:                		Uart4_SendText(str);
005534  07D720     RCALL Uart4_SendText
100:               		Uart4_SendEnter();
005536  07D735     RCALL Uart4_SendEnter
101:               	}
005538  060000     RETURN
102:               
103:               	void Wifi_BaudrateChange	(void)
104:               	{
105:               		if (++WifiBaudrate >= BaudRate_none)
00553A  EC0928     INC 0x928, WREG
00553C  884940     MOV W0, 0x928
00553E  500FE4     SUB W0, #0x4, [W15]
005540  360002     BRA LEU, 0x5546
106:               			WifiBaudrate = BaudRate_9600;
005542  EF2928     CLR 0x928
005544  37000E     BRA 0x5562
107:               		switch (WifiBaudrate)
005546  500FE2     SUB W0, #0x2, [W15]
005548  320012     BRA Z, 0x556E
00554A  3E0005     BRA GTU, 0x5556
00554C  E00000     CP0 W0
00554E  320009     BRA Z, 0x5562
005550  500FE1     SUB W0, #0x1, [W15]
005552  3A0018     BRA NZ, 0x5584
005554  370009     BRA 0x5568
005556  500FE4     SUB W0, #0x4, [W15]
005558  320010     BRA Z, 0x557A
00555A  39000C     BRA NC, 0x5574
00555C  500FE5     SUB W0, #0x5, [W15]
00555E  3A0012     BRA NZ, 0x5584
005560  37000F     BRA 0x5580
108:               		{
109:               			case BaudRate_9600:		DebugPrint("Wifi module Baud Rate changed to 9600");	break;
005562  2A8BA0     MOV #0xA8BA, W0
005564  07FEAC     RCALL Usb_SendText
005566  37000E     BRA 0x5584
110:               			case BaudRate_19200:	DebugPrint("Wifi module Baud Rate changed to 19200");	break;
005568  2A8E00     MOV #0xA8E0, W0
00556A  07FEA9     RCALL Usb_SendText
00556C  37000B     BRA 0x5584
111:               			case BaudRate_38400:	DebugPrint("Wifi module Baud Rate changed to 38400");	break;
00556E  2A9070     MOV #0xA907, W0
005570  07FEA6     RCALL Usb_SendText
005572  370008     BRA 0x5584
112:               			case BaudRate_57600:	DebugPrint("Wifi module Baud Rate changed to 57600");	break;
005574  2A92E0     MOV #0xA92E, W0
005576  07FEA3     RCALL Usb_SendText
005578  370005     BRA 0x5584
113:               			case BaudRate_115200:	DebugPrint("Wifi module Baud Rate changed to 115200");	break;
00557A  2A9550     MOV #0xA955, W0
00557C  07FEA0     RCALL Usb_SendText
00557E  370002     BRA 0x5584
114:               			case BaudRate_none:		DebugPrint("Wifi module Baud Rate Error");				break;
005580  2A97D0     MOV #0xA97D, W0
005582  07FE9D     RCALL Usb_SendText
115:               		}
116:               		Uart4_SetBaudrate(WifiBaudrate);
005584  804940     MOV 0x928, W0
005586  07D65C     RCALL Uart4_SetBaudrate
117:               	}
005588  060000     RETURN
118:               #endif
119:               
120:               // **********************************************************************
121:               //	WIFI Interrupt (I2C3 Slave Event used for 16bit proc) 100Hz if enabled
122:               // **********************************************************************
123:               void WIFI_INTERRUPT(void)
124:               {
005776  F80036     PUSH RCOUNT
005778  BE9F80     MOV.D W0, [W15++]
00577A  BE9F82     MOV.D W2, [W15++]
00577C  BE9F84     MOV.D W4, [W15++]
00577E  BE9F86     MOV.D W6, [W15++]
005780  781F88     MOV W8, [W15++]
125:               	static	WIFI_STATE	lastState = WifiState_Off;
126:               	static	U8			stateTimeout = 0, lastStatus;
127:               	WIFI_IF = 0;
005782  A9208A     BCLR IFS3, #1
128:               
129:               	if (lastStatus != Flags.Status)
005784  BFC8BF     MOV.B 0x8BF, WREG
005786  E348CE     CP.B lastStatus
005788  320021     BRA Z, 0x57CC
130:               	{
131:               		lastStatus = Flags.Status;													// pow, com, ap, ip, conected
00578A  B7E8CE     MOV.B WREG, lastStatus
132:               		if		(!Flags.pow)							WIFI_LED = LED_STATUS_1;	//  0    0    0    0    0
00578C  E208BE     CP0 Flags
00578E  350003     BRA LT, 0x5796
005790  280000     MOV #0x8000, W0
005792  8844C0     MOV W0, LedStatus3
005794  37001B     BRA 0x57CC
133:               		else if (Flags.Status == WIFI_STATUS_POWER)		WIFI_LED = LED_STATUS_2;	//  1    0    0    0    0
005796  B3C801     MOV.B #0x80, W1
005798  504F81     SUB.B W0, W1, [W15]
00579A  3A0003     BRA NZ, 0x57A2
00579C  290000     MOV #0x9000, W0
00579E  8844C0     MOV W0, LedStatus3
0057A0  370015     BRA 0x57CC
134:               		else if (Flags.Status == WIFI_STATUS_COM)		WIFI_LED = LED_STATUS_2;	//  1    1    0    0    0
0057A2  B3CC01     MOV.B #0xC0, W1
0057A4  504F81     SUB.B W0, W1, [W15]
0057A6  3A0003     BRA NZ, 0x57AE
0057A8  290000     MOV #0x9000, W0
0057AA  8844C0     MOV W0, LedStatus3
0057AC  37000F     BRA 0x57CC
135:               		else if (Flags.Status == WIFI_STATUS_AP)		WIFI_LED = LED_STATUS_3;	//  1    1    1    0    0
0057AE  B3CE01     MOV.B #0xE0, W1
0057B0  504F81     SUB.B W0, W1, [W15]
0057B2  3A0003     BRA NZ, 0x57BA
0057B4  292000     MOV #0x9200, W0
0057B6  8844C0     MOV W0, LedStatus3
0057B8  370009     BRA 0x57CC
136:               		else if (Flags.Status == WIFI_STATUS_IP_OK)		WIFI_LED = LED_STATUS_3;	//  1    1    1    1    0
0057BA  404FF0     ADD.B W0, #0x10, [W15]
0057BC  3A0003     BRA NZ, 0x57C4
0057BE  292000     MOV #0x9200, W0
0057C0  8844C0     MOV W0, LedStatus3
0057C2  370004     BRA 0x57CC
137:               		else if (Flags.Status == WIFI_STATUS_CONNECTED)	WIFI_LED = LED_STATUS_SLOW;	//  1    1    1    1    1
0057C4  404FE8     ADD.B W0, #0x8, [W15]
0057C6  3A0002     BRA NZ, 0x57CC
0057C8  2FF000     MOV #0xFF00, W0
0057CA  8844C0     MOV W0, LedStatus3
138:               	}
139:               
140:               	if (PacketRec)
0057CC  804600     MOV PacketRec, W0
0057CE  E00000     CP0 W0
0057D0  320002     BRA Z, 0x57D6
141:               	{
142:               //		DebugSprintf(tmp,"Tcp Packet - Type: %02X, ID: %04X, Len: %d", PacketRec->type, PacketRec->id, PacketRec->len);
143:               //		DebugPrint(tmp);
144:               		Tcp_PacketReceived(PacketRec);
0057D2  0702B5     RCALL Tcp_PacketReceived
145:               		PacketRec = NULL;
0057D4  EF28C0     CLR PacketRec
146:               	}
147:               	if (PackRecTimeout)
0057D6  E208B6     CP0 PackRecTimeout
0057D8  320007     BRA Z, 0x57E8
148:               	{
149:               		if (!--PackRecTimeout)
0057DA  ED28B6     DEC PackRecTimeout
0057DC  E208B6     CP0 PackRecTimeout
0057DE  3A0188     BRA NZ, 0x5AF0
150:               		{
151:               			FL_WIFI_REC	= 0;
0057E0  A9C92C     BCLR SysFlags, #6
152:               			DebugPrint("Error: Tcp Packet Receive Timeout !!!");
0057E2  2A9AC0     MOV #0xA9AC, W0
0057E4  07FD6C     RCALL Usb_SendText
0057E6  370184     BRA 0x5AF0
153:               		}
154:               		return;
155:               	}
156:               
157:               	Wifi_ResponseAction();
0057E8  07FEFF     RCALL Wifi_ResponseAction
158:               
159:               	if (TimeOut_10mS)
0057EA  E208B2     CP0 TimeOut_10mS
0057EC  320002     BRA Z, 0x57F2
160:               	{
161:               		TimeOut_10mS--;
0057EE  ED28B2     DEC TimeOut_10mS
162:               		return;
0057F0  37017F     BRA 0x5AF0
163:               	}
164:               
165:               	if (lastState != WifiState)			// Wifi state changed
0057F2  804951     MOV 0x92A, W1
0057F4  804930     MOV 0x926, W0
0057F6  508F80     SUB W1, W0, [W15]
0057F8  32000C     BRA Z, 0x5812
166:               	{
167:               		lastState = WifiState;
0057FA  884950     MOV W0, 0x92A
168:               		stateTimeout = 0;
0057FC  EF68CF     CLR.B stateTimeout
169:               		DebugSprintf(tmp, "State nr: %d, Flags: 0x%04X", lastState, Flags.word);
0057FE  F808BE     PUSH Flags
005800  781F80     MOV W0, [W15++]
005802  2A9D20     MOV #0xA9D2, W0
005804  781F80     MOV W0, [W15++]
005806  217340     MOV #0x1734, W0
005808  07DDD1     RCALL __sprintf_cdnopuxX, __sprintf_s, __sprintf_0, __sprintf_cdnopsuxX
170:               		DebugPrint(tmp);
00580A  217340     MOV #0x1734, W0
00580C  07FD58     RCALL Usb_SendText
00580E  5787E6     SUB W15, #0x6, W15
005810  370015     BRA 0x583C
171:               	}
172:               	else if (!++stateTimeout)
005812  EC48CF     INC.B stateTimeout, WREG
005814  B7E8CF     MOV.B WREG, stateTimeout
005816  3A0012     BRA NZ, 0x583C
173:               	{
174:               		#if	(TEST == WIFI_TEST)
175:               			if (!FL_TEST_MANUAL)
005818  AB292C     BTST SysFlags, #1
00581A  3A0010     BRA NZ, 0x583C
176:               		#endif
177:               		{
178:               			DebugSprintf(tmp, "State nr: %d, Flags: 0x%04X - TimeOut Error !!!", lastState, Flags.word);
00581C  F808BE     PUSH Flags
00581E  781F81     MOV W1, [W15++]
005820  2A9EE0     MOV #0xA9EE, W0
005822  781F80     MOV W0, [W15++]
005824  217340     MOV #0x1734, W0
005826  07DDC2     RCALL __sprintf_cdnopuxX, __sprintf_s, __sprintf_0, __sprintf_cdnopsuxX
179:               			DebugPrint(tmp);
005828  217340     MOV #0x1734, W0
00582A  07FD49     RCALL Usb_SendText
180:               			WIFI_RST		= 0;
00582C  A942D9     BCLR 0x2D9, #2
181:               			FL_WIFI_OFFLINE	= 1;
00582E  A8E92C     BSET SysFlags, #7
182:               			WifiState		= WifiState_PowerOn;// Restart Wifi module
005830  200030     MOV #0x3, W0
005832  884930     MOV W0, 0x926
183:               			TimeOut_10mS	= 200;				// Timeout 2.0 sec
005834  200C80     MOV #0xC8, W0
005836  884590     MOV W0, TimeOut_10mS
184:               			return;
005838  5787E6     SUB W15, #0x6, W15
00583A  37015A     BRA 0x5AF0
185:               		}
186:               		// TODO: Change Baudrates
187:               	}
188:               	switch (WifiState)
00583C  804932     MOV 0x926, W2
00583E  EB8000     SETM W0
005840  EB8080     SETM W1
005842  410000     ADD W2, W0, W0
005844  4880E0     ADDC W1, #0x0, W1
005846  500FEF     SUB W0, #0xF, [W15]
005848  588FE0     SUBB W1, #0x0, [W15]
00584A  3E0147     BRA GTU, 0x5ADA
00584C  016000     BRA W0
00584E  37000F     BRA 0x586E
005850  370144     BRA 0x5ADA
005852  370050     BRA 0x58F4
005854  370060     BRA 0x5916
005856  37006A     BRA 0x592C
005858  370092     BRA 0x597E
00585A  370096     BRA 0x5988
00585C  37009E     BRA 0x599A
00585E  3700B0     BRA 0x59C0
005860  3700C8     BRA 0x59F2
005862  3700E2     BRA 0x5A28
005864  3700EA     BRA 0x5A3A
005866  370139     BRA 0x5ADA
005868  370106     BRA 0x5A76
00586A  37010D     BRA 0x5A86
00586C  370130     BRA 0x5ACE
189:               	{
190:               	case WifiState_Idle:		{
191:               		#if	(TEST == WIFI_TEST)
192:               			if (FL_TEST_MANUAL)
00586E  AB292C     BTST SysFlags, #1
005870  320002     BRA Z, 0x5876
193:               			{
194:               				stateTimeout = 0;				// debug mode
005872  EF68CF     CLR.B stateTimeout
195:               				return;
005874  37013D     BRA 0x5AF0
196:               			}
197:               		#endif
198:               		if ((Flags.Status == WIFI_STATUS_IP_OK) && (Flags.ackOk))
005876  2FF011     MOV #0xFF01, W1
005878  8045F0     MOV Flags, W0
00587A  608080     AND W1, W0, W1
00587C  2F0010     MOV #0xF001, W0
00587E  508F80     SUB W1, W0, [W15]
005880  3A0003     BRA NZ, 0x5888
199:               			WifiState = WifiState_Connect;
005882  2000F0     MOV #0xF, W0
005884  884930     MOV W0, 0x926
005886  370034     BRA 0x58F0
200:               		else if (!(WifiSec & AP_CHECK_SEC))		// every 31 sec
005888  8045A0     MOV WifiSec, W0
00588A  60007F     AND W0, #0x1F, W0
00588C  3A0005     BRA NZ, 0x5898
201:               		{
202:               //			FL_WIFI_OFFLINE = 0;
203:               			Uart4_SendText("AT+CWJAP?\r\n");	//	Query Access Point Connection
00588E  2AA1E0     MOV #0xAA1E, W0
005890  07D572     RCALL Uart4_SendText
204:               			Flags.Ack = 0;
005892  EF68BE     CLR.B Flags
205:               			WifiSec++;
005894  EC28B4     INC WifiSec
005896  37002C     BRA 0x58F0
206:               		}
207:               		else if (Flags.Status == WIFI_STATUS_CONNECTED)
005898  BFC8BF     MOV.B 0x8BF, WREG
00589A  404FE8     ADD.B W0, #0x8, [W15]
00589C  3A0029     BRA NZ, 0x58F0
208:               		{
209:               			FL_WIFI_OFFLINE = 0;
00589E  A9E92C     BCLR SysFlags, #7
210:               			if (WifiSec >= WIFI_OK_TIMEOUT_S)
0058A0  200770     MOV #0x77, W0
0058A2  E308B4     CP WifiSec
0058A4  36000E     BRA LEU, 0x58C2
211:               			{
212:               				OkPacket[6] = Rssi.u8l;
0058A6  2178A0     MOV #0x178A, W0
0058A8  208BA1     MOV #0x8BA, W1
0058AA  784091     MOV.B [W1], W1
0058AC  784801     MOV.B W1, [W0]
213:               				OkPacket[7] = Rssi.u8h;
0058AE  E80000     INC W0, W0
0058B0  208BB2     MOV #0x8BB, W2
0058B2  784112     MOV.B [W2], W2
0058B4  784802     MOV.B W2, [W0]
214:               				Tcp_PreparePacket((TCP_PACKET*)OkPacket, TYPE_OK_WIFI);
0058B6  500467     SUB W0, #0x7, W8
0058B8  B3CF11     MOV.B #0xF1, W1
0058BA  780008     MOV W8, W0
0058BC  070200     RCALL Tcp_PreparePacket
215:               				OutPacket = (TCP_PACKET*)OkPacket;
0058BE  884658     MOV W8, OutPacket
0058C0  370004     BRA 0x58CA
216:               			}
217:               			else if (FL_TCP_READY)
0058C2  AB892C     BTST SysFlags, #4
0058C4  320002     BRA Z, 0x58CA
218:               				OutPacket = Tcp_GetUnsent();
0058C6  070224     RCALL Tcp_GetUnsent
0058C8  884650     MOV W0, OutPacket
219:               			
220:               			if (!OutPacket)
0058CA  804651     MOV OutPacket, W1
0058CC  E00001     CP0 W1
0058CE  3A0002     BRA NZ, 0x58D4
221:               				FL_TCP_READY = 0;
0058D0  A9892C     BCLR SysFlags, #4
0058D2  37000E     BRA 0x58F0
222:               			else
223:               			{
224:               //				DebugSprintf(tmp, "Available buffers: %u", Tcp_AvailableOutBuff());
225:               //				DebugPrint(tmp);
226:               				OutPacketLen.u16	= 0;
0058D4  EF28CC     CLR OutPacketLen
227:               				OutPacketLen.u8l	= OutPacket->len;
0058D6  904111     MOV.B [W1+1], W2
0058D8  208CC0     MOV #0x8CC, W0
0058DA  784802     MOV.B W2, [W0]
228:               				OutPacketLen.u16  += TCP_PACKET_HEDER;			//		LEN_CHANGES
0058DC  200080     MOV #0x8, W0
0058DE  B428CC     ADD OutPacketLen
229:               				WifiState = WifiState_SendPacket;
0058E0  2000A0     MOV #0xA, W0
0058E2  884930     MOV W0, 0x926
230:               				WifiSec = 0;
0058E4  EF28B4     CLR WifiSec
231:               				#if	(TEST == WIFI_TEST)
232:               					switch (OutPacket->type)
0058E6  904031     MOV.B [W1+3], W0
0058E8  404FEF     ADD.B W0, #0xF, [W15]
0058EA  3A0002     BRA NZ, 0x58F0
233:               					{
234:               					case TYPE_OK_WIFI:	DebugPrint("Send OK_Wifi Packet");	break;
0058EC  2AA2A0     MOV #0xAA2A, W0
0058EE  07FCE7     RCALL Usb_SendText
235:               //					default:			DebugSprintf(tmp, "Send Wifi Packet: Type_%02X, Len_%03u, Nr_%04X",
236:               //															OutPacket->type, OutPacket->len, OutPacket->nr);
237:               //										DebugPrint(tmp);					break;
238:               					}
239:               				#endif
240:               			}
241:               		}
242:               		stateTimeout = 0;						// temporary
0058F0  EF68CF     CLR.B stateTimeout
243:               		break;					}
0058F2  3700FE     BRA 0x5AF0
244:               	case WifiState_PowerOn:		{
245:               		Flags.word	= 0;
0058F4  EF28BE     CLR Flags
246:               		WIFI_RST	= 1;
0058F6  A842D9     BSET 0x2D9, #2
247:               		WIFI_EN		= !WIFI_EN;
0058F8  8016E0     MOV LATD, W0
0058FA  600061     AND W0, #0x1, W0
0058FC  A20000     BTG W0, #0
0058FE  8016E1     MOV LATD, W1
005900  A10001     BCLR W1, #0
005902  700081     IOR W0, W1, W1
005904  8816E1     MOV W1, LATD
248:               		if (WIFI_EN)							// if not restart
005906  AB02DC     BTST LATD, #0
005908  320003     BRA Z, 0x5910
249:               		{
250:               			Flags.pow	= 1;					// pow Flag on
00590A  A8E8BF     BSET 0x8BF, #7
251:               			Uart4_Init(WifiBaudrate);
00590C  804940     MOV 0x928, W0
00590E  07D478     RCALL Uart4_Init
252:               		}
253:               		TimeOut_10mS = 150;						// Timeout 1.5 sec
005910  200960     MOV #0x96, W0
005912  884590     MOV W0, TimeOut_10mS
254:               		break;					}
005914  3700ED     BRA 0x5AF0
255:               	case WifiState_ComOn:		{
256:               		if (!stateTimeout)
005916  E248CF     CP0.B stateTimeout
005918  3A0004     BRA NZ, 0x5922
257:               		{
258:               			Uart4_SendText("ATE0\r\n");
00591A  2AA3E0     MOV #0xAA3E, W0
00591C  07D52C     RCALL Uart4_SendText
259:               			Flags.Ack = 0;
00591E  EF68BE     CLR.B Flags
005920  3700E7     BRA 0x5AF0
260:               		}
261:               		else if (Flags.ackOk)
005922  AB08BE     BTST Flags, #0
005924  3200E5     BRA Z, 0x5AF0
262:               			WifiState = WifiState_CwMode;
005926  200050     MOV #0x5, W0
005928  884930     MOV W0, 0x926
00592A  3700E2     BRA 0x5AF0
263:               		break;				}
264:               	case WifiState_CwMode:		{				// TODO: Restart module after mode change
265:               		if (!stateTimeout)
00592C  E248CF     CP0.B stateTimeout
00592E  3A0004     BRA NZ, 0x5938
266:               		{
267:               			Uart4_SendText("AT+CWMODE?\r\n");
005930  2AA450     MOV #0xAA45, W0
005932  07D521     RCALL Uart4_SendText
268:               			Flags.Ack = 0;
005934  EF68BE     CLR.B Flags
005936  3700DC     BRA 0x5AF0
269:               		}
270:               		else if (Flags.ackOk)
005938  8045F0     MOV Flags, W0
00593A  A30800     BTST.Z W0, #0
00593C  32000A     BRA Z, 0x5952
271:               		{
272:               			if (Flags.setup)
00593E  A3A800     BTST.Z W0, #10
005940  320003     BRA Z, 0x5948
273:               				WifiState = WifiState_Setup;
005942  2000C0     MOV #0xC, W0
005944  884930     MOV W0, 0x926
005946  3700D4     BRA 0x5AF0
274:               			else
275:               			{
276:               				WifiSec = (AP_CHECK_SEC - 3);
005948  2001C0     MOV #0x1C, W0
00594A  8845A0     MOV W0, WifiSec
277:               				WifiState = WifiState_Idle;
00594C  200010     MOV #0x1, W0
00594E  884930     MOV W0, 0x926
005950  3700CF     BRA 0x5AF0
278:               			}
279:               		}
280:               		else if (Flags.ackData)
005952  A32800     BTST.Z W0, #2
005954  3200CD     BRA Z, 0x5AF0
281:               		{
282:               			register S16 mode = atoi(RecWifiData);
005956  2000A2     MOV #0xA, W2
005958  EB0080     CLR W1
00595A  8045E0     MOV RecWifiData, W0
00595C  07DC71     RCALL __Stoul
00595E  780400     MOV W0, W8
283:               			DebugSprintf(tmp, "Wifi MODE: %u, must be %u", mode, WIFI_MODE);
005960  200032     MOV #0x3, W2
005962  781F82     MOV W2, [W15++]
005964  781F80     MOV W0, [W15++]
005966  2AA520     MOV #0xAA52, W0
005968  781F80     MOV W0, [W15++]
00596A  217340     MOV #0x1734, W0
00596C  07DD1F     RCALL __sprintf_cdnopuxX, __sprintf_s, __sprintf_0, __sprintf_cdnopsuxX
284:               			DebugPrint(tmp);
00596E  217340     MOV #0x1734, W0
005970  07FCA6     RCALL Usb_SendText
285:               			if (mode != WIFI_MODE)
005972  5787E6     SUB W15, #0x6, W15
005974  540FE3     SUB W8, #0x3, [W15]
005976  320001     BRA Z, 0x597A
286:               				Flags.setup = 1;
005978  A848BF     BSET 0x8BF, #2
287:               			Flags.Ack = 0;
00597A  EF68BE     CLR.B Flags
00597C  3700B9     BRA 0x5AF0
288:               		}
289:               		break;					}
290:               	case WifiState_NoAp:		{
291:               		FL_WIFI_OFFLINE = 1;
00597E  A8E92C     BSET SysFlags, #7
292:               		Flags.Status = WIFI_STATUS_COM;			// pow=1, com=1, ap=0, ip=0, conected=0
005980  B3CC00     MOV.B #0xC0, W0
005982  B7E8BF     MOV.B WREG, 0x8BF
293:               		if (!Flags.ackOk)
005984  AB08BE     BTST Flags, #0
005986  3200B4     BRA Z, 0x5AF0
294:               			break;				}
295:               	case WifiState_ListAp:		{
296:               		Uart4_SendText("AT+CWLAP\r\n");
005988  2AA6C0     MOV #0xAA6C, W0
00598A  07D4F5     RCALL Uart4_SendText
297:               		TimeOut_10mS = 1000;					// Timeout 10 sec;
00598C  203E80     MOV #0x3E8, W0
00598E  884590     MOV W0, TimeOut_10mS
298:               		Flags.Ack = 0;
005990  EF68BE     CLR.B Flags
299:               		VisibleApCount = 0;
005992  EF28B8     CLR VisibleApCount
300:               		WifiState = WifiState_ListApRec;
005994  200080     MOV #0x8, W0
005996  884930     MOV W0, 0x926
301:               		break;					}
005998  3700AB     BRA 0x5AF0
302:               	case WifiState_ListApRec:	{
303:               		if (Flags.ackOk)
00599A  8045F0     MOV Flags, W0
00599C  A30800     BTST.Z W0, #0
00599E  320004     BRA Z, 0x59A8
304:               		{
305:               			Wifi_CheckWisibleSsid();
0059A0  07FEB2     RCALL Wifi_CheckWisibleSsid
306:               			WifiState = WifiState_Idle;
0059A2  200010     MOV #0x1, W0
0059A4  884930     MOV W0, 0x926
0059A6  3700A4     BRA 0x5AF0
307:               		}
308:               		else if (Flags.ackErr)
0059A8  A31800     BTST.Z W0, #1
0059AA  320005     BRA Z, 0x59B6
309:               		{
310:               			DebugPrint("Wifi Access Point List Error");
0059AC  2AA770     MOV #0xAA77, W0
0059AE  07FC87     RCALL Usb_SendText
311:               			WifiState = WifiState_Idle;
0059B0  200010     MOV #0x1, W0
0059B2  884930     MOV W0, 0x926
0059B4  37009D     BRA 0x5AF0
312:               		}
313:               		else if (Flags.ackData)
0059B6  A32800     BTST.Z W0, #2
0059B8  32009B     BRA Z, 0x5AF0
314:               		{
315:               			Wifi_SaveWisibleSsid();
0059BA  07FE55     RCALL Wifi_SaveWisibleSsid
316:               			Flags.Ack = 0;
0059BC  EF68BE     CLR.B Flags
0059BE  370098     BRA 0x5AF0
317:               		}
318:               		break;					}
319:               	case WifiState_CWJAP:		{
320:               		register U8 i = 0, j = 0;
0059C4  EB4200     CLR.B W4
0059C6  784084     MOV.B W4, W1
321:               		FL_WIFI_OFFLINE = 0;
0059C0  A9E92C     BCLR SysFlags, #7
322:               		while (RecWifiData[i])
0059C2  8045E0     MOV RecWifiData, W0
0059CA  370004     BRA 0x59D4
0059D4  FB8101     ZE W1, W2
0059D6  794160     MOV.B [W0+W2], W2
0059D8  E00402     CP0.B W2
0059DA  3AFFF8     BRA NZ, 0x59CC
323:               		{
324:               			if (RecWifiData[i++] != ',')	// search last ',' in string
0059C8  B3C2C3     MOV.B #0x2C, W3
0059CC  E84081     INC.B W1, W1
0059CE  514F83     SUB.B W2, W3, [W15]
0059D0  3A0001     BRA NZ, 0x59D4
325:               				continue;
326:               			j = i;							// point j to next char
0059D2  784201     MOV.B W1, W4
327:               		}
328:               		if (RecWifiData[j])
0059DC  FB8204     ZE W4, W4
0059DE  400004     ADD W0, W4, W0
0059E0  E00410     CP0.B [W0]
0059E2  320004     BRA Z, 0x59EC
329:               			Rssi.s16 = atoi(&RecWifiData[j]);	// +CWJAP:"Mazais","a0:f3:c1:b5:af:00",3,-55
0059E4  2000A2     MOV #0xA, W2
0059E6  EB0080     CLR W1
0059E8  07DC2B     RCALL __Stoul
0059EA  8845D0     MOV W0, Rssi
330:               		
331:               		WifiState = WifiState_Idle;
0059EC  200010     MOV #0x1, W0
0059EE  884930     MOV W0, 0x926
332:               		break;					}
0059F0  37007F     BRA 0x5AF0
333:               	case WifiState_SendPacket:	{
334:               		if (!stateTimeout)
0059F2  E248CF     CP0.B stateTimeout
0059F4  3A000A     BRA NZ, 0x5A0A
335:               		{
336:               			Flags.Ack = 0;
0059F6  EF68BE     CLR.B Flags
337:               			sprintf(WifiBuf,"AT+CIPSEND=%d\r\n",OutPacketLen.u16);
0059F8  F808CC     PUSH OutPacketLen
0059FA  2AA940     MOV #0xAA94, W0
0059FC  781F80     MOV W0, [W15++]
0059FE  213340     MOV #0x1334, W0
005A00  07DCD5     RCALL __sprintf_cdnopuxX, __sprintf_s, __sprintf_0, __sprintf_cdnopsuxX
338:               			Uart4_SendText(WifiBuf);
005A02  213340     MOV #0x1334, W0
005A04  07D4B8     RCALL Uart4_SendText
005A06  5787E4     SUB W15, #0x4, W15
005A08  370073     BRA 0x5AF0
339:               		}
340:               		else if (Flags.ackOk)
005A0A  AB08BE     BTST Flags, #0
005A0C  320071     BRA Z, 0x5AF0
341:               		{
342:               			if ((Uart4_ByteReceived()) && (Uart4_GetByte() == '>'))
005A0E  07D481     RCALL Uart4_ByteReceived
005A10  E00400     CP0.B W0
005A12  32006E     BRA Z, 0x5AF0
005A14  07D486     RCALL Uart4_GetByte
005A16  B3C3E1     MOV.B #0x3E, W1
005A18  504F81     SUB.B W0, W1, [W15]
005A1A  3A006A     BRA NZ, 0x5AF0
343:               			{
344:               //				while (Uart4_ByteReceived())
345:               //					Uart4_GetByte();
346:               				Uart4_SendData((char*)OutPacket->bytes, OutPacketLen.u16);
005A1C  804661     MOV OutPacketLen, W1
005A1E  804650     MOV OutPacket, W0
005A20  07D4B5     RCALL Uart4_SendData
347:               				TimeOut_10mS = 3000;			// Timeout 30 sec
005A22  20BB80     MOV #0xBB8, W0
005A24  884590     MOV W0, TimeOut_10mS
005A26  370064     BRA 0x5AF0
348:               //				WifiState = WifiState_Idle;
349:               			}
350:               		}
351:               		break;					}
352:               	case WifiState_SendOk:		{
353:               		if (OutPacket != (TCP_PACKET*)OkPacket)
005A28  804650     MOV OutPacket, W0
005A2A  217841     MOV #0x1784, W1
005A2C  500F81     SUB W0, W1, [W15]
005A2E  320001     BRA Z, 0x5A32
354:               			OutPacket->start = 0;
005A30  EB4800     CLR.B [W0]
355:               		OutPacket = NULL;
005A32  EF28CA     CLR OutPacket
356:               		WifiState = WifiState_Idle;
005A34  200010     MOV #0x1, W0
005A36  884930     MOV W0, 0x926
357:               		break;					}
005A38  37005B     BRA 0x5AF0
358:               	case WifiState_Setup:		{
359:               		if (!stateTimeout)
005A3A  E248CF     CP0.B stateTimeout
005A3C  3A0012     BRA NZ, 0x5A62
360:               		{
361:               			sprintf(WifiBuf,"AT+CWMODE=%d\r\n", WIFI_MODE);
005A3E  200038     MOV #0x3, W8
005A40  781F88     MOV W8, [W15++]
005A42  2AAA40     MOV #0xAAA4, W0
005A44  781F80     MOV W0, [W15++]
005A46  213340     MOV #0x1334, W0
005A48  07DCB1     RCALL __sprintf_cdnopuxX, __sprintf_s, __sprintf_0, __sprintf_cdnopsuxX
362:               			Uart4_SendText(WifiBuf);
005A4A  213340     MOV #0x1334, W0
005A4C  07D494     RCALL Uart4_SendText
363:               			Flags.Ack = 0;
005A4E  EF68BE     CLR.B Flags
364:               			DebugSprintf(tmp, "Set CwMode to %u", WIFI_MODE);
005A50  781F88     MOV W8, [W15++]
005A52  2AAB30     MOV #0xAAB3, W0
005A54  781F80     MOV W0, [W15++]
005A56  217340     MOV #0x1734, W0
005A58  07DCA9     RCALL __sprintf_cdnopuxX, __sprintf_s, __sprintf_0, __sprintf_cdnopsuxX
365:               			DebugPrint(tmp);
005A5A  217340     MOV #0x1734, W0
005A5C  07FC30     RCALL Usb_SendText
005A5E  5787E8     SUB W15, #0x8, W15
005A60  370047     BRA 0x5AF0
366:               		}
367:               		else if (Flags.ackOk)
005A62  AB08BE     BTST Flags, #0
005A64  320045     BRA Z, 0x5AF0
368:               		{
369:               			DebugPrint("Ok - Reset module");
005A66  2AAC40     MOV #0xAAC4, W0
005A68  07FC2A     RCALL Usb_SendText
370:               			WIFI_RST = 0;
005A6A  A942D9     BCLR 0x2D9, #2
371:               			WifiState = WifiState_PowerOn;		// Restart Wifi module
005A6C  200030     MOV #0x3, W0
005A6E  884930     MOV W0, 0x926
372:               			TimeOut_10mS = 20;					// Timeout 0.2 sec
005A70  200140     MOV #0x14, W0
005A72  884590     MOV W0, TimeOut_10mS
005A74  37003D     BRA 0x5AF0
373:               		}
374:               		break;					}
375:               	case WifiState_Disconnect:	{
376:               		Flags.Status &= WIFI_STATUS_COM;
005A76  B3CC00     MOV.B #0xC0, W0
005A78  208BF1     MOV #0x8BF, W1
005A7A  784091     MOV.B [W1], W1
005A7C  60C000     AND.B W1, W0, W0
005A7E  B7E8BF     MOV.B WREG, 0x8BF
377:               		WifiState = WifiState_Idle;
005A80  200010     MOV #0x1, W0
005A82  884930     MOV W0, 0x926
378:               		break;					}
005A84  370035     BRA 0x5AF0
379:               	case WifiState_Connect:		{
380:               		if (!stateTimeout)
005A86  BFC8CF     MOV.B stateTimeout, WREG
005A88  3A000D     BRA NZ, 0x5AA4
381:               		{
382:               			Flags.Ack = 0;
005A8A  EF68BE     CLR.B Flags
383:               			Uart4_SendText("AT+CIPSTART=\"TCP\",\"");
005A8C  2AAD60     MOV #0xAAD6, W0
005A8E  07D473     RCALL Uart4_SendText
384:               			Uart4_SendText(SERVER);
005A90  2AAEA0     MOV #0xAAEA, W0
005A92  07D471     RCALL Uart4_SendText
385:               			Uart4_SendText("\",");
005A94  2AAFB0     MOV #0xAAFB, W0
005A96  07D46F     RCALL Uart4_SendText
386:               			Uart4_SendText(PORT);
005A98  2AAFE0     MOV #0xAAFE, W0
005A9A  07D46D     RCALL Uart4_SendText
387:               			Uart4_SendEnter();
005A9C  07D482     RCALL Uart4_SendEnter
388:               			DebugPrint("Wifi Connect Command");
005A9E  2AB040     MOV #0xAB04, W0
005AA0  07FC0E     RCALL Usb_SendText
005AA2  370026     BRA 0x5AF0
389:               		}
390:               		else if (Flags.ackOk)
005AA4  AB08BE     BTST Flags, #0
005AA6  320009     BRA Z, 0x5ABA
391:               		{
392:               			WifiState = WifiState_Idle;
005AA8  200010     MOV #0x1, W0
005AAA  884930     MOV W0, 0x926
393:               			WifiSec	= WIFI_OK_TIMEOUT_S;
005AAC  200780     MOV #0x78, W0
005AAE  8845A0     MOV W0, WifiSec
394:               			DebugPrint("Wifi Connect Ok -> wait connection 90sec");
005AB0  2AB190     MOV #0xAB19, W0
005AB2  07FC05     RCALL Usb_SendText
395:               			TimeOut_10mS = 9000;			// Timeout 90 sec
005AB4  223280     MOV #0x2328, W0
005AB6  884590     MOV W0, TimeOut_10mS
005AB8  37001B     BRA 0x5AF0
396:               		}
397:               		else if (stateTimeout > 200)
005ABA  B3CC81     MOV.B #0xC8, W1
005ABC  504F81     SUB.B W0, W1, [W15]
005ABE  360018     BRA LEU, 0x5AF0
398:               		{
399:               			DebugPrint("Wifi Connect Command Error -> tray after 10 sec");
005AC0  2AB420     MOV #0xAB42, W0
005AC2  07FBFD     RCALL Usb_SendText
400:               			WifiState = WifiState_Idle;
005AC4  200010     MOV #0x1, W0
005AC6  884930     MOV W0, 0x926
401:               			TimeOut_10mS = 1000;
005AC8  203E80     MOV #0x3E8, W0
005ACA  884590     MOV W0, TimeOut_10mS
005ACC  370011     BRA 0x5AF0
402:               		}
403:               		break;					}
404:               	case WifiState_Closed:		{
405:               		Flags.conected	= 0;
005ACE  A968BF     BCLR 0x8BF, #3
406:               		WifiSec = AP_CHECK_SEC - 1;
005AD0  2001E0     MOV #0x1E, W0
005AD2  8845A0     MOV W0, WifiSec
407:               		WifiState = WifiState_Idle;
005AD4  200010     MOV #0x1, W0
005AD6  884930     MOV W0, 0x926
408:               		break;					}
005AD8  37000B     BRA 0x5AF0
409:               	default:					{
410:               		DebugSprintf(tmp, "State nr: %d, Flags: 0x%04X - State Error !!!", WifiState, Flags.word);
005ADA  F808BE     PUSH Flags
005ADC  781F82     MOV W2, [W15++]
005ADE  2AB720     MOV #0xAB72, W0
005AE0  781F80     MOV W0, [W15++]
005AE2  217340     MOV #0x1734, W0
005AE4  07DC63     RCALL __sprintf_cdnopuxX, __sprintf_s, __sprintf_0, __sprintf_cdnopsuxX
411:               		DebugPrint(tmp);
005AE6  217340     MOV #0x1734, W0
005AE8  07FBEA     RCALL Usb_SendText
412:               		WifiState = WifiState_Idle;
005AEA  200010     MOV #0x1, W0
005AEC  884930     MOV W0, 0x926
413:               		break;					}
005AEE  5787E6     SUB W15, #0x6, W15
414:               	}
415:               }
005AF0  78044F     MOV [--W15], W8
005AF2  BE034F     MOV.D [--W15], W6
005AF4  BE024F     MOV.D [--W15], W4
005AF6  BE014F     MOV.D [--W15], W2
005AF8  BE004F     MOV.D [--W15], W0
005AFA  F90036     POP RCOUNT
005AFC  064000     RETFIE
416:               
417:               inline	void	WifiPacketReceive	(U8 data)
418:               {
419:               	static TCP_PACKET*	inPacket;
420:               	static U8			currentPacket = 0, crc;
421:               	static U16			idx = 0;
422:               	static UNI16		recLen;
423:               
424:               	if (!FL_WIFI_REC)
00558A  ABC92C     BTST SysFlags, #6
00558C  3A0011     BRA NZ, 0x55B0
425:               	{
426:               		if (!Flags.conected)
00558E  AB68BF     BTST 0x8BF, #3
005590  32002A     BRA Z, 0x55E6
427:               			return;
428:               		FL_WIFI_REC	= 1;				// Set flag to receive WIFI packet
005592  A8C92C     BSET SysFlags, #6
429:               		PackRecTimeout = TCP_PACKET_TIMEOUT;
005594  200281     MOV #0x28, W1
005596  8845B1     MOV W1, PackRecTimeout
430:               		currentPacket ^= 1;				// change to ather packet buffer
005598  208C71     MOV #0x8C7, W1
00559A  784091     MOV.B [W1], W1
00559C  A20401     BTG.B W1, #0
00559E  208C72     MOV #0x8C7, W2
0055A0  784901     MOV.B W1, [W2]
431:               		inPacket	= &PacketIn[currentPacket];	// Recive pointer to free buffer
0055A2  DD08C8     SL W1, #8, W1
0055A4  215342     MOV #0x1534, W2
0055A6  408082     ADD W1, W2, W1
0055A8  884641     MOV W1, inPacket
432:               		idx			= 0;				// buffer index = 0
0055AA  EF28C4     CLR idx
433:               		crc			= 0;				// clear crc
0055AC  EF68C6     CLR.B crc
434:               		recLen.u16  = 0;
0055AE  EF28C2     CLR recLen
435:               	}
436:               	inPacket->bytes[idx++] = data;		// save current byte
0055B0  804642     MOV inPacket, W2
0055B2  804621     MOV idx, W1
0055B4  78F100     MOV.B W0, [W2+W1]
0055B6  E80081     INC W1, W1
0055B8  884621     MOV W1, idx
437:               	if (idx > 3)						// if Start, Lenght, CRC bytes already received
0055BA  508FE3     SUB W1, #0x3, [W15]
0055BC  36000D     BRA LEU, 0x55D8
438:               	{
439:               		crc ^= data;					// calculate crc
0055BE  B6C8C6     XOR.B crc, WREG
0055C0  B7E8C6     MOV.B WREG, crc
440:               		if (idx >= recLen.u16)		// if packet len bytes received		LEN_CHANGES
0055C2  804613     MOV recLen, W3
0055C4  518F81     SUB W3, W1, [W15]
0055C6  3E000F     BRA GTU, 0x55E6
441:               		{
442:               			FL_WIFI_REC		= 0;		// turn off tcp packet receive
0055C8  A9C92C     BCLR SysFlags, #6
443:               			PackRecTimeout	= 0;
0055CA  EF28B6     CLR PackRecTimeout
444:               			if (crc == inPacket->crc)	// if crc ok
0055CC  9040A2     MOV.B [W2+2], W1
0055CE  504F81     SUB.B W0, W1, [W15]
0055D0  3A000A     BRA NZ, 0x55E6
445:               			{
446:               				PacketRec	= inPacket;
0055D2  884602     MOV W2, PacketRec
447:               				WIFI_IF		= 1;		// enable Wifi IRQ
0055D4  A8208A     BSET IFS3, #1
0055D6  370007     BRA 0x55E6
448:               			}
449:               //			U8* ptr = inPacket->bytes;
450:               //			DebugSprintf(gsmBuff,"%02X %02X %02X(%02X) %02X %02X %02X %02X %02X",
451:               //						ptr[0], ptr[1], ptr[2], crc, ptr[3], ptr[4], ptr[5], ptr[6], ptr[7]);
452:               //			DebugPrint(gsmBuff);
453:               		}
454:               	}
455:               	else if (idx == 2)											//		LEN_CHANGES
0055D8  508FE2     SUB W1, #0x2, [W15]
0055DA  3A0005     BRA NZ, 0x55E6
456:               	{
457:               		recLen.u8l  = inPacket->len;
0055DC  904092     MOV.B [W2+1], W1
0055DE  208C20     MOV #0x8C2, W0
0055E0  784801     MOV.B W1, [W0]
458:               		recLen.u16 += TCP_PACKET_HEDER;
0055E2  200080     MOV #0x8, W0
0055E4  B428C2     ADD recLen
459:               	}
460:               }
0055E6  060000     RETURN
461:               
462:               inline	void Wifi_ResponseAction	(void)
463:               {
0055E8  BE9F88     MOV.D W8, [W15++]
0055EA  BE9F8A     MOV.D W10, [W15++]
464:               	while (Uart4_StringReceived())
0055EE  370035     BRA 0x565A
00565A  07D661     RCALL Uart4_StringReceived
00565C  E00400     CP0.B W0
00565E  3AFFC8     BRA NZ, 0x55F0
465:               	{
466:               		register char d = WifiBuf[0];
0055EC  213348     MOV #0x1334, W8
0055F0  784498     MOV.B [W8], W9
467:               		Uart4_GetString((P_U8)WifiBuf);
0055F2  780008     MOV W8, W0
0055F4  07D6B2     RCALL Uart4_GetString
468:               		if (!WifiBuf[0])						// if received string is empty
0055F6  E00418     CP0.B [W8]
0055F8  3A0002     BRA NZ, 0x55FE
469:               		{	WifiBuf[0] = d;	continue;	}		// restore previous value of buffer ("" = '\0')
0055FA  784C09     MOV.B W9, [W8]
0055FC  37002E     BRA 0x565A
470:               
471:               		#if	(TEST == WIFI_TEST)
472:               			if (FL_TEST_MANUAL)
0055FE  AB292C     BTST SysFlags, #1
005600  320003     BRA Z, 0x5608
473:               			{
474:               				DebugPrint(WifiBuf);
005602  213340     MOV #0x1334, W0
005604  07FE5C     RCALL Usb_SendText
475:               				return;
005606  37002C     BRA 0x5660
476:               			}
477:               		#endif
478:               		
479:               		Flags.Ack = 0b1000;
005608  B3C080     MOV.B #0x8, W0
00560A  B7E8BE     MOV.B WREG, Flags
00560C  2AC848     MOV #0xAC84, W8
480:               		register U16 i;
481:               		for(i = 0; i < (sizeof(WifiResponses) / sizeof(WIFI_RESPONSE)); i++)
00560E  EB0480     CLR W9
005648  E80489     INC W9, W9
00564A  44046A     ADD W8, #0xA, W8
00564C  548FF7     SUB W9, #0x17, [W15]
00564E  3AFFE1     BRA NZ, 0x5612
482:               		{
483:               			if(!(memcmp(WifiBuf, WifiResponses[i].text, WifiResponses[i].size)))
005610  21334B     MOV #0x1334, W11
005612  FB8518     ZE [W8], W10
005614  97B8F8     MOV [W8-2], W1
005616  78010A     MOV W10, W2
005618  78000B     MOV W11, W0
00561A  07DDED     RCALL _memcmp
00561C  E00000     CP0 W0
00561E  3A0014     BRA NZ, 0x5648
484:               			{
485:               				if (WifiResponses[i].newState)
005620  B9486A     MUL.SU W9, #10, W0
005622  400064     ADD W0, #0x4, W0
005624  2AC821     MOV #0xAC82, W1
005626  780061     MOV [W1+W0], W0
005628  E00000     CP0 W0
00562A  320001     BRA Z, 0x562E
486:               					WifiState = WifiResponses[i].newState;
00562C  884930     MOV W0, 0x926
487:               				TimeOut_10mS = WifiResponses[i].newTimeout;
00562E  B9486A     MUL.SU W9, #10, W0
005630  780480     MOV W0, W9
005632  4480E6     ADD W9, #0x6, W1
005634  2AC820     MOV #0xAC82, W0
005636  7880E0     MOV [W0+W1], W1
005638  884591     MOV W1, TimeOut_10mS
488:               				Flags.word |= WifiResponses[i].orFlags;
00563A  4484E8     ADD W9, #0x8, W9
00563C  7C8060     MOV [W0+W9], W0
00563E  B728BE     IOR Flags
489:               				RecWifiData = WifiBuf + WifiResponses[i].size;
005640  213340     MOV #0x1334, W0
005642  450500     ADD W10, W0, W10
005644  8845EA     MOV W10, RecWifiData
490:               				#ifdef	SHOW_AT_RESPONSE
491:               					DebugPrint(WifiBuf);
492:               //					DebugPrint(RecWifiData);
493:               				#endif
494:               				return;
005646  37000C     BRA 0x5660
495:               			}
496:               		}
497:               		DebugPrint(WifiBuf);
005650  213340     MOV #0x1334, W0
005652  07FE35     RCALL Usb_SendText
498:               		RecWifiData = WifiBuf;
005654  213340     MOV #0x1334, W0
005656  8845E0     MOV W0, RecWifiData
499:               		return;
005658  370003     BRA 0x5660
500:               	}
501:               }
005660  BE054F     MOV.D [--W15], W10
005662  BE044F     MOV.D [--W15], W8
005664  060000     RETURN
502:               
503:               // +CWLAP:(3,"Mazais",-52,"a0:f3:c1:b5:af:00",3,-21)
504:               inline void Wifi_SaveWisibleSsid	(void)
0056C6  E88102     INC2 W2, W2
505:               {
005666  781F88     MOV W8, [W15++]
506:               	if (VisibleApCount >= MAX_VISIBLE_AP)		return;
005668  8045C8     MOV VisibleApCount, W8
00566A  540FF3     SUB W8, #0x13, [W15]
00566C  3E004A     BRA GTU, 0x5702
00566E  8045E1     MOV RecWifiData, W1
507:               	while ((*RecWifiData < '0') || (*RecWifiData > '9'))
005670  B3CD04     MOV.B #0xD0, W4
005672  370004     BRA 0x567C
00567E  784131     MOV.B [W1++], W2
005680  414184     ADD.B W2, W4, W3
005682  51CFE9     SUB.B W3, #0x9, [W15]
005684  3EFFF7     BRA GTU, 0x5674
005686  8845E0     MOV W0, RecWifiData
508:               	{
509:               		if(!*RecWifiData++)						return;
005674  E00402     CP0.B W2
005676  3A0002     BRA NZ, 0x567C
005678  8845E1     MOV W1, RecWifiData
00567A  370043     BRA 0x5702
00567C  780001     MOV W1, W0
510:               	}
511:               	VisibleAPs[VisibleApCount].ecn = atoi(RecWifiData);		// 3
005688  2000A2     MOV #0xA, W2
00568A  EB0080     CLR W1
00568C  07DDD9     RCALL __Stoul
00568E  BE0100     MOV.D W0, W2
005690  DD4447     SL W8, #7, W8
005692  209B21     MOV #0x9B2, W1
005694  78B402     MOV W2, [W8+W1]
005696  8045E0     MOV RecWifiData, W0
512:               	while (*RecWifiData != '"')								// "
005698  B3C223     MOV.B #0x22, W3
00569A  370004     BRA 0x56A4
0056A6  7840B0     MOV.B [W0++], W1
0056A8  50CF83     SUB.B W1, W3, [W15]
0056AA  3AFFF8     BRA NZ, 0x569C
513:               	{
514:               		if(!*RecWifiData++)						return;
00569C  E00401     CP0.B W1
00569E  3A0002     BRA NZ, 0x56A4
0056A0  8845E0     MOV W0, RecWifiData
0056A2  37002F     BRA 0x5702
0056A4  780100     MOV W0, W2
515:               	}
516:               	RecWifiData++;											// M
0056AC  E80002     INC W2, W0
0056AE  8845E0     MOV W0, RecWifiData
517:               	char* ptr = VisibleAPs[VisibleApCount].ssid;
0056B0  8045C8     MOV VisibleApCount, W8
0056B2  DD4247     SL W8, #7, W4
0056B4  209341     MOV #0x934, W1
0056B6  420201     ADD W4, W1, W4
518:               	while (*RecWifiData != '"')
0056B8  784090     MOV.B [W0], W1
0056BA  B3C223     MOV.B #0x22, W3
0056BC  50CF83     SUB.B W1, W3, [W15]
0056BE  320010     BRA Z, 0x56E0
0056C8  B3C225     MOV.B #0x22, W5
0056CA  370004     BRA 0x56D4
0056DA  7840B2     MOV.B [W2++], W1
0056DC  50CF85     SUB.B W1, W5, [W15]
0056DE  3AFFF6     BRA NZ, 0x56CC
519:               	{
520:               		if(!*RecWifiData)						return;
0056C0  E00401     CP0.B W1
0056C2  32001F     BRA Z, 0x5702
0056C4  780184     MOV W4, W3
0056CC  E00401     CP0.B W1
0056CE  3A0002     BRA NZ, 0x56D4
0056D0  8845E0     MOV W0, RecWifiData
0056D2  370017     BRA 0x5702
521:               		*ptr++ = *RecWifiData++;							// Mazais
0056D4  785981     MOV.B W1, [W3++]
0056D6  780203     MOV W3, W4
0056D8  780002     MOV W2, W0
522:               	}
523:               	*ptr = '\0';
0056E0  EB4A00     CLR.B [W4]
524:               	RecWifiData++;
525:               	if (*RecWifiData++ != ',')					return;
0056E2  E80000     INC W0, W0
0056E4  784130     MOV.B [W0++], W2
0056E6  8845E0     MOV W0, RecWifiData
0056E8  B3C2C1     MOV.B #0x2C, W1
0056EA  514F81     SUB.B W2, W1, [W15]
0056EC  3A000A     BRA NZ, 0x5702
526:               	if(!*RecWifiData)							return;
0056EE  E00410     CP0.B [W0]
0056F0  320008     BRA Z, 0x5702
527:               	VisibleAPs[VisibleApCount].rssi = atoi(RecWifiData);	// -52
0056F2  2000A2     MOV #0xA, W2
0056F4  EB0080     CLR W1
0056F6  07DDA4     RCALL __Stoul
0056F8  BE0100     MOV.D W0, W2
0056FA  DD4447     SL W8, #7, W8
0056FC  209B01     MOV #0x9B0, W1
0056FE  78B402     MOV W2, [W8+W1]
528:               
529:               	VisibleApCount++;
005700  EC28B8     INC VisibleApCount
530:               }
005702  78044F     MOV [--W15], W8
005704  060000     RETURN
531:               
532:               inline void Wifi_CheckWisibleSsid	(void)
533:               {
005706  BE9F88     MOV.D W8, [W15++]
005708  BE9F8A     MOV.D W10, [W15++]
00570A  BE9F8C     MOV.D W12, [W15++]
00570C  781F8E     MOV W14, [W15++]
005716  EB0700     CLR W14
005760  78040E     MOV W14, W8
534:               	if (!VisibleApCount)
00570E  8045CD     MOV VisibleApCount, W13
005710  E0000D     CP0 W13
005712  32002C     BRA Z, 0x576C
005714  EB0600     CLR W12
535:               		return;
536:               	U16 i, j;
537:               	for (i = 0; i < VisibleApCount; i++)
00575A  E8060C     INC W12, W12
00575C  568F8C     SUB W13, W12, [W15]
00575E  360005     BRA LEU, 0x576A
538:               	{
539:               //		DebugSprintf(tmp,"SSID: '%s', ecn: %d, rssi: %d", VisibleAPs[i].ssid, VisibleAPs[i].ecn, VisibleAPs[i].rssi);
540:               //		DebugPrint(tmp);
541:               //		DebugSprintf(tmp, "Visible AP: %d, Flags: 0x%04X", i, Flags.word);
542:               //		DebugPrint(tmp);
543:               		for (j = 0; j < (sizeof(WifiAccessPoints) / sizeof(WIFI_ACCESS_POINT)); j++)
005754  E80408     INC W8, W8
005756  540FE9     SUB W8, #0x9, [W15]
005758  3AFFE1     BRA NZ, 0x571C
544:               		{
545:               			if (!strcmp(VisibleAPs[i].ssid, WifiAccessPoints[j].ssid))
005718  2AD68B     MOV #0xAD68, W11
00571A  370022     BRA 0x5760
00571C  DD44C7     SL W8, #7, W9
00571E  44848B     ADD W9, W11, W9
005720  780089     MOV W9, W1
005722  78000A     MOV W10, W0
005724  07DD7D     RCALL _strcmp
005726  E00000     CP0 W0
005728  3A0015     BRA NZ, 0x5754
005762  DD6547     SL W12, #7, W10
005764  209340     MOV #0x934, W0
005766  450500     ADD W10, W0, W10
005768  37FFD9     BRA 0x571C
546:               			{
547:               				Uart4_SendText("AT+CWJAP=\"");
00572A  2A9990     MOV #0xA999, W0
00572C  07D624     RCALL Uart4_SendText
548:               				Uart4_SendText(WifiAccessPoints[j].ssid);
00572E  780009     MOV W9, W0
005730  07D622     RCALL Uart4_SendText
549:               				Uart4_SendText("\",\"");
005732  2A9A40     MOV #0xA9A4, W0
005734  07D620     RCALL Uart4_SendText
550:               				Uart4_SendText(WifiAccessPoints[j].psw);
005736  DD4447     SL W8, #7, W8
005738  2ADA40     MOV #0xADA4, W0
00573A  440000     ADD W8, W0, W0
00573C  07D61C     RCALL Uart4_SendText
551:               				Uart4_SendText("\"\r\n");
00573E  2A9A80     MOV #0xA9A8, W0
005740  07D61A     RCALL Uart4_SendText
552:               				TimeOut_10mS = 1000;					// Timeout 10 sec;
005742  203E80     MOV #0x3E8, W0
005744  884590     MOV W0, TimeOut_10mS
553:               				Rssi.s16 = VisibleAPs[VisibleApCount].rssi;
005746  8045C0     MOV VisibleApCount, W0
005748  DD0047     SL W0, #7, W0
00574A  B007C0     ADD #0x7C, W0
00574C  209341     MOV #0x934, W1
00574E  7800E1     MOV [W1+W0], W1
005750  8845D1     MOV W1, Rssi
554:               //				DebugSprintf(tmp, "Found AP: %d, Flags: 0x%04X", j, Flags.word);
555:               //				DebugPrint(tmp);
556:               				return;
005752  37000C     BRA 0x576C
557:               			}
558:               		}
559:               	}
560:               	// TODO Check free APs
561:               //	VisibleApCount = 0;
562:               	FL_WIFI_OFFLINE = 1;
00576A  A8E92C     BSET SysFlags, #7
563:               }
00576C  78074F     MOV [--W15], W14
00576E  BE064F     MOV.D [--W15], W12
005770  BE054F     MOV.D [--W15], W10
005772  BE044F     MOV.D [--W15], W8
005774  060000     RETURN
564:               #else
565:               U8	 Wifi_Connected	(void)
566:               {
567:                   return 0;
568:               }
569:               #endif  //  UART4_WIFI
570:               
---  /home/pele/src/Auto_02/src/Uart4.c  ----------------------------------------------------------------
1:                 #include	"Uart4.h"
2:                 #include	"Ports.h"
3:                 
4:                 #ifdef UART4_WIFI
5:                 
6:                 #define	UART4_TX		U4STAbits.UTXEN
7:                 #define	UART4_RX		U4MODEbits.UARTEN
8:                 
9:                 static	volatile U8		TxBuff[256];
10:                static	volatile U8		RxBuff[256];
11:                static	volatile U8		TxWrite, TxSent, RxRec, RxRead, Enter;
12:                
13:                extern OSC			Oscillator;
14:                extern const U16	BaudRates[5][8];
15:                
16:                // BaudRate_9600
17:                // BaudRate_19200
18:                // BaudRate_38400
19:                // BaudRate_57600
20:                // BaudRate_115200
21:                void Uart4_Init(BAUDRATE br)
22:                {
23:                	U4MODE		= 0;				//	UART reset
000200  EF22B0     CLR U4MODE
24:                	U4STA		= 0;
000202  EF22B2     CLR U4STA
25:                	U4BRG		= BaudRates[br][Oscillator];	//	BAUD Rate
000204  DD0043     SL W0, #3, W0
000206  804851     MOV 0x90A, W1
000208  400001     ADD W0, W1, W0
00020A  400000     ADD W0, W0, W0
00020C  2B57E1     MOV #0xB57E, W1
00020E  7800E1     MOV [W1+W0], W1
000210  8815C1     MOV W1, U4BRG
26:                
27:                	TxWrite = TxSent = RxRec = RxRead = Enter = 0;
000212  EF6920     CLR.B Enter
000214  209201     MOV #0x920, W1
000216  784091     MOV.B [W1], W1
000218  209230     MOV #0x923, W0
00021A  784801     MOV.B W1, [W0]
00021C  209231     MOV #0x923, W1
00021E  784091     MOV.B [W1], W1
000220  209240     MOV #0x924, W0
000222  784801     MOV.B W1, [W0]
000224  209241     MOV #0x924, W1
000226  784091     MOV.B [W1], W1
000228  209220     MOV #0x922, W0
00022A  784801     MOV.B W1, [W0]
00022C  209221     MOV #0x922, W1
00022E  784091     MOV.B [W1], W1
000230  209210     MOV #0x921, W0
000232  784801     MOV.B W1, [W0]
28:                
29:                	_U4TXIF		= 0;				// Clear the Transmit Interrupt Flag
000234  A9208F     BCLR 0x8F, #1
30:                	_U4RXIF		= 0;				// Clear the Recieve Interrupt Flag
000236  A9008F     BCLR 0x8F, #0
31:                //	_U4TXIE		= 1;				// Enable Transmit Interrupts
32:                	_U4RXIE		= 1;				// Enable Recieve Interrupts
000238  A8009F     BSET 0x9F, #0
33:                
34:                	UART4_RX	= 1;				// And turn the peripheral on
00023A  A8E2B1     BSET 0x2B1, #7
35:                	UART4_TX	= 1;
00023C  A842B3     BSET 0x2B3, #2
36:                }
00023E  060000     RETURN
37:                
38:                void Uart4_SetBaudrate	(BAUDRATE br)
39:                {
40:                	U16 tmpMODE	= U4MODE;
000240  801582     MOV U4MODE, W2
41:                	U16 tmpSTA	= U4STA;
000242  801591     MOV U4STA, W1
42:                	U4MODE		= 0;				//	UART Stop
000244  EF22B0     CLR U4MODE
43:                	U4STA		= 0;
000246  EF22B2     CLR U4STA
44:                	TxWrite = TxSent = RxRec = RxRead = Enter = 0;
000248  EF6920     CLR.B Enter
00024A  209203     MOV #0x920, W3
00024C  784193     MOV.B [W3], W3
00024E  209234     MOV #0x923, W4
000250  784A03     MOV.B W3, [W4]
000252  209233     MOV #0x923, W3
000254  784193     MOV.B [W3], W3
000256  209244     MOV #0x924, W4
000258  784A03     MOV.B W3, [W4]
00025A  209243     MOV #0x924, W3
00025C  784193     MOV.B [W3], W3
00025E  209224     MOV #0x922, W4
000260  784A03     MOV.B W3, [W4]
000262  209223     MOV #0x922, W3
000264  784193     MOV.B [W3], W3
000266  209214     MOV #0x921, W4
000268  784A03     MOV.B W3, [W4]
45:                
46:                	U4BRG		= BaudRates[br][Oscillator];	//	BAUD Rate
00026A  DD0043     SL W0, #3, W0
00026C  804853     MOV 0x90A, W3
00026E  400003     ADD W0, W3, W0
000270  400000     ADD W0, W0, W0
000272  2B57E3     MOV #0xB57E, W3
000274  7801E3     MOV [W3+W0], W3
000276  8815C3     MOV W3, U4BRG
47:                
48:                	U4MODE	= tmpMODE;
000278  881582     MOV W2, U4MODE
49:                	U4STA	= tmpSTA;
00027A  881591     MOV W1, U4STA
50:                }
00027C  060000     RETURN
51:                
52:                void Uart4_Flush	(void)
53:                {
54:                	TxWrite = TxSent = RxRec = RxRead = Enter = 0;
00027E  EF6920     CLR.B Enter
000280  209201     MOV #0x920, W1
000282  784091     MOV.B [W1], W1
000284  209230     MOV #0x923, W0
000286  784801     MOV.B W1, [W0]
000288  209231     MOV #0x923, W1
00028A  784091     MOV.B [W1], W1
00028C  209240     MOV #0x924, W0
00028E  784801     MOV.B W1, [W0]
000290  209241     MOV #0x924, W1
000292  784091     MOV.B [W1], W1
000294  209220     MOV #0x922, W0
000296  784801     MOV.B W1, [W0]
000298  209221     MOV #0x922, W1
00029A  784091     MOV.B [W1], W1
00029C  209210     MOV #0x921, W0
00029E  784801     MOV.B W1, [W0]
55:                }
0002A0  060000     RETURN
56:                
57:                // **********************************************************************
58:                //	Tx4 INTERRUPT
59:                // **********************************************************************
60:                void __attribute__((interrupt, no_auto_psv)) _U4TXInterrupt( void )
61:                {
0002A2  BE9F80     MOV.D W0, [W15++]
0002A4  781F82     MOV W2, [W15++]
62:                	_U4TXIF		= 0;				// Clear the Transmit Interrupt Flag
0002A6  A9208F     BCLR 0x8F, #1
63:                	if (TxWrite	!= TxSent)			//	if remain bytes in buffer
0002A8  BFC922     MOV.B TxSent, WREG
0002AA  E34921     CP.B TxWrite
0002AC  320009     BRA Z, 0x2C0
64:                		U4TXREG	= TxBuff[TxSent++];	//	Transmit next byte
0002AE  BFC922     MOV.B TxSent, WREG
0002B0  FB8080     ZE W0, W1
0002B2  231942     MOV #0x3194, W2
0002B4  78C0E2     MOV.B [W2+W1], W1
0002B6  FB8081     ZE W1, W1
0002B8  8815A1     MOV W1, U4TXREG
0002BA  E84000     INC.B W0, W0
0002BC  B7E922     MOV.B WREG, TxSent
0002BE  370001     BRA 0x2C2
65:                	else
66:                		_U4TXIE		= 0;			// Disable Transmit Interrupt
0002C0  A9209F     BCLR 0x9F, #1
67:                }
0002C2  78014F     MOV [--W15], W2
0002C4  BE004F     MOV.D [--W15], W0
0002C6  064000     RETFIE
68:                
69:                extern inline	void	WifiPacketReceive	(U8 data);
70:                // **********************************************************************
71:                //	Rx4 INTERRUPT
72:                // **********************************************************************
73:                void __attribute__((interrupt, no_auto_psv)) _U4RXInterrupt( void )
74:                {
0002C8  F80036     PUSH RCOUNT
0002CA  BE9F80     MOV.D W0, [W15++]
0002CC  BE9F82     MOV.D W2, [W15++]
0002CE  BE9F84     MOV.D W4, [W15++]
0002D0  BE9F86     MOV.D W6, [W15++]
0002D2  BE9F88     MOV.D W8, [W15++]
75:                	do
76:                	{
77:                		register U8	rxData = U4RXREG;	// read from uart1 Rx buffer
0002D8  8015B1     MOV U4RXREG, W1
78:                		_U4RXIF		= 0;				// Clear the Recieve Interrupt Flag
0002DA  A9008F     BCLR 0x8F, #0
79:                		if ((FL_WIFI_REC) || (rxData == STX))
0002D4  200408     MOV #0x40, W8
0002DC  804962     MOV SysFlags, W2
0002DE  640002     AND W8, W2, W0
0002E0  3A0002     BRA NZ, 0x2E6
0002E2  50CFE2     SUB.B W1, #0x2, [W15]
0002E4  3A0003     BRA NZ, 0x2EC
80:                			WifiPacketReceive(rxData);	// GPRS packet receive in progress
0002E6  784001     MOV.B W1, W0
0002E8  072950     RCALL WifiPacketReceive
0002EA  370009     BRA 0x2FE
81:                		else
82:                		{
83:                			if (rxData == CR)			// Enter received
0002EC  50CFED     SUB.B W1, #0xD, [W15]
0002EE  3A0002     BRA NZ, 0x2F4
84:                			{
85:                				Enter++;
0002F0  EC6920     INC.B Enter
86:                				WIFI_IF = 1;			// Set WIFI Interrupt flag
0002F2  A8208A     BSET IFS3, #1
87:                			}
88:                			RxBuff[RxRec++] = rxData; 	// save to rx buffer
0002D6  232949     MOV #0x3294, W9
0002F4  BFC924     MOV.B RxRec, WREG
0002F6  FB8100     ZE W0, W2
0002F8  797481     MOV.B W1, [W9+W2]
0002FA  E84000     INC.B W0, W0
0002FC  B7E924     MOV.B WREG, RxRec
89:                		}
90:                	} while (U4STAbits.URXDA);
0002FE  AB02B2     BTST U4STA, #0
000300  3AFFEB     BRA NZ, 0x2D8
91:                	U4STAbits.OERR = 0;
000302  A922B2     BCLR U4STA, #1
92:                }
000304  BE044F     MOV.D [--W15], W8
000306  BE034F     MOV.D [--W15], W6
000308  BE024F     MOV.D [--W15], W4
00030A  BE014F     MOV.D [--W15], W2
00030C  BE004F     MOV.D [--W15], W0
00030E  F90036     POP RCOUNT
000310  064000     RETFIE
93:                
94:                
95:                U8 Uart4_ByteReceived	(void)
96:                {
97:                	return (RxRec != RxRead);
000312  BFC924     MOV.B RxRec, WREG
000314  B6C923     XOR.B RxRead, WREG
000316  FB8000     ZE W0, W0
000318  EA0000     NEG W0, W0
00031A  DE004F     LSR W0, #15, W0
98:                }
00031C  060000     RETURN
99:                
100:               U8 Uart4_StringReceived	(void)
101:               {
102:               	return Enter;
00031E  BFC920     MOV.B Enter, WREG
103:               }
000320  060000     RETURN
104:               
105:               U8 Uart4_GetByte(void)
106:               {
107:               	register U8 temp = RxBuff[RxRead++];
000322  BFC923     MOV.B RxRead, WREG
000324  FB8080     ZE W0, W1
000326  232942     MOV #0x3294, W2
000328  78C0E2     MOV.B [W2+W1], W1
00032A  E84000     INC.B W0, W0
00032C  B7E923     MOV.B WREG, RxRead
108:               	if (temp == CR)					// Enter received
00032E  50CFED     SUB.B W1, #0xD, [W15]
000330  3A0001     BRA NZ, 0x334
109:               		Enter--;
000332  ED6920     DEC.B Enter
110:               	return temp;
111:               }
000334  784001     MOV.B W1, W0
000336  060000     RETURN
112:               
113:               void Uart4_SendByte(char data)
114:               {
115:               	TxBuff[TxWrite++] = data;
000338  209211     MOV #0x921, W1
00033A  784091     MOV.B [W1], W1
00033C  FB8101     ZE W1, W2
00033E  231943     MOV #0x3194, W3
000340  797180     MOV.B W0, [W3+W2]
000342  E84081     INC.B W1, W1
000344  784101     MOV.B W1, W2
000346  209210     MOV #0x921, W0
000348  784802     MOV.B W2, [W0]
116:               	if ((_U4TXIE == 0) && (TxWrite != TxSent))
00034A  AB209F     BTST 0x9F, #1
00034C  3A0005     BRA NZ, 0x358
00034E  BFC922     MOV.B TxSent, WREG
000350  E34921     CP.B TxWrite
000352  320002     BRA Z, 0x358
117:               	{
118:               		_U4TXIE		= 1;				// Enable Transmit Interrupt
000354  A8209F     BSET 0x9F, #1
119:               		_U4TXIF		= 1;				// Set Transmit Interrupt Flag
000356  A8208F     BSET 0x8F, #1
120:               	}
121:               }
000358  060000     RETURN
122:               
123:               void Uart4_GetString(P_U8 str)
124:               {
00035A  781F88     MOV W8, [W15++]
00035C  780400     MOV W0, W8
125:               	if (Enter)
00035E  E24920     CP0.B Enter
000360  320007     BRA Z, 0x370
126:               	{
127:               		while (1)
128:               		{
129:               			register U8 data = Uart4_GetByte();
000362  07FFDF     RCALL Uart4_GetByte
130:               			if (data == CR)
000364  504FED     SUB.B W0, #0xD, [W15]
000366  320004     BRA Z, 0x370
131:               				break;
132:               			else if (data != LF)
000368  504FEA     SUB.B W0, #0xA, [W15]
00036A  32FFFB     BRA Z, 0x362
133:               				*str++ = data;
00036C  785C00     MOV.B W0, [W8++]
00036E  37FFF9     BRA 0x362
134:               		}
135:               	}
136:               	*str = '\0';
000370  EB4C00     CLR.B [W8]
137:               }
000372  78044F     MOV [--W15], W8
000374  060000     RETURN
138:               
139:               void Uart4_SendText	(const char *str)
140:               {
000376  781F88     MOV W8, [W15++]
000378  780400     MOV W0, W8
141:               	while (*str)
00037A  784018     MOV.B [W8], W0
00037C  E00400     CP0.B W0
00037E  320004     BRA Z, 0x388
000382  784058     MOV.B [++W8], W0
000384  E00400     CP0.B W0
000386  3AFFFC     BRA NZ, 0x380
142:               		Uart4_SendByte(*str++);
000380  07FFDB     RCALL Uart4_SendByte
143:               }
000388  78044F     MOV [--W15], W8
00038A  060000     RETURN
144:               
145:               void Uart4_SendData	(const char *str, U16 len)
146:               {
00038C  BE9F88     MOV.D W8, [W15++]
00038E  780480     MOV W0, W9
000390  780401     MOV W1, W8
147:               	while (len)
000392  E00008     CP0 W8
000394  320004     BRA Z, 0x39E
00039C  3AFFFC     BRA NZ, 0x396
148:               	{
149:               		Uart4_SendByte(*str++);
000396  784039     MOV.B [W9++], W0
000398  07FFCF     RCALL Uart4_SendByte
150:               		len--;
00039A  E90408     DEC W8, W8
151:               	}
152:               }
00039E  BE044F     MOV.D [--W15], W8
0003A0  060000     RETURN
153:               
154:               void Uart4_SendEnter(void)
155:               {
156:               	Uart4_SendByte(CR);
0003A2  B3C0D0     MOV.B #0xD, W0
0003A4  07FFC9     RCALL Uart4_SendByte
157:               	Uart4_SendByte(LF);
0003A6  B3C0A0     MOV.B #0xA, W0
0003A8  07FFC7     RCALL Uart4_SendByte
158:               }
0003AA  060000     RETURN
159:               
160:               #endif  //  UART4_WIFI
161:               
---  /home/pele/src/Auto_02/src/Uart3.c  ----------------------------------------------------------------
1:                 #include	"Uart3.h"
2:                 #include	"Ports.h"
3:                 //#include	"Memory.h"
4:                 #include	<stdio.h>
5:                 
6:                 #define	UART3_TX		U3STAbits.UTXEN
7:                 #define	UART3_RX		U3MODEbits.UARTEN
8:                 
9:                 static	volatile U8		TxBuff[256];
10:                static	volatile U8		RxBuff[256];
11:                static	volatile U8		TxWrite, TxSent, RxRec, RxRead, Enter;
12:                
13:                
14:                // BAUD_9600
15:                // BAUD_19200
16:                // BAUD_38400
17:                // BAUD_115200
18:                void Uart3_Init	(void)
19:                {
20:                	U3MODE		= 0;				//	UART reset
007450  EF2250     CLR U3MODE
21:                	U3STA		= 0;
007452  EF2252     CLR U3STA
22:                //	U3BRG		= baudRate;			//	BAUD Rate
23:                
24:                	TxWrite = TxSent = RxRec = RxRead = Enter = 0;
007454  EF691C     CLR.B Enter
007456  2091C1     MOV #0x91C, W1
007458  784091     MOV.B [W1], W1
00745A  2091D0     MOV #0x91D, W0
00745C  784801     MOV.B W1, [W0]
00745E  2091D1     MOV #0x91D, W1
007460  784091     MOV.B [W1], W1
007462  2091E0     MOV #0x91E, W0
007464  784801     MOV.B W1, [W0]
007466  2091E1     MOV #0x91E, W1
007468  784091     MOV.B [W1], W1
00746A  2091B0     MOV #0x91B, W0
00746C  784801     MOV.B W1, [W0]
00746E  2091B1     MOV #0x91B, W1
007470  784091     MOV.B [W1], W1
007472  2091A0     MOV #0x91A, W0
007474  784801     MOV.B W1, [W0]
25:                //	GsmDataAutoSort = 0;
26:                
27:                	_U3TXIF		= 0;				// Clear the Transmit Interrupt Flag
007476  A9608E     BCLR IFS5, #3
28:                	_U3RXIF		= 0;				// Clear the Recieve Interrupt Flag
007478  A9408E     BCLR IFS5, #2
29:                //	_U3TXIE		= 1;				// Enable Transmit Interrupts
30:                	_U3RXIE		= 1;				// Enable Recieve Interrupts
00747A  A8409E     BSET IEC5, #2
31:                
32:                	UART3_RX	= 1;				// And turn the peripheral on
00747C  A8E251     BSET 0x251, #7
33:                	UART3_TX	= 1;
00747E  A84253     BSET 0x253, #2
34:                }
007480  060000     RETURN
35:                
36:                void Uart3_SetBaudrate	(U16 baudRate)
37:                {
38:                	U16 tmpMODE	= U3MODE;
007482  801282     MOV U3MODE, W2
39:                	U16 tmpSTA	= U3STA;
007484  801291     MOV U3STA, W1
40:                	U3MODE		= 0;				//	UART Stop
007486  EF2250     CLR U3MODE
41:                	U3STA		= 0;
007488  EF2252     CLR U3STA
42:                
43:                	U3BRG		= baudRate;			//	BAUD Rate
00748A  8812C0     MOV W0, U3BRG
44:                
45:                	U3MODE	= tmpMODE;
00748C  881282     MOV W2, U3MODE
46:                	U3STA	= tmpSTA;
00748E  881291     MOV W1, U3STA
47:                }
007490  060000     RETURN
48:                
49:                // **********************************************************************
50:                //	Tx3 INTERRUPT
51:                // **********************************************************************
52:                void __attribute__((interrupt, no_auto_psv)) _U3TXInterrupt( void )
53:                {
007492  BE9F80     MOV.D W0, [W15++]
007494  781F82     MOV W2, [W15++]
54:                	_U3TXIF		= 0;				// Clear the Transmit Interrupt Flag
007496  A9608E     BCLR IFS5, #3
55:                //	if		(FLAG_MEM_TO_UART3)		// Direct Mem data send mode
56:                //	{
57:                //		do
58:                //		{
59:                //			register U8 a = DataFromSpiMem();			// get next byte from Spi memory
60:                //			U3TXREG = (a == 0xE7)?	0x1C: (a ^ 0xFF);	// send to uart inverted bits (if data is magic bitmap code - change it)
61:                //		} while (FLAG_MEM_TO_UART3 && !U3STAbits.UTXBF);
62:                //	}
63:                //	else if	(TxWrite	!= TxSent)	//	if remain bytes in buffer
64:                	if	(TxWrite	!= TxSent)	//	if remain bytes in buffer
007498  BFC91B     MOV.B TxSent, WREG
00749A  E3491A     CP.B TxWrite
00749C  320009     BRA Z, 0x74B0
65:                		U3TXREG	= TxBuff[TxSent++];	//	Transmit next byte
00749E  BFC91B     MOV.B TxSent, WREG
0074A0  FB8080     ZE W0, W1
0074A2  22F942     MOV #0x2F94, W2
0074A4  78C0E2     MOV.B [W2+W1], W1
0074A6  FB8081     ZE W1, W1
0074A8  8812A1     MOV W1, U3TXREG
0074AA  E84000     INC.B W0, W0
0074AC  B7E91B     MOV.B WREG, TxSent
0074AE  370001     BRA 0x74B2
66:                	else
67:                		_U3TXIE		= 0;			// Disable Transmit Interrupt
0074B0  A9609E     BCLR IEC5, #3
68:                }
0074B2  78014F     MOV [--W15], W2
0074B4  BE004F     MOV.D [--W15], W0
0074B6  064000     RETFIE
69:                
70:                // **********************************************************************
71:                //	Rx3 INTERRUPT
72:                // **********************************************************************
73:                void __attribute__((interrupt, no_auto_psv)) _U3RXInterrupt( void )
74:                {
0074B8  BE9F80     MOV.D W0, [W15++]
0074BA  BE9F82     MOV.D W2, [W15++]
75:                	U8	temp = U3RXREG;				// read from uart1 Rx buffer
0074BC  8012B1     MOV U3RXREG, W1
76:                	_U3RXIF		= 0;				// Clear the Recieve Interrupt Flag
0074BE  A9408E     BCLR IFS5, #2
77:                
78:                	{
79:                		if (temp == CR)					// Enter received
0074C0  50CFED     SUB.B W1, #0xD, [W15]
0074C2  3A0001     BRA NZ, 0x74C6
80:                			Enter++;
0074C4  EC691C     INC.B Enter
81:                		RxBuff[RxRec++] = temp; 		// save to rx buffer
0074C6  BFC91E     MOV.B RxRec, WREG
0074C8  FB8100     ZE W0, W2
0074CA  230943     MOV #0x3094, W3
0074CC  797181     MOV.B W1, [W3+W2]
0074CE  E84000     INC.B W0, W0
0074D0  B7E91E     MOV.B WREG, RxRec
82:                	}
83:                }
0074D2  BE014F     MOV.D [--W15], W2
0074D4  BE004F     MOV.D [--W15], W0
0074D6  064000     RETFIE
84:                
85:                
86:                U8 Uart3ByteReceived(void)
87:                {
88:                	return (RxRec != RxRead);
0074D8  BFC91E     MOV.B RxRec, WREG
0074DA  B6C91D     XOR.B RxRead, WREG
0074DC  FB8000     ZE W0, W0
0074DE  EA0000     NEG W0, W0
0074E0  DE004F     LSR W0, #15, W0
89:                }
0074E2  060000     RETURN
90:                
91:                U8 Uart3StringReceived(void)
92:                {
93:                	return Enter;
0074E4  BFC91C     MOV.B Enter, WREG
94:                }
0074E6  060000     RETURN
95:                
96:                U8 Uart3GetByte(void)
97:                {
98:                	U8 temp = RxBuff[RxRead++];
0074E8  BFC91D     MOV.B RxRead, WREG
0074EA  FB8080     ZE W0, W1
0074EC  230942     MOV #0x3094, W2
0074EE  78C0E2     MOV.B [W2+W1], W1
0074F0  E84000     INC.B W0, W0
0074F2  B7E91D     MOV.B WREG, RxRead
99:                	if (temp == CR)					// Enter received
0074F4  50CFED     SUB.B W1, #0xD, [W15]
0074F6  3A0001     BRA NZ, 0x74FA
100:               		Enter--;
0074F8  ED691C     DEC.B Enter
101:               	return temp;
102:               }
0074FA  784001     MOV.B W1, W0
0074FC  060000     RETURN
103:               
104:               void Uart3SendByte(char data)
105:               {
106:               	TxBuff[TxWrite++] = data;
0074FE  2091A1     MOV #0x91A, W1
007500  784091     MOV.B [W1], W1
007502  FB8101     ZE W1, W2
007504  22F943     MOV #0x2F94, W3
007506  797180     MOV.B W0, [W3+W2]
007508  E84081     INC.B W1, W1
00750A  784101     MOV.B W1, W2
00750C  2091A0     MOV #0x91A, W0
00750E  784802     MOV.B W2, [W0]
107:               	if ((_U3TXIE == 0) && (TxWrite != TxSent))
007510  AB609E     BTST IEC5, #3
007512  3A0005     BRA NZ, 0x751E
007514  BFC91B     MOV.B TxSent, WREG
007516  E3491A     CP.B TxWrite
007518  320002     BRA Z, 0x751E
108:               	{
109:               		_U3TXIE		= 1;				// Enable Transmit Interrupt
00751A  A8609E     BSET IEC5, #3
110:               		_U3TXIF		= 1;				// Set Transmit Interrupt Flag
00751C  A8608E     BSET IFS5, #3
111:               	}
112:               }
00751E  060000     RETURN
113:               
114:               void Uart3GetString(P_U8 str)
115:               {
007520  781F88     MOV W8, [W15++]
007522  780400     MOV W0, W8
116:               	if (Enter)
007524  E2491C     CP0.B Enter
007526  320007     BRA Z, 0x7536
117:               	{
118:               		while (1)
119:               		{
120:               			U8 data = Uart3GetByte();
007528  07FFDF     RCALL Uart3GetByte
121:               			if (data == CR)
00752A  504FED     SUB.B W0, #0xD, [W15]
00752C  320004     BRA Z, 0x7536
122:               				break;
123:               			else if (data != LF)
00752E  504FEA     SUB.B W0, #0xA, [W15]
007530  32FFFB     BRA Z, 0x7528
124:               				*str++ = data;
007532  785C00     MOV.B W0, [W8++]
007534  37FFF9     BRA 0x7528
125:               		}
126:               	}
127:               	*str = '\0';
007536  EB4C00     CLR.B [W8]
128:               }
007538  78044F     MOV [--W15], W8
00753A  060000     RETURN
129:               /*
130:               void Uart3SendString(P_R8 str)
131:               {
132:               	while (*str)
133:               		Uart3SendByte(*str++);
134:               
135:               	Uart3SendEnter();
136:               }
137:               */
138:               void Uart3SendText(const char *str)
139:               {
00753C  781F88     MOV W8, [W15++]
00753E  780400     MOV W0, W8
140:               	while (*str)
007540  784018     MOV.B [W8], W0
007542  E00400     CP0.B W0
007544  320004     BRA Z, 0x754E
007548  784058     MOV.B [++W8], W0
00754A  E00400     CP0.B W0
00754C  3AFFFC     BRA NZ, 0x7546
141:               		Uart3SendByte(*str++);
007546  07FFDB     RCALL Uart3SendByte
142:               
143:               //	Uart3SendEnter();
144:               }
00754E  78044F     MOV [--W15], W8
007550  060000     RETURN
145:               
146:               void Uart3SendData(const U8 *data, U16 len)
147:               {
007552  BE9F88     MOV.D W8, [W15++]
007554  780480     MOV W0, W9
007556  780401     MOV W1, W8
148:               	while (len)
007558  E00008     CP0 W8
00755A  320004     BRA Z, 0x7564
007562  3AFFFC     BRA NZ, 0x755C
149:               	{
150:               		Uart3SendByte(*data++);
00755C  784039     MOV.B [W9++], W0
00755E  07FFCF     RCALL Uart3SendByte
151:               		len--;
007560  E90408     DEC W8, W8
152:               	}
153:               
154:               //	Uart3SendEnter();
155:               }
007564  BE044F     MOV.D [--W15], W8
007566  060000     RETURN
156:               
157:               void Uart3SendEnter(void)
158:               {
159:               	Uart3SendByte(CR);
007568  B3C0D0     MOV.B #0xD, W0
00756A  07FFC9     RCALL Uart3SendByte
160:               	Uart3SendByte(LF);
00756C  B3C0A0     MOV.B #0xA, W0
00756E  07FFC7     RCALL Uart3SendByte
161:               }
007570  060000     RETURN
162:               
163:               void Uart3PrintDebugData(const U8 *data, U8 len)
164:               {
007572  FA0006     LNK #0x6
007574  BE9F88     MOV.D W8, [W15++]
007576  781F8A     MOV W10, [W15++]
007578  780480     MOV W0, W9
00757A  784401     MOV.B W1, W8
165:               //	Uart3SendText("\r\nData: ");
166:               	Uart3SendEnter();
00757C  07FFF5     RCALL Uart3SendEnter
167:               	char str[5];
168:               	while(len)
00757E  E00408     CP0.B W8
007580  32000C     BRA Z, 0x759A
007594  5787E4     SUB W15, #0x4, W15
007596  E00408     CP0.B W8
007598  3AFFF5     BRA NZ, 0x7584
169:               	{
170:               		sprintf(str,"%02X ", *data++);		Uart3SendText(str);
007582  2B64CA     MOV #0xB64C, W10
007584  FB8039     ZE [W9++], W0
007586  781F80     MOV W0, [W15++]
007588  781F8A     MOV W10, [W15++]
00758A  578070     SUB W15, #0x10, W0
00758C  07CF0F     RCALL __sprintf_cdnopuxX, __sprintf_s, __sprintf_0, __sprintf_cdnopsuxX
00758E  578070     SUB W15, #0x10, W0
007590  07FFD5     RCALL Uart3SendText
171:               		len--;
007592  E94408     DEC.B W8, W8
172:               	}
173:               //	Uart3SendEnter();
174:               }
00759A  78054F     MOV [--W15], W10
00759C  BE044F     MOV.D [--W15], W8
00759E  FA8000     ULNK
0075A0  060000     RETURN
175:               
176:               // return number of remain empty bytes in transmit buffer
177:               U8 Uart3TxBuffResidual(void)
178:               {
179:               	return (TxWrite < TxSent)?		(TxSent - TxWrite):((255 - TxWrite) + TxSent);
0075A2  BFC91B     MOV.B TxSent, WREG
0075A4  E3491A     CP.B TxWrite
0075A6  310005     BRA C, 0x75B2
0075A8  2091B1     MOV #0x91B, W1
0075AA  784091     MOV.B [W1], W1
0075AC  BFC91A     MOV.B TxWrite, WREG
0075AE  50C000     SUB.B W1, W0, W0
0075B0  370005     BRA 0x75BC
0075B2  BFC91A     MOV.B TxWrite, WREG
0075B4  2091B1     MOV #0x91B, W1
0075B6  784091     MOV.B [W1], W1
0075B8  EAC000     COM.B W0, W0
0075BA  404001     ADD.B W0, W1, W0
180:               }
0075BC  060000     RETURN
---  /home/pele/src/Auto_02/src/Uart2.c  ----------------------------------------------------------------
1:                 #include	"Uart2.h"
2:                 #include	"Ports.h"
3:                 #include	"Gsm.h"
4:                 
5:                 #define	UART2_TX		U2STAbits.UTXEN
6:                 #define	UART2_RX		U2MODEbits.UARTEN
7:                 
8:                 static	volatile U8		TxBuff[256];
9:                 static	volatile U8		RxBuff[256];
10:                static	volatile U8		TxWrite, TxSent, RxRec, RxRead, Enter;
11:                
12:                extern OSC			Oscillator;
13:                extern const U16	BaudRates[5][8];
14:                
15:                // BAUD_9600
16:                // BAUD_19200
17:                // BAUD_38400
18:                // BAUD_115200
19:                void Uart2_Init(BAUDRATE br)
20:                {
21:                	U2MODE		= 0;				//	UART reset
007124  EF2230     CLR U2MODE
22:                	U2STA		= 0;
007126  EF2232     CLR U2STA
23:                	U2BRG		= BaudRates[br][Oscillator];	//	BAUD Rate
007128  DD0043     SL W0, #3, W0
00712A  804851     MOV 0x90A, W1
00712C  400001     ADD W0, W1, W0
00712E  400000     ADD W0, W0, W0
007130  2B57E1     MOV #0xB57E, W1
007132  7800E1     MOV [W1+W0], W1
007134  8811C1     MOV W1, U2BRG
24:                
25:                	TxWrite = TxSent = RxRec = RxRead = Enter = 0;
007136  EF6914     CLR.B Enter
007138  209141     MOV #0x914, W1
00713A  784091     MOV.B [W1], W1
00713C  209170     MOV #0x917, W0
00713E  784801     MOV.B W1, [W0]
007140  209171     MOV #0x917, W1
007142  784091     MOV.B [W1], W1
007144  209180     MOV #0x918, W0
007146  784801     MOV.B W1, [W0]
007148  209181     MOV #0x918, W1
00714A  784091     MOV.B [W1], W1
00714C  209160     MOV #0x916, W0
00714E  784801     MOV.B W1, [W0]
007150  209161     MOV #0x916, W1
007152  784091     MOV.B [W1], W1
007154  209150     MOV #0x915, W0
007156  784801     MOV.B W1, [W0]
26:                
27:                	_U2TXIF		= 0;				// Clear the Transmit Interrupt Flag
007158  A9E087     BCLR 0x87, #7
28:                	_U2RXIF		= 0;				// Clear the Recieve Interrupt Flag
00715A  A9C087     BCLR 0x87, #6
29:                //	_U2TXIE		= 1;				// Enable Transmit Interrupts
30:                	_U2RXIE		= 1;				// Enable Recieve Interrupts
00715C  A8C097     BSET 0x97, #6
31:                
32:                	UART2_RX	= 1;				// And turn the peripheral on
00715E  A8E231     BSET 0x231, #7
33:                	UART2_TX	= 1;
007160  A84233     BSET 0x233, #2
34:                }
007162  060000     RETURN
35:                
36:                void Uart2_SetBaudrate	(BAUDRATE br)
37:                {
38:                	U16 tmpMODE	= U2MODE;
007164  801182     MOV U2MODE, W2
39:                	U16 tmpSTA	= U2STA;
007166  801191     MOV U2STA, W1
40:                	U2MODE		= 0;				//	UART Stop
007168  EF2230     CLR U2MODE
41:                	U2STA		= 0;
00716A  EF2232     CLR U2STA
42:                	TxWrite = TxSent = RxRec = RxRead = Enter = 0;
00716C  EF6914     CLR.B Enter
00716E  209143     MOV #0x914, W3
007170  784193     MOV.B [W3], W3
007172  209174     MOV #0x917, W4
007174  784A03     MOV.B W3, [W4]
007176  209173     MOV #0x917, W3
007178  784193     MOV.B [W3], W3
00717A  209184     MOV #0x918, W4
00717C  784A03     MOV.B W3, [W4]
00717E  209183     MOV #0x918, W3
007180  784193     MOV.B [W3], W3
007182  209164     MOV #0x916, W4
007184  784A03     MOV.B W3, [W4]
007186  209163     MOV #0x916, W3
007188  784193     MOV.B [W3], W3
00718A  209154     MOV #0x915, W4
00718C  784A03     MOV.B W3, [W4]
43:                
44:                	U2BRG		= BaudRates[br][Oscillator];	//	BAUD Rate
00718E  DD0043     SL W0, #3, W0
007190  804853     MOV 0x90A, W3
007192  400003     ADD W0, W3, W0
007194  400000     ADD W0, W0, W0
007196  2B57E3     MOV #0xB57E, W3
007198  7801E3     MOV [W3+W0], W3
00719A  8811C3     MOV W3, U2BRG
45:                
46:                	U2MODE	= tmpMODE;
00719C  881182     MOV W2, U2MODE
47:                	U2STA	= tmpSTA;
00719E  881191     MOV W1, U2STA
48:                }
0071A0  060000     RETURN
49:                
50:                void Uart2_Flush	(void)
51:                {
52:                	TxWrite = TxSent = RxRec = RxRead = Enter = 0;
0071A2  EF6914     CLR.B Enter
0071A4  209141     MOV #0x914, W1
0071A6  784091     MOV.B [W1], W1
0071A8  209170     MOV #0x917, W0
0071AA  784801     MOV.B W1, [W0]
0071AC  209171     MOV #0x917, W1
0071AE  784091     MOV.B [W1], W1
0071B0  209180     MOV #0x918, W0
0071B2  784801     MOV.B W1, [W0]
0071B4  209181     MOV #0x918, W1
0071B6  784091     MOV.B [W1], W1
0071B8  209160     MOV #0x916, W0
0071BA  784801     MOV.B W1, [W0]
0071BC  209161     MOV #0x916, W1
0071BE  784091     MOV.B [W1], W1
0071C0  209150     MOV #0x915, W0
0071C2  784801     MOV.B W1, [W0]
53:                }
0071C4  060000     RETURN
54:                
55:                // **********************************************************************
56:                //	Tx2 INTERRUPT
57:                // **********************************************************************
58:                void __attribute__((interrupt, no_auto_psv)) _U2TXInterrupt( void )
59:                {
0071C6  BE9F80     MOV.D W0, [W15++]
0071C8  781F82     MOV W2, [W15++]
60:                	_U2TXIF		= 0;				// Clear the Transmit Interrupt Flag
0071CA  A9E087     BCLR 0x87, #7
61:                	if (TxWrite	!= TxSent)			//	if remain bytes in buffer
0071CC  BFC916     MOV.B TxSent, WREG
0071CE  E34915     CP.B TxWrite
0071D0  320009     BRA Z, 0x71E4
62:                		U2TXREG	= TxBuff[TxSent++];	//	Transmit next byte
0071D2  BFC916     MOV.B TxSent, WREG
0071D4  FB8080     ZE W0, W1
0071D6  22D942     MOV #0x2D94, W2
0071D8  78C0E2     MOV.B [W2+W1], W1
0071DA  FB8081     ZE W1, W1
0071DC  8811A1     MOV W1, U2TXREG
0071DE  E84000     INC.B W0, W0
0071E0  B7E916     MOV.B WREG, TxSent
0071E2  370001     BRA 0x71E6
63:                	else
64:                		_U2TXIE		= 0;			// Disable Transmit Interrupt
0071E4  A9E097     BCLR 0x97, #7
65:                }
0071E6  78014F     MOV [--W15], W2
0071E8  BE004F     MOV.D [--W15], W0
0071EA  064000     RETFIE
66:                
67:                extern inline	void	GprsPacketReceive	(U8 data);
68:                // **********************************************************************
69:                //	Rx2 INTERRUPT
70:                // **********************************************************************
71:                void __attribute__((interrupt, no_auto_psv)) _U2RXInterrupt( void )
72:                {
0071EC  F80036     PUSH RCOUNT
0071EE  BE9F80     MOV.D W0, [W15++]
0071F0  BE9F82     MOV.D W2, [W15++]
0071F2  BE9F84     MOV.D W4, [W15++]
0071F4  BE9F86     MOV.D W6, [W15++]
0071F6  781F88     MOV W8, [W15++]
73:                	do
74:                	{
75:                		register U8	rxData = U2RXREG;	// read from uart1 Rx buffer
0071FA  8011B1     MOV U2RXREG, W1
76:                		_U2RXIF		= 0;				// Clear the Recieve Interrupt Flag
0071FC  A9C087     BCLR 0x87, #6
77:                		if ((FL_GPRS_REC) || (rxData == STX))
0071FE  AB492C     BTST SysFlags, #2
007200  3A0002     BRA NZ, 0x7206
007202  50CFE2     SUB.B W1, #0x2, [W15]
007204  3A0003     BRA NZ, 0x720C
78:                			GprsPacketReceive(rxData);	// GPRS packet receive in progress
007206  784001     MOV.B W1, W0
007208  07E2D7     RCALL GprsPacketReceive
00720A  370009     BRA 0x721E
79:                		else
80:                		{
81:                			if (rxData == CR)			// Enter received
00720C  50CFED     SUB.B W1, #0xD, [W15]
00720E  3A0002     BRA NZ, 0x7214
82:                			{
83:                				Enter++;
007210  EC6914     INC.B Enter
84:                				GSM_IF = 1;				// Set GSM Interrupt flag
007212  A80086     BSET IFS1, #0
85:                			}
86:                			RxBuff[RxRec++] = rxData; 	// save to rx buffer
0071F8  22E948     MOV #0x2E94, W8
007214  BFC918     MOV.B RxRec, WREG
007216  FB8100     ZE W0, W2
007218  797401     MOV.B W1, [W8+W2]
00721A  E84000     INC.B W0, W0
00721C  B7E918     MOV.B WREG, RxRec
87:                		}
88:                	} while (U2STAbits.URXDA);
00721E  AB0232     BTST U2STA, #0
007220  3AFFEC     BRA NZ, 0x71FA
89:                	U2STAbits.OERR = 0;
007222  A92232     BCLR U2STA, #1
90:                }
007224  78044F     MOV [--W15], W8
007226  BE034F     MOV.D [--W15], W6
007228  BE024F     MOV.D [--W15], W4
00722A  BE014F     MOV.D [--W15], W2
00722C  BE004F     MOV.D [--W15], W0
00722E  F90036     POP RCOUNT
007230  064000     RETFIE
91:                
92:                
93:                U8 Uart2_ByteReceived	(void)
94:                {
95:                	return (RxRec != RxRead);
007232  BFC918     MOV.B RxRec, WREG
007234  B6C917     XOR.B RxRead, WREG
007236  FB8000     ZE W0, W0
007238  EA0000     NEG W0, W0
00723A  DE004F     LSR W0, #15, W0
96:                }
00723C  060000     RETURN
97:                
98:                U8 Uart2_StringReceived	(void)
99:                {
100:               	return Enter;
00723E  BFC914     MOV.B Enter, WREG
101:               }
007240  060000     RETURN
102:               
103:               U8 Uart2_GetByte(void)
104:               {
105:               	register U8 temp = RxBuff[RxRead++];
007242  BFC917     MOV.B RxRead, WREG
007244  FB8080     ZE W0, W1
007246  22E942     MOV #0x2E94, W2
007248  78C0E2     MOV.B [W2+W1], W1
00724A  E84000     INC.B W0, W0
00724C  B7E917     MOV.B WREG, RxRead
106:               	if (temp == CR)					// Enter received
00724E  50CFED     SUB.B W1, #0xD, [W15]
007250  3A0001     BRA NZ, 0x7254
107:               		Enter--;
007252  ED6914     DEC.B Enter
108:               	return temp;
109:               }
007254  784001     MOV.B W1, W0
007256  060000     RETURN
110:               
111:               void Uart2_SendByte(char data)
112:               {
113:               	TxBuff[TxWrite++] = data;
007258  209151     MOV #0x915, W1
00725A  784091     MOV.B [W1], W1
00725C  FB8101     ZE W1, W2
00725E  22D943     MOV #0x2D94, W3
007260  797180     MOV.B W0, [W3+W2]
007262  E84081     INC.B W1, W1
007264  784101     MOV.B W1, W2
007266  209150     MOV #0x915, W0
007268  784802     MOV.B W2, [W0]
114:               	if ((_U2TXIE == 0) && (TxWrite != TxSent))
00726A  E20096     CP0 IEC1
00726C  350005     BRA LT, 0x7278
00726E  BFC916     MOV.B TxSent, WREG
007270  E34915     CP.B TxWrite
007272  320002     BRA Z, 0x7278
115:               	{
116:               		_U2TXIE		= 1;				// Enable Transmit Interrupt
007274  A8E097     BSET 0x97, #7
117:               		_U2TXIF		= 1;				// Set Transmit Interrupt Flag
007276  A8E087     BSET 0x87, #7
118:               	}
119:               }
007278  060000     RETURN
120:               
121:               void Uart2_GetString(P_U8 str)
122:               {
00727A  781F88     MOV W8, [W15++]
00727C  780400     MOV W0, W8
123:               	if (Enter)
00727E  E24914     CP0.B Enter
007280  320007     BRA Z, 0x7290
124:               	{
125:               		while (1)
126:               		{
127:               			register U8 data = Uart2_GetByte();
007282  07FFDF     RCALL Uart2_GetByte
128:               			if (data == CR)
007284  504FED     SUB.B W0, #0xD, [W15]
007286  320004     BRA Z, 0x7290
129:               				break;
130:               			else if (data != LF)
007288  504FEA     SUB.B W0, #0xA, [W15]
00728A  32FFFB     BRA Z, 0x7282
131:               				*str++ = data;
00728C  785C00     MOV.B W0, [W8++]
00728E  37FFF9     BRA 0x7282
132:               		}
133:               	}
134:               	*str = '\0';
007290  EB4C00     CLR.B [W8]
135:               }
007292  78044F     MOV [--W15], W8
007294  060000     RETURN
136:               
137:               void Uart2_SendText	(const char *str)
138:               {
007296  781F88     MOV W8, [W15++]
007298  780400     MOV W0, W8
139:               	while (*str)
00729A  784018     MOV.B [W8], W0
00729C  E00400     CP0.B W0
00729E  320004     BRA Z, 0x72A8
0072A2  784058     MOV.B [++W8], W0
0072A4  E00400     CP0.B W0
0072A6  3AFFFC     BRA NZ, 0x72A0
140:               		Uart2_SendByte(*str++);
0072A0  07FFDB     RCALL Uart2_SendByte
141:               }
0072A8  78044F     MOV [--W15], W8
0072AA  060000     RETURN
142:               
143:               void Uart2_SendData	(const char *str, U16 len)
144:               {
0072AC  BE9F88     MOV.D W8, [W15++]
0072AE  780480     MOV W0, W9
0072B0  780401     MOV W1, W8
145:               	while (len)
0072B2  E00008     CP0 W8
0072B4  320004     BRA Z, 0x72BE
0072BC  3AFFFC     BRA NZ, 0x72B6
146:               	{
147:               		Uart2_SendByte(*str++);
0072B6  784039     MOV.B [W9++], W0
0072B8  07FFCF     RCALL Uart2_SendByte
148:               		len--;
0072BA  E90408     DEC W8, W8
149:               	}
150:               }
0072BE  BE044F     MOV.D [--W15], W8
0072C0  060000     RETURN
151:               
152:               void Uart2_SendEnter(void)
153:               {
154:               	Uart2_SendByte(CR);
0072C2  B3C0D0     MOV.B #0xD, W0
0072C4  07FFC9     RCALL Uart2_SendByte
155:               	Uart2_SendByte(LF);
0072C6  B3C0A0     MOV.B #0xA, W0
0072C8  07FFC7     RCALL Uart2_SendByte
156:               }
0072CA  060000     RETURN
157:               
---  /home/pele/src/Auto_02/src/Uart1.c  ----------------------------------------------------------------
1:                 #include	"Uart1.h"
2:                 #include	"Ports.h"
3:                 #include	"Gps.h"
4:                 
5:                 #define	UART1_TX		U1STAbits.UTXEN
6:                 #define	UART1_RX		U1MODEbits.UARTEN
7:                 
8:                 static	volatile U8		TxBuff[256];
9:                 #ifndef	UART1_GPS
10:                	static	volatile U8	RxBuff[256];
11:                #endif
12:                static	volatile U8		TxWrite, TxSent, RxRec, RxRead, Enter;
13:                
14:                extern OSC			Oscillator;
15:                extern const U16	BaudRates[5][8];
16:                
17:                // BAUD_9600
18:                // BAUD_19200
19:                // BAUD_38400
20:                // BAUD_115200
21:                void Uart1_Init(BAUDRATE br)
22:                {
23:                	U1MODE		= 0;				//	UART reset
0072CC  EF2220     CLR U1MODE
24:                	U1STA		= 0;
0072CE  EF2222     CLR U1STA
25:                	U1BRG		= BaudRates[br][Oscillator];	//	BAUD Rate
0072D0  DD0043     SL W0, #3, W0
0072D2  804851     MOV 0x90A, W1
0072D4  400001     ADD W0, W1, W0
0072D6  400000     ADD W0, W0, W0
0072D8  2B57E1     MOV #0xB57E, W1
0072DA  7800E1     MOV [W1+W0], W1
0072DC  881141     MOV W1, U1BRG
26:                
27:                	TxWrite = TxSent = RxRec = RxRead = Enter = 0;
0072DE  EF690E     CLR.B Enter
0072E0  2090E1     MOV #0x90E, W1
0072E2  784091     MOV.B [W1], W1
0072E4  209110     MOV #0x911, W0
0072E6  784801     MOV.B W1, [W0]
0072E8  209111     MOV #0x911, W1
0072EA  784091     MOV.B [W1], W1
0072EC  209120     MOV #0x912, W0
0072EE  784801     MOV.B W1, [W0]
0072F0  209121     MOV #0x912, W1
0072F2  784091     MOV.B [W1], W1
0072F4  209100     MOV #0x910, W0
0072F6  784801     MOV.B W1, [W0]
0072F8  209101     MOV #0x910, W1
0072FA  784091     MOV.B [W1], W1
0072FC  2090F0     MOV #0x90F, W0
0072FE  784801     MOV.B W1, [W0]
28:                
29:                	_U1TXIF		= 0;				// Clear the Transmit Interrupt Flag
007300  A98085     BCLR 0x85, #4
30:                	_U1RXIF		= 0;				// Clear the Recieve Interrupt Flag
007302  A96085     BCLR 0x85, #3
31:                //	_U1TXIE		= 1;				// Enable Transmit Interrupts
32:                	_U1RXIE		= 1;				// Enable Recieve Interrupts
007304  A86095     BSET 0x95, #3
33:                
34:                	UART1_RX	= 1;				// And turn the peripheral on
007306  A8E221     BSET 0x221, #7
35:                	UART1_TX	= 1;
007308  A84223     BSET 0x223, #2
36:                }
00730A  060000     RETURN
37:                
38:                void Uart1_SetBaudrate	(BAUDRATE br)
39:                {
40:                	U16 tmpMODE	= U1MODE;
00730C  801102     MOV U1MODE, W2
41:                	U16 tmpSTA	= U1STA;
00730E  801111     MOV U1STA, W1
42:                	U1MODE		= 0;				//	UART Stop
007310  EF2220     CLR U1MODE
43:                	U1STA		= 0;
007312  EF2222     CLR U1STA
44:                	TxWrite = TxSent = RxRec = RxRead = Enter = 0;
007314  EF690E     CLR.B Enter
007316  2090E3     MOV #0x90E, W3
007318  784193     MOV.B [W3], W3
00731A  209114     MOV #0x911, W4
00731C  784A03     MOV.B W3, [W4]
00731E  209113     MOV #0x911, W3
007320  784193     MOV.B [W3], W3
007322  209124     MOV #0x912, W4
007324  784A03     MOV.B W3, [W4]
007326  209123     MOV #0x912, W3
007328  784193     MOV.B [W3], W3
00732A  209104     MOV #0x910, W4
00732C  784A03     MOV.B W3, [W4]
00732E  209103     MOV #0x910, W3
007330  784193     MOV.B [W3], W3
007332  2090F4     MOV #0x90F, W4
007334  784A03     MOV.B W3, [W4]
45:                
46:                	U1BRG		= BaudRates[br][Oscillator];	//	BAUD Rate
007336  DD0043     SL W0, #3, W0
007338  804853     MOV 0x90A, W3
00733A  400003     ADD W0, W3, W0
00733C  400000     ADD W0, W0, W0
00733E  2B57E3     MOV #0xB57E, W3
007340  7801E3     MOV [W3+W0], W3
007342  881143     MOV W3, U1BRG
47:                
48:                	U1MODE	= tmpMODE;
007344  881102     MOV W2, U1MODE
49:                	U1STA	= tmpSTA;
007346  881111     MOV W1, U1STA
50:                }
007348  060000     RETURN
51:                
52:                void Uart1_Flush	(void)
53:                {
54:                	TxWrite = TxSent = RxRec = RxRead = Enter = 0;
00734A  EF690E     CLR.B Enter
00734C  2090E1     MOV #0x90E, W1
00734E  784091     MOV.B [W1], W1
007350  209110     MOV #0x911, W0
007352  784801     MOV.B W1, [W0]
007354  209111     MOV #0x911, W1
007356  784091     MOV.B [W1], W1
007358  209120     MOV #0x912, W0
00735A  784801     MOV.B W1, [W0]
00735C  209121     MOV #0x912, W1
00735E  784091     MOV.B [W1], W1
007360  209100     MOV #0x910, W0
007362  784801     MOV.B W1, [W0]
007364  209101     MOV #0x910, W1
007366  784091     MOV.B [W1], W1
007368  2090F0     MOV #0x90F, W0
00736A  784801     MOV.B W1, [W0]
55:                }
00736C  060000     RETURN
56:                
57:                // **********************************************************************
58:                //	Tx1 INTERRUPT
59:                // **********************************************************************
60:                void __attribute__((interrupt, no_auto_psv)) _U1TXInterrupt( void )
61:                {
00736E  BE9F80     MOV.D W0, [W15++]
007370  781F82     MOV W2, [W15++]
62:                	_U1TXIF		= 0;				// Clear the Transmit Interrupt Flag
007372  A98085     BCLR 0x85, #4
63:                	if (TxWrite	!= TxSent)			//	if remain bytes in buffer
007374  BFC910     MOV.B TxSent, WREG
007376  E3490F     CP.B TxWrite
007378  320009     BRA Z, 0x738C
64:                		U1TXREG	= TxBuff[TxSent++];	//	Transmit next byte
00737A  BFC910     MOV.B TxSent, WREG
00737C  FB8080     ZE W0, W1
00737E  22B942     MOV #0x2B94, W2
007380  78C0E2     MOV.B [W2+W1], W1
007382  FB8081     ZE W1, W1
007384  881121     MOV W1, U1TXREG
007386  E84000     INC.B W0, W0
007388  B7E910     MOV.B WREG, TxSent
00738A  370001     BRA 0x738E
65:                	else
66:                		_U1TXIE		= 0;			// Disable Transmit Interrupt
00738C  A98095     BCLR 0x95, #4
67:                }
00738E  78014F     MOV [--W15], W2
007390  BE004F     MOV.D [--W15], W0
007392  064000     RETFIE
68:                
69:                #ifndef	UART1_GPS
70:                // **********************************************************************
71:                //	Rx1 INTERRUPT
72:                // **********************************************************************
73:                void __attribute__((interrupt, no_auto_psv)) _U1RXInterrupt( void )
74:                {
007394  BE9F80     MOV.D W0, [W15++]
007396  BE9F82     MOV.D W2, [W15++]
75:                	U8	temp = U1RXREG;				// read from uart1 Rx buffer
007398  801131     MOV U1RXREG, W1
76:                	_U1RXIF		= 0;				// Clear the Recieve Interrupt Flag
00739A  A96085     BCLR 0x85, #3
77:                
78:                	if (temp == CR)					// Enter received
00739C  50CFED     SUB.B W1, #0xD, [W15]
00739E  3A0002     BRA NZ, 0x73A4
79:                	{
80:                		Enter++;
0073A0  EC690E     INC.B Enter
81:                		GPS_IF = 1;
0073A2  A8A089     BSET 0x89, #5
82:                	}
83:                	RxBuff[RxRec++] = temp; 		// save to rx buffer
0073A4  BFC912     MOV.B RxRec, WREG
0073A6  FB8100     ZE W0, W2
0073A8  22C943     MOV #0x2C94, W3
0073AA  797181     MOV.B W1, [W3+W2]
0073AC  E84000     INC.B W0, W0
0073AE  B7E912     MOV.B WREG, RxRec
84:                }
0073B0  BE014F     MOV.D [--W15], W2
0073B2  BE004F     MOV.D [--W15], W0
0073B4  064000     RETFIE
85:                
86:                
87:                U8 Uart1_ByteReceived	(void)
88:                {
89:                	return (RxRec != RxRead);
0073B6  BFC912     MOV.B RxRec, WREG
0073B8  B6C911     XOR.B RxRead, WREG
0073BA  FB8000     ZE W0, W0
0073BC  EA0000     NEG W0, W0
0073BE  DE004F     LSR W0, #15, W0
90:                }
0073C0  060000     RETURN
91:                
92:                U8 Uart1_StringReceived	(void)
93:                {
94:                	return Enter;
0073C2  BFC90E     MOV.B Enter, WREG
95:                }
0073C4  060000     RETURN
96:                
97:                U8 Uart1_GetByte(void)
98:                {
99:                	register U8 temp = RxBuff[RxRead++];
0073C6  BFC911     MOV.B RxRead, WREG
0073C8  FB8080     ZE W0, W1
0073CA  22C942     MOV #0x2C94, W2
0073CC  78C0E2     MOV.B [W2+W1], W1
0073CE  E84000     INC.B W0, W0
0073D0  B7E911     MOV.B WREG, RxRead
100:               	if (temp == CR)					// Enter received
0073D2  50CFED     SUB.B W1, #0xD, [W15]
0073D4  3A0001     BRA NZ, 0x73D8
101:               		Enter--;
0073D6  ED690E     DEC.B Enter
102:               	return temp;
103:               }
0073D8  784001     MOV.B W1, W0
0073DA  060000     RETURN
104:               #endif
105:               void Uart1_SendByte(char data)
106:               {
107:               	TxBuff[TxWrite++] = data;
0073DC  2090F1     MOV #0x90F, W1
0073DE  784091     MOV.B [W1], W1
0073E0  FB8101     ZE W1, W2
0073E2  22B943     MOV #0x2B94, W3
0073E4  797180     MOV.B W0, [W3+W2]
0073E6  E84081     INC.B W1, W1
0073E8  784101     MOV.B W1, W2
0073EA  2090F0     MOV #0x90F, W0
0073EC  784802     MOV.B W2, [W0]
108:               	if ((_U1TXIE == 0) && (TxWrite != TxSent))
0073EE  AB8095     BTST 0x95, #4
0073F0  3A0005     BRA NZ, 0x73FC
0073F2  BFC910     MOV.B TxSent, WREG
0073F4  E3490F     CP.B TxWrite
0073F6  320002     BRA Z, 0x73FC
109:               	{
110:               		_U1TXIE		= 1;				// Enable Transmit Interrupt
0073F8  A88095     BSET 0x95, #4
111:               		_U1TXIF		= 1;				// Set Transmit Interrupt Flag
0073FA  A88085     BSET 0x85, #4
112:               	}
113:               }
0073FC  060000     RETURN
114:               #ifndef	UART1_GPS
115:               void Uart1_GetString(P_U8 str)
116:               {
0073FE  781F88     MOV W8, [W15++]
007400  780400     MOV W0, W8
117:               	if (Enter)
007402  E2490E     CP0.B Enter
007404  320007     BRA Z, 0x7414
118:               	{
119:               		while (1)
120:               		{
121:               			register U8 data = Uart1_GetByte();
007406  07FFDF     RCALL Uart1_GetByte
122:               			if (data == CR)
007408  504FED     SUB.B W0, #0xD, [W15]
00740A  320004     BRA Z, 0x7414
123:               				break;
124:               			else if (data != LF)
00740C  504FEA     SUB.B W0, #0xA, [W15]
00740E  32FFFB     BRA Z, 0x7406
125:               				*str++ = data;
007410  785C00     MOV.B W0, [W8++]
007412  37FFF9     BRA 0x7406
126:               		}
127:               	}
128:               	*str = '\0';
007414  EB4C00     CLR.B [W8]
129:               }
007416  78044F     MOV [--W15], W8
007418  060000     RETURN
130:               #endif
131:               void Uart1_SendText	(const char *str)
132:               {
00741A  781F88     MOV W8, [W15++]
00741C  780400     MOV W0, W8
133:               	while (*str)
00741E  784018     MOV.B [W8], W0
007420  E00400     CP0.B W0
007422  320004     BRA Z, 0x742C
007426  784058     MOV.B [++W8], W0
007428  E00400     CP0.B W0
00742A  3AFFFC     BRA NZ, 0x7424
134:               		Uart1_SendByte(*str++);
007424  07FFDB     RCALL Uart1_SendByte
135:               }
00742C  78044F     MOV [--W15], W8
00742E  060000     RETURN
136:               
137:               void Uart1_SendData	(const char *str, U16 len)
138:               {
007430  BE9F88     MOV.D W8, [W15++]
007432  780480     MOV W0, W9
007434  780401     MOV W1, W8
139:               	while (len)
007436  E00008     CP0 W8
007438  320004     BRA Z, 0x7442
007440  3AFFFC     BRA NZ, 0x743A
140:               	{
141:               		Uart1_SendByte(*str++);
00743A  784039     MOV.B [W9++], W0
00743C  07FFCF     RCALL Uart1_SendByte
142:               		len--;
00743E  E90408     DEC W8, W8
143:               	}
144:               }
007442  BE044F     MOV.D [--W15], W8
007444  060000     RETURN
145:               
146:               void Uart1_SendEnter(void)
147:               {
148:               	Uart1_SendByte(CR);
007446  B3C0D0     MOV.B #0xD, W0
007448  07FFC9     RCALL Uart1_SendByte
149:               	Uart1_SendByte(LF);
00744A  B3C0A0     MOV.B #0xA, W0
00744C  07FFC7     RCALL Uart1_SendByte
150:               }
00744E  060000     RETURN
151:               
---  /home/pele/src/Auto_02/src/Timers.c  ---------------------------------------------------------------
1:                 #include	"Timers.h"
2:                 #include	"Ports.h"
3:                 #include	"Gsm.h"
4:                 #include	"Tcp.h"
5:                 #include	"Uart2.h"
6:                 #include	"Uart3.h"
7:                 #include	<string.h>
8:                 //#include	"Memory.h"
9:                 
10:                
11:                volatile	U16		LedStatus1 = LED_STATUS_OFF, LedStatus2 = LED_STATUS_OFF, LedStatus3 = LED_STATUS_OFF, LedStatus4 = LED_STATUS_OFF;
12:                volatile	U16		Ms = 0;
13:                volatile	U16		LedBit, Sec, Tics_ms = 0;
14:                volatile	TIME_ST	SysTime;
15:                volatile	U16		StartYear = 2000;
16:                
17:                
18:                //-------------------------------------------------------------------------------------------------
19:                //	OSC_4__MHZ_FRCDIV	Fast RC Oscillator with Postscaler (FRCDIV)
20:                //	OSC_05_MHZ_FRC_16	Fast RC Oscillator/16 (500 KHz)
21:                //	OSC_31_KHZ_LPRC		Low-Power RC Oscillator (LPRC)
22:                //	OSC_0__MHZ_SOSC		Secondary Oscillator (SOSC)
23:                //	OSC_0__MHZ_PRI_PLL	Primary Oscillator with PLL module (XTPLL, HSPLL, ECPLL)
24:                //	OSC_0__MHZ_PRI		Primary Oscillator (XT, HS, EC)
25:                //	OSC_32_MHZ_FRCPLL	Fast RC Oscillator with Postscaler and PLL module (FRCPLL)
26:                //	OSC_8__MHZ_FRC		Fast RC Oscillator (FRC)
27:                //-------------------------------------------------------------------------------------------------
28:                OSC Oscillator = Osc_4__MHz;
29:                const U16 BaudRates[5][8] =
30:                {
31:                	{
32:                		((( 8000000 /2 / 16) / 9600) - 1),		// 26.04166
33:                		(((32000000 /2 / 16) / 9600) - 1),		// 104.1666
34:                		(((       0 /2 / 16) / 9600) - 1),		// 0
35:                		(((       0 /2 / 16) / 9600) - 1),		// 0
36:                		(((       0 /2 / 16) / 9600) - 1),		// 0
37:                		(((   31000 /2 / 16) / 9600) - 1),		// 0
38:                		(((  500000 /2 / 16) / 9600)),			// 1,627604
39:                		((( 4000000 /2 / 16) / 9600) - 1)		// 13
40:                	},
41:                	{
42:                		((( 8000000 /2 / 16) / 19200) - 1),		// 13.0208
43:                		(((32000000 /2 / 16) / 19200) - 1),		// 53.0833
44:                		(((       0 /2 / 16) / 19200) - 1),		// 0
45:                		(((       0 /2 / 16) / 19200) - 1),		// 0
46:                		(((       0 /2 / 16) / 19200) - 1),		// 0
47:                		(((   31000 /2 / 16) / 19200) - 1),		// 0
48:                		(((  500000 /2 / 16) / 19200) - 1),		// 0
49:                		((( 4000000 /2 / 16) / 19200))			// 6.5104
50:                	},
51:                	{
52:                		((( 8000000 /2 / 16) / 38400)),			// 6.5104
53:                		(((32000000 /2 / 16) / 38400) - 1),		// 26.0416
54:                		(((       0 /2 / 16) / 38400) - 1),		// 0
55:                		(((       0 /2 / 16) / 38400) - 1),		// 0
56:                		(((       0 /2 / 16) / 38400) - 1),		// 0
57:                		(((   31000 /2 / 16) / 38400) - 1),		// 0
58:                		(((  500000 /2 / 16) / 38400)),			// 0
59:                		((( 4000000 /2 / 16) / 38400) - 1)		// 3.2552
60:                	},
61:                	{
62:                		((( 8000000 /2 / 16) / 57600) - 1),		// 4.340278
63:                		(((32000000 /2 / 16) / 57600) - 1),		// 17.36111
64:                		(((       0 /2 / 16) / 57600) - 1),		// 0
65:                		(((       0 /2 / 16) / 57600) - 1),		// 0
66:                		(((       0 /2 / 16) / 57600) - 1),		// 0
67:                		(((   31000 /2 / 16) / 57600) - 1),		// 0
68:                		(((  500000 /2 / 16) / 57600)),			// 0
69:                		((( 4000000 /2 / 16) / 57600) - 1)		// 2.170139
70:                	},
71:                	{
72:                		((( 8000000 /2 / 16) / 115200) - 1),	// 2,170138
73:                		(((32000000 /2 / 16) / 115200)),		// 8,680555
74:                		(((       0 /2 / 16) / 115200) - 1),	// 0
75:                		(((       0 /2 / 16) / 115200) - 1),	// 0
76:                		(((       0 /2 / 16) / 115200) - 1),	// 0
77:                		(((   31000 /2 / 16) / 115200) - 1),	// 0
78:                		(((  500000 /2 / 16) / 115200)),		// 0
79:                		((( 4000000 /2 / 16) / 115200) - 1)		// 1,085069
80:                	},
81:                };
82:                
83:                
84:                void OSCconfig(OSC osc)
85:                {
006BDE  781F88     MOV W8, [W15++]
006BE0  780400     MOV W0, W8
86:                	Oscillator = osc;
006BE2  884858     MOV W8, 0x90A
87:                //	CLKDIV	= 	0b0000000100000000
88:                			//	  |||||||||||+++++	---	Unimplemented (Reserved)
89:                			//	  ||||||||||+-----	---	PLLEN: 96 MHz PLL Enable bit
90:                			//	  ||||||||++------	---	CPDIV<1:0>: System Clock Select bits (postscaler select from 32 MHz clock branch)
91:                			//	  |||||+++--------	---	RCDIV<2:0>: FRC Postscaler Select bits
92:                			//	  ||||+-----------	---	DOZEN: DOZE Enable bit
93:                			//	  |+++------------	---	DOZE<2:0>: CPU Peripheral Clock Ratio Select bits
94:                			//	  +---------------	---	ROI: Recover on Interrupt bit
95:                
96:                	if ((osc == Osc_32_MHz) /*|| (osc == Osc_0_PriPLL)*/)
006BE4  540FE1     SUB W8, #0x1, [W15]
006BE6  3A0001     BRA NZ, 0x6BEA
97:                		_PLLEN = 1;					// Enable PLL 96 MHz
006BE8  A8A744     BSET CLKDIV, #5
98:                
99:                
100:               	__builtin_write_OSCCONH(osc);
006BEA  2009A1     MOV #0x9A, W1
006BEC  200780     MOV #0x78, W0
006BEE  207432     MOV #0x743, W2
006BF0  784900     MOV.B W0, [W2]
006BF2  784901     MOV.B W1, [W2]
006BF4  784908     MOV.B W8, [W2]
101:               	__builtin_write_OSCCONL(0x01);	// Initiate Clock Switch
006BF6  200571     MOV #0x57, W1
006BF8  200012     MOV #0x1, W2
006BFA  200460     MOV #0x46, W0
006BFC  207423     MOV #0x742, W3
006BFE  784980     MOV.B W0, [W3]
006C00  784981     MOV.B W1, [W3]
006C02  784982     MOV.B W2, [W3]
102:               
103:               	// Wait for Clock switch to occur
104:               	while (_OSWEN);
006C04  AB0742     BTST OSCCON, #0
006C06  3AFFFE     BRA NZ, 0x6C04
105:               
106:               	// Wait for PLL to lock
107:               	if ((osc == Osc_32_MHz) /*|| (osc == Osc_0_PriPLL)*/)
006C08  540FE1     SUB W8, #0x1, [W15]
006C0A  3A0005     BRA NZ, 0x6C16
108:               	{
109:               		while(_LOCK != 1);
006C0C  200201     MOV #0x20, W1
006C0E  803A12     MOV OSCCON, W2
006C10  608002     AND W1, W2, W0
006C12  32FFFD     BRA Z, 0x6C0E
006C14  370001     BRA 0x6C18
110:               	}
111:               	else
112:               		_PLLEN = 0;					// Disable PLL 96 MHz
006C16  A9A744     BCLR CLKDIV, #5
113:               
114:               	TimersInit();
006C18  07FF6F     RCALL TimersInit
115:               //	Uart1SetBaudrate(BaudRates[0][osc]);
116:               //	Uart2_SetBaudrate(BaudRate_115200);
117:               //	Uart2_SetBaudrate(BaudRates[0][osc]);
118:               	Uart3_SetBaudrate(BaudRates[3][osc]);
006C1A  440478     ADD W8, #0x18, W8
006C1C  440408     ADD W8, W8, W8
006C1E  2B57E0     MOV #0xB57E, W0
006C20  7C0060     MOV [W0+W8], W0
006C22  07042F     RCALL Uart3_SetBaudrate
119:               }
006C24  78044F     MOV [--W15], W8
006C26  060000     RETURN
120:               
121:               
122:               // **********************************************************************
123:               //	Init All Timers
124:               // **********************************************************************
125:               void TimersInit(void)
126:               {
127:               	T1CON				= 0;		//	Timer1 reset
006AF8  EF2104     CLR T1CON
128:               	T2CON				= 0;		//	Timer2 reset
006AFA  EF2110     CLR T2CON
129:               	T3CON				= 0;		//	Timer3 reset
006AFC  EF2112     CLR T3CON
130:               	T4CON				= 0;		//	Timer4 reset
006AFE  EF211E     CLR T4CON
131:               	OC1CON1bits.OCM		= 0; 		// Output compare channel is disabled (PWM)
006B00  2FFF80     MOV #0xFFF8, W0
006B02  B62190     AND OC1CON1
132:               	OC2CON1bits.OCM		= 0; 		// Output compare channel is disabled (PWM)
006B04  B6219A     AND OC2CON1
133:               
134:               	switch (Oscillator)
006B06  804850     MOV 0x90A, W0
006B08  500FE1     SUB W0, #0x1, [W15]
006B0A  320013     BRA Z, 0x6B32
006B0C  390005     BRA NC, 0x6B18
006B0E  500FE5     SUB W0, #0x5, [W15]
006B10  320026     BRA Z, 0x6B5E
006B12  500FE6     SUB W0, #0x6, [W15]
006B14  3A0034     BRA NZ, 0x6B7E
006B16  37002B     BRA 0x6B6E
135:               	{
136:               	case Osc_8__MHz:
137:               		T1CONbits.TCKPS	= 0b10;				//	T1 Prescaler	| 11b - 1:256;	10b - 1:64
006B18  2FFCF0     MOV #0xFFCF, W0
006B1A  800822     MOV T1CON, W2
006B1C  600082     AND W0, W2, W1
006B1E  A05001     BSET W1, #5
006B20  880821     MOV W1, T1CON
138:               		T2CONbits.TCKPS	= 0b00;				//	T2 Prescaler	| 01b - 1:8;	00b - 1:1
006B22  B62110     AND T2CON
139:               		T3CONbits.TCKPS	= 0b10;				//	T3 Prescaler
006B24  B60112     AND T3CON, WREG
006B26  A05000     BSET W0, #5
006B28  880890     MOV W0, T3CON
140:               		PR1		= (4000000 / 64 / 1000);	//	FOSC / Prescaler / 1000Hz	(mS)
006B2A  2003E0     MOV #0x3E, W0
006B2C  880810     MOV W0, PR1
141:               //		PR2		= DC_PERIOD;				//	DC/DC period
142:               		PR3		= (4000000 / 64 / 1000);	//	FOSC / Prescaler / 1000Hz 	(mS)
006B2E  880870     MOV W0, PR3
143:               		break;
006B30  370033     BRA 0x6B98
144:               	case Osc_32_MHz:
145:               		T1CONbits.TCKPS	= 0b10;					//	T1 Prescaler	| 00b - 1:1
006B32  2FFCF0     MOV #0xFFCF, W0
006B34  800823     MOV T1CON, W3
006B36  600083     AND W0, W3, W1
006B38  A05001     BSET W1, #5
006B3A  880821     MOV W1, T1CON
146:               		T2CONbits.TCKPS	= 0b00;					//	T2 Prescaler	| 01b - 1:8
006B3C  B62110     AND T2CON
147:               		T3CONbits.TCKPS	= 0b10;					//	T3 Prescaler	| 10b - 1:64
006B3E  800892     MOV T3CON, W2
006B40  600082     AND W0, W2, W1
006B42  A05001     BSET W1, #5
006B44  880891     MOV W1, T3CON
148:               		T4CONbits.TCKPS	= 0b01;					//	T4 Prescaler	| 11b - 1:256
006B46  B6011E     AND T4CON, WREG
006B48  A04000     BSET W0, #4
006B4A  8808F0     MOV W0, T4CON
149:               		PR1		= (16000000 /  64 / 1000) - 1;	//	FOSC / Prescaler / 1000Hz	(1mS)
006B4C  200F90     MOV #0xF9, W0
006B4E  880810     MOV W0, PR1
150:               		PR2		= (DC_PERIOD	 		  - 1);	//	DC/DC period
006B50  2009F0     MOV #0x9F, W0
006B52  880860     MOV W0, PR2
151:               		PR3		= (16000000	/  64 / 100)  - 1;	//	FOSC / Prescaler / 100Hz 	(10mS)
006B54  209C30     MOV #0x9C3, W0
006B56  880870     MOV W0, PR3
152:               		PR4		= (16000000 /   8 / 100)  - 1;	//	FOSC / Prescaler / 100Hz
006B58  24E1F0     MOV #0x4E1F, W0
006B5A  8808D0     MOV W0, PR4
153:               		break;
006B5C  37001D     BRA 0x6B98
154:               	case Osc_31_kHz:
155:               		T1CONbits.TCKPS	= 0b00;				//	T1 Prescaler	| 11b - 1:256;	10b - 1:64
006B5E  2FFCF0     MOV #0xFFCF, W0
006B60  B62104     AND T1CON
156:               		T2CONbits.TCKPS	= 0b00;				//	T2 Prescaler	| 01b - 1:8;	00b - 1:1
006B62  B62110     AND T2CON
157:               		T3CONbits.TCKPS	= 0b00;				//	T3 Prescaler
006B64  B62112     AND T3CON
158:               		PR1		= (15500 / 1 / 1000);		//	FOSC / Prescaler / 1000Hz	(mS)
006B66  2000F0     MOV #0xF, W0
006B68  880810     MOV W0, PR1
159:               //		PR2		= DC_PERIOD;				//	DC/DC period
160:               		PR3		= (15500 / 1 / 1000);		//	FOSC / Prescaler / 1000Hz 	(mS)
006B6A  880870     MOV W0, PR3
161:               		break;
006B6C  370015     BRA 0x6B98
162:               	case Osc_05_MHz:
163:               		T1CONbits.TCKPS	= 0b00;				//	T1 Prescaler	| 11b - 1:256;	10b - 1:64
006B6E  2FFCF0     MOV #0xFFCF, W0
006B70  B62104     AND T1CON
164:               		T2CONbits.TCKPS	= 0b00;				//	T2 Prescaler	| 01b - 1:8;	00b - 1:1
006B72  B62110     AND T2CON
165:               		T3CONbits.TCKPS	= 0b00;				//	T3 Prescaler
006B74  B62112     AND T3CON
166:               		PR1		= (250000 / 1 / 1000);		//	FOSC / Prescaler / 1000Hz	(mS)
006B76  200FA0     MOV #0xFA, W0
006B78  880810     MOV W0, PR1
167:               //		PR2		= DC_PERIOD;				//	DC/DC period
168:               		PR3		= (250000 / 1 / 1000);		//	FOSC / Prescaler / 1000Hz 	(mS)
006B7A  880870     MOV W0, PR3
169:               		break;
006B7C  37000D     BRA 0x6B98
170:               	case Osc_4__MHz:
171:               	case Osc_0_Pri:
172:               	case Osc_0_PriPLL:
173:               	case Osc_0_SOSC:
174:               	default:
175:               		T1CONbits.TCKPS	= 0b01;				//	T1 Prescaler	| 11b - 1:256;	10b - 1:64
006B7E  2FFCF0     MOV #0xFFCF, W0
006B80  800823     MOV T1CON, W3
006B82  600083     AND W0, W3, W1
006B84  A04001     BSET W1, #4
006B86  880821     MOV W1, T1CON
176:               		T2CONbits.TCKPS	= 0b00;				//	T2 Prescaler	| 01b - 1:8;	00b - 1:1
006B88  B62110     AND T2CON
177:               		T3CONbits.TCKPS	= 0b10;				//	T3 Prescaler
006B8A  B60112     AND T3CON, WREG
006B8C  A05000     BSET W0, #5
006B8E  880890     MOV W0, T3CON
178:               		PR1		= (2000000 / 8 / 1000);		//	FOSC / Prescaler / 1000Hz	(mS)
006B90  200FA0     MOV #0xFA, W0
006B92  880810     MOV W0, PR1
179:               //		PR2		= DC_PERIOD;				//	DC/DC period
180:               		PR3		= (2000000 / 64 / 1000);	//	FOSC / Prescaler / 1000Hz 	(mS)
006B94  2001F0     MOV #0x1F, W0
006B96  880870     MOV W0, PR3
181:               		break;
182:               	}
183:               
184:               	OC1R					= 0;		// Initialize Compare Register1 with 0% duty cycle				(default)
006B98  EF2196     CLR OC1R
185:               //	OC1RS					= 0;		// Initialize Secondary Compare Register1 with 0% duty cycle	(default)
186:               //	OC1CON2bits.SYNCSEL		= 0b01100;	// Trigger/Synchronization Source = Timer2						(default)
187:               //	OC1CON2bits.OCTRIG		= 0;																		(default)
188:               //	OC1CON1bits.TRIGMODE	= 0;																		(default)
189:               //	OC1CON2bits.TRIGSTAT	= 0;																		(default)
190:               //	OC1CON1bits.OCSIDL		= 0;		// Output capture will continue to operate in CPU Idle mode		(default)
191:               //	OC1CON1bits.OCFLT		= 0;		// No PWM Fault condition has occurred (this bit is only used when OCM<2:0> = 111)	(default)
192:               //	OC1CON1bits.OCTSEL		= 0b111;	// FCY is the clock source for output Compare
193:               //	OC1CON1bits.OCTSEL		= 0b000;	// Timer2 is the clock source for output Compare				(default)
194:               	OC1CON1bits.OCM			= 0b110;	// Edge-Aligned PWM Mode on OCx (Fault pin disabled)
006B9A  2FFF81     MOV #0xFFF8, W1
006B9C  800C82     MOV OC1CON1, W2
006B9E  608002     AND W1, W2, W0
006BA0  B30060     IOR #0x6, W0
006BA2  880C80     MOV W0, OC1CON1
195:               
196:               	_T1IP = 4;		//	Timer1 Interrupt priority level=4
006BA4  28FFF0     MOV #0x8FFF, W0
006BA6  800523     MOV IPC0, W3
006BA8  600103     AND W0, W3, W2
006BAA  A0E002     BSET W2, #14
006BAC  880522     MOV W2, IPC0
197:               	_T2IP = 4;		//	Timer2 Interrupt priority level=4
006BAE  800533     MOV IPC1, W3
006BB0  600103     AND W0, W3, W2
006BB2  A0E002     BSET W2, #14
006BB4  880532     MOV W2, IPC1
198:               	_T3IP = 4;		//	Timer3 Interrupt priority level=4
006BB6  800542     MOV IPC2, W2
006BB8  608082     AND W1, W2, W1
006BBA  A02001     BSET W1, #2
006BBC  880541     MOV W1, IPC2
199:               	_T4IP = 4;		//	Timer4 Interrupt priority level=4
006BBE  B600B0     AND IPC6, WREG
006BC0  A0E000     BSET W0, #14
006BC2  880580     MOV W0, IPC6
200:               
201:               	memset((char*)&SysTime, 0, sizeof(SysTime));
006BC4  200082     MOV #0x8, W2
006BC6  EB0080     CLR W1
006BC8  208A00     MOV #0x8A0, W0
006BCA  07D323     RCALL _memset
202:               	T1CONbits.TON = 1;		//	Enable Timer1 and start the counter
006BCC  A8E105     BSET 0x105, #7
203:               	_T1IF = 0;				//	Reset Timer1 interrupt flag
006BCE  A96084     BCLR IFS0, #3
204:               	_T1IE = 1;				//	Enable Timer1 interrupt
006BD0  A86094     BSET IEC0, #3
205:               
206:               	T2CONbits.TON = 1;		//	Enable Timer2 and start the counter
006BD2  A8E111     BSET 0x111, #7
207:               //	_T2IF = 0;				//	Reset Timer2 interrupt flag
208:               //	_T2IE = 1;				//	Enable Timer2 interrupt
209:               
210:               	T3CONbits.TON = 1;		//	Enable Timer3 and start the counter
006BD4  A8E113     BSET 0x113, #7
211:               	_T3IF = 0;				//	Reset Timer3 interrupt flag
006BD6  A90085     BCLR 0x85, #0
212:               	_T3IE = 1;				//	Enable Timer3 interrupt
006BD8  A80095     BSET 0x95, #0
213:               
214:               	T4CONbits.TON = 1;		//	Enable Timer4 and start the counter
006BDA  A8E11F     BSET 0x11F, #7
215:               //	_T4IF = 0;				//	Clear  Timer4 interrupt flag
216:               //	_T4IE = 1;				//	Enable Timer4 interrupt
217:               
218:               //	_IC3IP	= 5;			//	Set		IC3 interrupt priority
219:               //	_IC3IF	= 0;			//	Clear	IC3 interrupt flag
220:               //	_IC3IE	= 1;			//	Enable	IC3 interrupt
221:               }
006BDC  060000     RETURN
222:               
223:               // **********************************************************************
224:               inline	void DcDcUpdate		(void);
225:               inline	void SysTimeIrq		(void);
226:               inline	void LedStatusUpdate(void);
227:               //extern inline void SpiMemTimer(void);
228:               extern	volatile U16	WifiSec;
229:               // ......................................................................
230:               // Timer1 INTERRUPT			1000Hz - 1ms
231:               // **********************************************************************
232:               void __attribute__((interrupt, no_auto_psv)) _T1Interrupt( void )
233:               {
006D30  F80036     PUSH RCOUNT
006D32  BE9F80     MOV.D W0, [W15++]
006D34  BE9F82     MOV.D W2, [W15++]
006D36  BE9F84     MOV.D W4, [W15++]
006D38  BE9F86     MOV.D W6, [W15++]
234:               	_T1IF = 0;				//	Reset Timer1 interrupt flag
006D3A  A96084     BCLR IFS0, #3
235:               
236:               	Tics_ms++;
006D3C  EC289E     INC Tics_ms
237:               //	DcDcUpdate();
238:               	SysTimeIrq();
006D3E  07FF75     RCALL SysTimeIrq
239:               	LedStatusUpdate();
006D40  07FF9B     RCALL LedStatusUpdate
240:               }
006D42  BE034F     MOV.D [--W15], W6
006D44  BE024F     MOV.D [--W15], W4
006D46  BE014F     MOV.D [--W15], W2
006D48  BE004F     MOV.D [--W15], W0
006D4A  F90036     POP RCOUNT
006D4C  064000     RETFIE
241:               
242:               inline void DcDcUpdate(void)
243:               {
244:               /*	U16 step, adc = AN_V18;
245:               
246:               	ProcPowerReduction	= (adc > AN_V18_VALUE)?	(U8)((adc - 562) / 21): 0;
247:               	step				= DcDcReductionSteps[ProcPowerReduction];
248:               
249:               	adc = AN_DC_DC;
250:               	if (adc > step)
251:               	{
252:               		if (OC1R)					OC1R--;
253:               	}
254:               	else if (adc < step)
255:               	{
256:               //		if (OC1R < DC_DUTY_MAX)		OC1R++;
257:               	}
258:               */
259:               }
006C28  060000     RETURN
260:               
261:               inline	void SysTimeIrq	(void)
262:               {
263:               	if (++Ms >= 1000)
006C2A  EC289C     INC Ms
006C2C  203E70     MOV #0x3E7, W0
006C2E  E3089C     CP Ms
006C30  360022     BRA LEU, 0x6C76
264:               	{	Ms		= 0;
006C32  EF289C     CLR Ms
265:               //		if (Sec & 0x0001)
266:               			LedBit	= 0x8000;
006C34  280000     MOV #0x8000, W0
006C36  884540     MOV W0, LedBit
267:               		Sec++;
006C38  EC28AA     INC Sec
268:               		#ifdef UART4_WIFI
269:               			WifiSec++;
006C3A  EC28B4     INC WifiSec
270:               		#endif
271:               		FL_GSM_SEC = 1;
006C3C  A8092C     BSET SysFlags, #0
272:               		if (SysTime.gpsFix)					SysTime.gpsFix	= 0;
006C3E  E248A7     CP0.B 0x8A7
006C40  320002     BRA Z, 0x6C46
006C42  EF68A7     CLR.B 0x8A7
006C44  37000F     BRA 0x6C64
273:               		else if	  (++SysTime.sec  >= 60) {	SysTime.sec		= 0;
006C46  EC68A6     INC.B 0x8A6
006C48  B3C3B0     MOV.B #0x3B, W0
006C4A  E348A6     CP.B 0x8A6
006C4C  36000B     BRA LEU, 0x6C64
006C4E  EF68A6     CLR.B 0x8A6
274:               			  if  (++SysTime.min  >= 60) {	SysTime.min		= 0;
006C50  EC68A5     INC.B 0x8A5
006C52  E348A5     CP.B 0x8A5
006C54  360007     BRA LEU, 0x6C64
006C56  EF68A5     CLR.B 0x8A5
275:               			   if (++SysTime.hour >= 24) {	SysTime.hour	= 0;
006C58  EC68A4     INC.B 0x8A4
006C5A  BFC8A4     MOV.B 0x8A4, WREG
006C5C  504FF7     SUB.B W0, #0x17, [W15]
006C5E  360002     BRA LEU, 0x6C64
006C60  EF68A4     CLR.B 0x8A4
276:               				   ++SysTime.day;
006C62  EC68A3     INC.B 0x8A3
277:               			   }
278:               			}
279:               		}
280:               		if (FL_WEB_ONLINE)
006C64  ABA92C     BTST SysFlags, #5
006C66  320007     BRA Z, 0x6C76
281:               		{
282:               			if (OnlineTimer)	OnlineTimer--;
006C68  804740     MOV OnlineTimer, W0
006C6A  E00000     CP0 W0
006C6C  320003     BRA Z, 0x6C74
006C6E  E90000     DEC W0, W0
006C70  884740     MOV W0, OnlineTimer
006C72  370001     BRA 0x6C76
283:               			else				FL_WEB_ONLINE = 0;
006C74  A9A92C     BCLR SysFlags, #5
284:               		}
285:               	}
286:               }
006C76  060000     RETURN
287:               
288:               
289:               inline void LedStatusUpdate(void)
290:               {
291:               	static	U8	ledTimer = 0;
292:               	static	U8	oneLedCnt = 0;
293:               
294:               	if (ledTimer)
006C78  BFC8B1     MOV.B ledTimer, WREG
006C7A  320003     BRA Z, 0x6C82
295:               		ledTimer--;
006C7C  E94000     DEC.B W0, W0
006C7E  B7E8B1     MOV.B WREG, ledTimer
006C80  370056     BRA 0x6D2E
296:               	else	if (LedBit)
006C82  E208A8     CP0 LedBit
006C84  320054     BRA Z, 0x6D2E
297:               //	if ((!ledTimer) && (LedBit))
298:               	{
299:               		switch (oneLedCnt)
006C86  BFC8B0     MOV.B oneLedCnt, WREG
006C88  504FE1     SUB.B W0, #0x1, [W15]
006C8A  32001A     BRA Z, 0x6CC0
006C8C  390003     BRA NC, 0x6C94
006C8E  504FE2     SUB.B W0, #0x2, [W15]
006C90  3A003B     BRA NZ, 0x6D08
006C92  370028     BRA 0x6CE4
300:               		{
301:               		case 0:		LED1 = (LedStatus1 & LedBit)? 1:0;
006C94  8044A0     MOV LedStatus1, W0
006C96  B608A8     AND LedBit, WREG
006C98  A7F000     BTSC W0, #15
006C9A  EA0000     NEG W0, W0
006C9C  EA0000     NEG W0, W0
006C9E  DE004F     LSR W0, #15, W0
006CA0  801761     MOV LATF, W1
006CA2  A10001     BCLR W1, #0
006CA4  700081     IOR W0, W1, W1
006CA6  881761     MOV W1, LATF
302:               					LED2 = (LedBit & 0xF000)? 1:0;		break;
006CA8  2F0000     MOV #0xF000, W0
006CAA  B608A8     AND LedBit, WREG
006CAC  A7F000     BTSC W0, #15
006CAE  EA0000     NEG W0, W0
006CB0  EA0000     NEG W0, W0
006CB2  DE004F     LSR W0, #15, W0
006CB4  DD0047     SL W0, #7, W0
006CB6  8016E1     MOV LATD, W1
006CB8  A17001     BCLR W1, #7
006CBA  700081     IOR W0, W1, W1
006CBC  8816E1     MOV W1, LATD
006CBE  37002C     BRA 0x6D18
303:               		case 1:		LED1 = (LedStatus2 & LedBit)? 1:0;
006CC0  8044B0     MOV LedStatus2, W0
006CC2  B608A8     AND LedBit, WREG
006CC4  A7F000     BTSC W0, #15
006CC6  EA0000     NEG W0, W0
006CC8  EA0000     NEG W0, W0
006CCA  DE004F     LSR W0, #15, W0
006CCC  801761     MOV LATF, W1
006CCE  A10001     BCLR W1, #0
006CD0  700081     IOR W0, W1, W1
006CD2  881761     MOV W1, LATF
304:               					LED2 = (LedBit & 0x8000)? 1:0;		break;
006CD4  804540     MOV LedBit, W0
006CD6  DE004F     LSR W0, #15, W0
006CD8  DD0047     SL W0, #7, W0
006CDA  8016E1     MOV LATD, W1
006CDC  A17001     BCLR W1, #7
006CDE  700081     IOR W0, W1, W1
006CE0  8816E1     MOV W1, LATD
006CE2  37001A     BRA 0x6D18
305:               		case 2:		LED1 = (LedStatus3 & LedBit)? 1:0;
006CE4  8044C0     MOV LedStatus3, W0
006CE6  B608A8     AND LedBit, WREG
006CE8  A7F000     BTSC W0, #15
006CEA  EA0000     NEG W0, W0
006CEC  EA0000     NEG W0, W0
006CEE  DE004F     LSR W0, #15, W0
006CF0  801761     MOV LATF, W1
006CF2  A10001     BCLR W1, #0
006CF4  700081     IOR W0, W1, W1
006CF6  881761     MOV W1, LATF
306:               					LED2 = (LedBit & 0x8000)? 1:0;		break;
006CF8  804540     MOV LedBit, W0
006CFA  DE004F     LSR W0, #15, W0
006CFC  DD0047     SL W0, #7, W0
006CFE  8016E1     MOV LATD, W1
006D00  A17001     BCLR W1, #7
006D02  700081     IOR W0, W1, W1
006D04  8816E1     MOV W1, LATD
006D06  370008     BRA 0x6D18
307:               //		case 3:		LED1 = (LedStatus4 & LedBit)? 1:0;	break;
308:               		default:	LED1 = 0;
006D08  A902EC     BCLR LATF, #0
309:               					LED2 = (LedBit & 0x8000)? 1:0;		break;
006D0A  804540     MOV LedBit, W0
006D0C  DE004F     LSR W0, #15, W0
006D0E  DD0047     SL W0, #7, W0
006D10  8016E1     MOV LATD, W1
006D12  A17001     BCLR W1, #7
006D14  700081     IOR W0, W1, W1
006D16  8816E1     MOV W1, LATD
310:               		}
311:               /*		#ifdef LED1
312:               			LED1 = (LedStatus1 & LedBit)? 1:0;
313:               		#endif
314:               		#ifdef LED2
315:               			LED2 = (LedStatus2 & LedBit)? 1:0;
316:               		#endif
317:               		#ifdef LED3
318:               			LED3 = (LedStatus3 & LedBit)? 1:0;
319:               		#endif
320:               		#ifdef LED4
321:               			LED4 = (LedStatus4 & LedBit)? 1:0;
322:               		#endif
323:               
324:               		LedBit >>= 1;
325:               */		if (!(LedBit >>= 1))
006D18  D528A8     LSR LedBit
006D1A  E208A8     CP0 LedBit
006D1C  3A0006     BRA NZ, 0x6D2A
326:               		{
327:               			if (++oneLedCnt > 3)
006D1E  EC48B0     INC.B oneLedCnt, WREG
006D20  B7E8B0     MOV.B WREG, oneLedCnt
006D22  504FE3     SUB.B W0, #0x3, [W15]
006D24  360004     BRA LEU, 0x6D2E
328:               				oneLedCnt = 0;
006D26  EF68B0     CLR.B oneLedCnt
006D28  370002     BRA 0x6D2E
329:               		}
330:               		else
331:               			ledTimer = 62;						// 1000hz / 16bit = 62.5
006D2A  B3C3E0     MOV.B #0x3E, W0
006D2C  B7E8B1     MOV.B WREG, ledTimer
332:               	}
333:               //	else
334:               //		ledTimer--;
335:               }
006D2E  060000     RETURN
336:               
337:               // **********************************************************************
338:               // Timer2 INTERRUPT			50kHz
339:               // **********************************************************************
340:               void __attribute__ ((interrupt, no_auto_psv)) _T2Interrupt(void)
341:               {
342:               	_T2IF = 0;				//	Reset Timer2 interrupt flag
006D4E  A9E084     BCLR IFS0, #7
343:               }
006D50  064000     RETFIE
344:               
345:               // **********************************************************************
346:               extern	inline	void	SpiMemTimer	(void);
347:               extern	inline	void	UsbMsTimer	(void);
348:               //#if (HARDWARE == HW_SEE)
349:               // extern inline  void    SwitchTimer (void);
350:               //#endif
351:               // ......................................................................
352:               // Timer3 INTERRUPT			100Hz - 10ms
353:               // **********************************************************************
354:               void __attribute__ ((interrupt, no_auto_psv)) _T3Interrupt(void)
355:               {
006D52  F80036     PUSH RCOUNT
006D54  BE9F80     MOV.D W0, [W15++]
006D56  BE9F82     MOV.D W2, [W15++]
006D58  BE9F84     MOV.D W4, [W15++]
006D5A  BE9F86     MOV.D W6, [W15++]
356:               	_T3IF = 0;				//	Reset Timer3 interrupt flag
006D5C  A90085     BCLR 0x85, #0
357:               	GSM_IF	= 1;
006D5E  A80086     BSET IFS1, #0
358:               	SpiMemTimer();
006D60  07F98F     RCALL SpiMemTimer
359:               	#ifdef UART4_WIFI
360:               		WIFI_IF = 1;
006D62  A8208A     BSET IFS3, #1
361:               		#if	(TEST != WIFI_TEST)
362:               			if ((!WIFI_IE) && (WifiSec >= WIFI_WAKE_UP_S))
363:               				WIFI_IE = 1;
364:               		#endif
365:               	#endif
366:               
367:                   #if (HARDWARE == HW_SEE)
368:               		SwitchTimer();
369:               	#endif
370:               //	UsbMsTimer();
371:               }
006D64  BE034F     MOV.D [--W15], W6
006D66  BE024F     MOV.D [--W15], W4
006D68  BE014F     MOV.D [--W15], W2
006D6A  BE004F     MOV.D [--W15], W0
006D6C  F90036     POP RCOUNT
006D6E  064000     RETFIE
372:               
373:               void DelayMs(U16 ms)
374:               {
375:               	ms++;
006D70  8044F1     MOV Tics_ms, W1
006D72  E80081     INC W1, W1
376:               	ms += Tics_ms;
006D74  408000     ADD W1, W0, W0
377:               	while (Tics_ms != ms);
006D76  E3089E     CP Tics_ms
006D78  3AFFFE     BRA NZ, 0x6D76
378:               }
006D7A  060000     RETURN
379:               
380:               U16 GetTicsMs(void)
381:               {
382:               //	return ((U16)(Bcd_2Dec(TimeBcd.sec)) * mS);
383:               	return Tics_ms;
006D7C  8044F0     MOV Tics_ms, W0
384:               }
006D7E  060000     RETURN
385:               
386:               U16 GetTimeSinceMs(U16 previousTics)
387:               {
388:               	return (Tics_ms >= previousTics)?	(Tics_ms - previousTics):((0 - previousTics) + Tics_ms);
006D80  8044F1     MOV Tics_ms, W1
006D82  B5089E     SUB Tics_ms, WREG
389:               }
006D84  060000     RETURN
390:               
391:               U16 GetSec(void)
392:               {
393:               //	return (Bcd_2Dec(TimeBcd.min) * 60) + Bcd_2Dec(TimeBcd.sec);
394:               	return	Sec;
006D86  804550     MOV Sec, W0
395:               }
006D88  060000     RETURN
396:               
397:               U16 GetTimeSinceSec(U16 previousSec)
398:               {
399:               //	U16 currentSec = GetSec();
400:               //	return (currentSec > previousSec)?	(currentSec - previousSec):((0xFFFF - previousSec) + currentSec);
401:               	return (Sec >= previousSec)?			(Sec - previousSec):((0 - previousSec) + Sec);
006D8A  804551     MOV Sec, W1
006D8C  B508AA     SUB Sec, WREG
402:               }
006D8E  060000     RETURN
403:               
404:               // ggggggdd dddhhhhh MMMMmmmm mmssssss
405:               typedef union
406:               {
407:               	UNI32	dword;
408:               	struct
409:               	{
410:               		U16	sec		:6;
411:               		U16	min		:6;
412:               		U16	moon	:4;
413:               		U16	hour	:5;
414:               		U16	day		:5;
415:               		U16	year	:6;
416:               	};
417:               } TCP_TIME;
418:               
419:               void GetTcpTime	(U32* tcpTime)
420:               {
006D90  780300     MOV W0, W6
421:               	static TCP_TIME	TCPtime = {.dword.u32 = 0};
422:               	static U8		hour = 255;
423:               	if (hour != SysTime.hour)
006D92  BFC8A4     MOV.B 0x8A4, WREG
006D94  E3490C     CP.B 0x90C
006D96  320022     BRA Z, 0x6DDC
424:               	{
425:               		hour = SysTime.hour;
006D98  208A01     MOV #0x8A0, W1
006D9A  904041     MOV.B [W1+4], W0
006D9C  B7E90C     MOV.B WREG, 0x90C
426:               		TCPtime.year	= (SysTime.year > StartYear)? (SysTime.year - StartYear) : SysTime.year;
006D9E  780091     MOV [W1], W1
006DA0  804842     MOV 0x908, W2
006DA2  510F81     SUB W2, W1, [W15]
006DA4  310005     BRA C, 0x6DB0
006DA6  804503     MOV SysTime, W3
006DA8  804841     MOV 0x908, W1
006DAA  51C181     SUB.B W3, W1, W3
006DAC  B243F3     AND.B #0x3F, W3
006DAE  370002     BRA 0x6DB4
006DB0  804503     MOV SysTime, W3
006DB2  B243F3     AND.B #0x3F, W3
006DB4  DD19CA     SL W3, #10, W3
006DB6  203FF1     MOV #0x3FF, W1
006DB8  804570     MOV 0x8AE, W0
006DBA  608080     AND W1, W0, W1
006DBC  718181     IOR W3, W1, W3
006DBE  884573     MOV W3, 0x8AE
427:               		TCPtime.day		= SysTime.day;
006DC0  208A02     MOV #0x8A0, W2
006DC2  904232     MOV.B [W2+3], W4
006DC4  62027F     AND W4, #0x1F, W4
006DC6  DD2245     SL W4, #5, W4
006DC8  2FC1F1     MOV #0xFC1F, W1
006DCA  618081     AND W3, W1, W1
006DCC  720081     IOR W4, W1, W1
006DCE  884571     MOV W1, 0x8AE
428:               		TCPtime.hour	= SysTime.hour;
006DD0  904142     MOV.B [W2+4], W2
006DD2  61017F     AND W2, #0x1F, W2
006DD4  2FFE03     MOV #0xFFE0, W3
006DD6  608083     AND W1, W3, W1
006DD8  710081     IOR W2, W1, W1
006DDA  884571     MOV W1, 0x8AE
429:               	}
430:               	TCPtime.moon		= SysTime.month;
006DDC  208A01     MOV #0x8A0, W1
006DDE  9041A1     MOV.B [W1+2], W3
006DE0  DD19CC     SL W3, #12, W3
006DE2  20FFF4     MOV #0xFFF, W4
006DE4  804562     MOV TCPtime, W2
006DE6  620202     AND W4, W2, W4
006DE8  718204     IOR W3, W4, W4
006DEA  884564     MOV W4, TCPtime
431:               	TCPtime.min			= SysTime.min;
006DEC  9042D1     MOV.B [W1+5], W5
006DEE  2003F3     MOV #0x3F, W3
006DF0  618285     AND W3, W5, W5
006DF2  DD2AC6     SL W5, #6, W5
006DF4  2F03F2     MOV #0xF03F, W2
006DF6  620102     AND W4, W2, W2
006DF8  728102     IOR W5, W2, W2
006DFA  884562     MOV W2, TCPtime
432:               	TCPtime.sec			= SysTime.sec;
006DFC  9040E1     MOV.B [W1+6], W1
006DFE  618181     AND W3, W1, W3
006E00  2FFC01     MOV #0xFFC0, W1
006E02  610101     AND W2, W1, W2
006E04  718102     IOR W3, W2, W2
006E06  884562     MOV W2, TCPtime
433:               
434:               	*tcpTime = TCPtime.dword.u32;
006E08  804560     MOV TCPtime, W0
006E0A  804571     MOV 0x8AE, W1
006E0C  BE8B00     MOV.D W0, [W6]
435:               }
006E0E  060000     RETURN
436:               
437:               void SetTcpTime	(U32* tcpTime)
438:               {
439:               	register TCP_TIME* t_Time = (TCP_TIME*)tcpTime;
440:               	if (SysTime.day	!= t_Time->day)
006E10  900090     MOV [W0+2], W1
006E12  DE08C5     LSR W1, #5, W1
006E14  60C0FF     AND.B W1, #0x1F, W1
006E16  208A32     MOV #0x8A3, W2
006E18  784112     MOV.B [W2], W2
006E1A  514F81     SUB.B W2, W1, [W15]
006E1C  320016     BRA Z, 0x6E4A
441:               	{
442:               		SysTime.sec		= t_Time->sec;
006E1E  B3C3F1     MOV.B #0x3F, W1
006E20  60C110     AND.B W1, [W0], W2
006E22  208A01     MOV #0x8A0, W1
006E24  9840E2     MOV.B W2, [W1+6]
443:               		SysTime.min		= t_Time->min;
006E26  780110     MOV [W0], W2
006E28  DE1146     LSR W2, #6, W2
006E2A  B243F2     AND.B #0x3F, W2
006E2C  9840D2     MOV.B W2, [W1+5]
444:               		SysTime.month	= t_Time->moon;
006E2E  780110     MOV [W0], W2
006E30  DE114C     LSR W2, #12, W2
006E32  9840A2     MOV.B W2, [W1+2]
445:               		SysTime.hour	= t_Time->hour;
006E34  900110     MOV [W0+2], W2
006E36  61417F     AND.B W2, #0x1F, W2
006E38  9840C2     MOV.B W2, [W1+4]
446:               		SysTime.day		= t_Time->day;
006E3A  900110     MOV [W0+2], W2
006E3C  DE1145     LSR W2, #5, W2
006E3E  61417F     AND.B W2, #0x1F, W2
006E40  9840B2     MOV.B W2, [W1+3]
447:               		SysTime.year	= t_Time->year + StartYear;
006E42  804842     MOV 0x908, W2
006E44  900010     MOV [W0+2], W0
006E46  DE004A     LSR W0, #10, W0
006E48  400882     ADD W0, W2, [W1]
448:               	}
449:               }
006E4A  060000     RETURN
450:               
451:               // **********************************************************************
452:               // ......................................................................
453:               // IC3 INTERRUPT			GSM PWM Input Compare
454:               // **********************************************************************
455:               void __attribute__((interrupt, no_auto_psv)) _IC3Interrupt( void )
456:               {
457:               /*	if(!GSM_ANALOG_IN)
458:               		IC3CON2bits.TRIGSTAT	= 1;	// Release	IC3 Timer by manual Trigger
459:               	else
460:               	{
461:               		while (IC3CON1bits.ICBNE)		// Buffer Empty Status bit
462:               			IC3val[0] = IC3BUF;
463:               		IC3CON2bits.TRIGSTAT	= 0;	// Stop		IC3 Timer by manual Trigger
464:               	}
465:               */
466:               	_IC3IF	= 0;			//	Clear	IC3 interrupt flag
006E4C  A9A088     BCLR IFS2, #5
467:               //	FLAG_IC3 = 1;
468:               }
006E4E  064000     RETFIE
469:               
470:               
471:               /*
472:               inline void LedAndButtons(void)
473:               {
474:                   U8 i = (U8)(SystemTime.ms & 0x3F);
475:                   if (!i)
476:                   {
477:                       Button1Check();
478:                       LedStatusUpdate();
479:                   }
480:                   else if (i == 0x3F)
481:                   {
482:                       LED_OFF();
483:                       if (SistemState == pps_system)
484:                           Button2Check();
485:                   }
486:               }
487:               
488:               
489:               inline void Button1Check(void)
490:               {
491:               	static	U8	button1Last, but1Time = 0;
492:                   U8 but1 = BUTTON1;
493:               	if (button1Last != but1)
494:               	{
495:               		button1Last = but1;
496:                       but1Time = 1;
497:               	}
498:                   else if (but1Time)
499:                   {
500:                       if (but1)
501:                       {
502:                           Button_1 = but1Time;
503:                           but1Time++;
504:                       }
505:                       else
506:                       {
507:                           but1Time = 0;
508:                           Button_1 = but1;
509:                       }
510:                   }
511:               }
512:               
513:               inline void Button2Check(void)
514:               {
515:               	static	U8	button2Last, but2Time = 0;
516:                   U8 but2 = !BUTTON2;
517:               
518:                   if (button2Last != but2)
519:                   {
520:                       button2Last = but2;
521:                       but2Time = 1;
522:                   }
523:                   else if (but2Time)
524:                   {
525:                       if (but2)
526:                       {
527:                           Button_2 = but2Time;
528:                           but2Time++;
529:                       }
530:                       else
531:                       {
532:                           but2Time = 0;
533:                           Button_2 = but2;
534:                       }
535:                   }
536:               }
537:               
538:               void GetTimeAscii(char* time)
539:               {
540:               	if (SystemTime.hours > 9)
541:               		*time++ = (SystemTime.hours / 10) + '0';
542:               	else
543:               		*time++ = SPACE;
544:               	*time++ = (SystemTime.hours % 10) + '0';
545:               	*time++ = ':';
546:               	*time++ = (SystemTime.minutes / 10) + '0';
547:               	*time++ = (SystemTime.minutes % 10) + '0';
548:               	*time++ = ':';
549:               	*time++ = (SystemTime.seconds / 10) + '0';
550:               	*time++ = (SystemTime.seconds % 10) + '0';
551:               }
552:               
553:               void GetDateAscii(char* date)
554:               {
555:               	if (SystemTime.day > 9)
556:               		*date++ = (SystemTime.day / 10) + '0';
557:               	else
558:               		*date++ = SPACE;
559:               	*date++ = (SystemTime.day % 10) + '0';
560:               	*date++ = '.';
561:               	*date++ = (SystemTime.mon / 10) + '0';
562:               	*date++ = (SystemTime.mon % 10) + '0';
563:               	*date++ = '.';
564:               	*date++ = '2';
565:               	*date++ = '0';
566:               	*date++ = (SystemTime.year / 10) + '0';
567:               	*date++ = (SystemTime.year % 10) + '0';
568:               	*date++ = '\0';
569:               }
570:               */
---  /home/pele/src/Auto_02/src/Tcp.c  ------------------------------------------------------------------
1:                 #include	"Tcp.h"
2:                 #include	"Gsm.h"
3:                 #include	"Wifi.h"
4:                 #include	"Ports.h"
5:                 #include	"Memory.h"
6:                 #include	"Timers.h"
7:                 #include	<string.h>
8:                 #include	<stdio.h>
9:                 
10:                #define	OUT_PACKET_COUNT	8
11:                #define	MEMORY_EMPTY_CHAR	0xFF	// for tests - change to 0xFF in future
12:                //#define	DEVICE_ID			1	// TODO Make changable and save to memory
13:                #define	FL_INIT				TcpFlags.flag_0
14:                #define	FL_WIFI_GPRS		TcpFlags.flag_1
15:                #define	FL_ONLINE_MAX_SEC	2
16:                
17:                		U16				OnlineTimer		= 0, OnlineTimeoutSec	= FL_ONLINE_MAX_SEC;
18:                static	U16				MemSendSize		= 0;
19:                static	TCP_PACKET		OutPackets[OUT_PACKET_COUNT];
20:                //static TCP_PACKET*	OutPacket;
21:                static	U8				OutPacketIdx	= 0;
22:                //static U16			PacketNbr		= 0;
23:                //static UNI32			Address			= {.u32 = 0};
24:                static	FLAGS			TcpFlags		= {.word = 0};
25:                //static UNI16			DeviceId		= {.u16 = DataFromFlash.DeviceId};
26:                //static U16			MaxPackets		= 0x1000;				// Temporary
27:                static	U16				MemDataSent 	= 0;
28:                static	U16				ResendPacket	= 0;
29:                
30:                static enum State
31:                {
32:                	State_Idle = 0,
33:                	State_BootFlash,
34:                	State_MemStatus,
35:                	State_MemBootAddr,
36:                	State_MemWrite,
37:                	State_MemRead,
38:                
39:                	State_Uncnown
40:                } TcpBootState = State_Idle;
41:                
42:                U8			Tcp_GetPacketBuffer		(void);
43:                TCP_PACKET* Tcp_GetOutPacketBuffer	(void);
44:                //U8			Tcp_AvailableOutBuff	(void);
45:                
46:                void Tcp_Init	(void)
47:                {
48:                	register UNI32 wAddr;
49:                	wAddr.u32 = Mem_GetWriteAddress();
005AFE  0703ED     RCALL Mem_GetWriteAddress
50:                
51:                	if (wAddr.u8ll)
005B00  E00400     CP0.B W0
005B02  320005     BRA Z, 0x5B0E
52:                	{
53:                		wAddr.u8ll = 0;
005B04  2FF002     MOV #0xFF00, W2
005B06  610000     AND W2, W0, W0
54:                		wAddr.u32 += 0x100;
005B08  B01000     ADD #0x100, W0
005B0A  B08001     ADDC #0x0, W1
55:                		Mem_SetWriteAddress(wAddr.u32);
005B0C  0703A2     RCALL Mem_SetWriteAddress
56:                	}
57:                //	Mem_SetWriteAddress(0);
58:                	memset((char*)&OutPackets, 0, sizeof(OutPackets));
005B0E  2178C0     MOV #0x178C, W0
005B10  0903FF     REPEAT #0x3FF
005B12  EB1800     CLR [W0++]
59:                	FL_INIT = 1;
005B14  A808EA     BSET TcpFlags, #0
60:                }
005B16  060000     RETURN
61:                
62:                U8 Tcp_GetPacketBuffer	(void)
63:                {
005B1A  200091     MOV #0x9, W1
64:                	register U16 i;
65:                	for (i = 0; i <= OUT_PACKET_COUNT; i++)
005B18  BFC8F6     MOV.B OutPacketIdx, WREG
005B38  3AFFF3     BRA NZ, 0x5B20
005B3A  B7E8F6     MOV.B WREG, OutPacketIdx
66:                	{
67:                		if (++OutPacketIdx >= OUT_PACKET_COUNT)
005B20  E84000     INC.B W0, W0
005B22  504FE7     SUB.B W0, #0x7, [W15]
005B24  360001     BRA LEU, 0x5B28
68:                			OutPacketIdx = 0;
005B1C  EB4280     CLR.B W5
005B26  784005     MOV.B W5, W0
69:                		if (!OutPackets[OutPacketIdx].start)
005B1E  2178C4     MOV #0x178C, W4
005B28  FB8100     ZE W0, W2
005B2A  DD11C8     SL W2, #8, W3
005B2C  79C1E4     MOV.B [W4+W3], W3
005B2E  E00403     CP0.B W3
005B30  3A0002     BRA NZ, 0x5B36
005B32  B7E8F6     MOV.B WREG, OutPacketIdx
005B34  370003     BRA 0x5B3C
005B36  E90081     DEC W1, W1
70:                			break;
71:                	}
72:                //	TCP_PACKET* packet = &OutPackets[OutPacketIdx];	// point to next packet buffer
73:                	memset(OutPackets[OutPacketIdx].bytes, 0xFF, TCP_PACKET_LEN);
005B3C  DD1148     SL W2, #8, W2
005B3E  2178C1     MOV #0x178C, W1
005B40  2FFFF4     MOV #0xFFFF, W4
005B42  408182     ADD W1, W2, W3
005B44  09007F     REPEAT #0x7F
005B46  781984     MOV W4, [W3++]
74:                	return OutPacketIdx;
75:                }
005B48  060000     RETURN
76:                
77:                TCP_PACKET* Tcp_GetOutPacketBuffer	(void)
78:                {
005B4E  200090     MOV #0x9, W0
79:                	register U16 i;
80:                	for (i = 0; i <= OUT_PACKET_COUNT; i++)
005B4A  208F61     MOV #0x8F6, W1
005B4C  784091     MOV.B [W1], W1
005B6E  3AFFF2     BRA NZ, 0x5B54
005B70  208F64     MOV #0x8F6, W4
005B72  784A01     MOV.B W1, [W4]
81:                	{
82:                		if (++OutPacketIdx >= OUT_PACKET_COUNT)
005B54  E84081     INC.B W1, W1
005B56  50CFE7     SUB.B W1, #0x7, [W15]
005B58  360001     BRA LEU, 0x5B5C
83:                			OutPacketIdx = 0;
005B50  EB4280     CLR.B W5
005B5A  784085     MOV.B W5, W1
84:                		if (!OutPackets[OutPacketIdx].start)
005B52  2178C4     MOV #0x178C, W4
005B5C  FB8101     ZE W1, W2
005B5E  DD11C8     SL W2, #8, W3
005B60  79C1E4     MOV.B [W4+W3], W3
005B62  E00403     CP0.B W3
005B64  3A0003     BRA NZ, 0x5B6C
005B66  208F60     MOV #0x8F6, W0
005B68  784801     MOV.B W1, [W0]
005B6A  370004     BRA 0x5B74
005B6C  E90000     DEC W0, W0
85:                			break;
86:                	}
87:                	memset(OutPackets[OutPacketIdx].bytes, 0xFF, TCP_PACKET_LEN);
005B74  DD1148     SL W2, #8, W2
005B76  2178C0     MOV #0x178C, W0
005B78  2FFFF4     MOV #0xFFFF, W4
005B7A  400182     ADD W0, W2, W3
005B7C  09007F     REPEAT #0x7F
005B7E  781984     MOV W4, [W3++]
88:                	return &OutPackets[OutPacketIdx];
005B80  DD08C8     SL W1, #8, W1
005B82  408000     ADD W1, W0, W0
89:                }
005B84  060000     RETURN
90:                
91:                U8	Tcp_AvailableOutBuff	(void)
005B88  21F8C2     MOV #0x1F8C, W2
92:                {
93:                	register U8 i, ret = 0;
005B86  2178C1     MOV #0x178C, W1
005B8A  EB4000     CLR.B W0
94:                	for (i = 0; i < OUT_PACKET_COUNT; i++)
005B94  508F82     SUB W1, W2, [W15]
005B96  3AFFFA     BRA NZ, 0x5B8C
95:                	{
96:                		if (!OutPackets[i].start)
005B8C  E00411     CP0.B [W1]
005B8E  3A0001     BRA NZ, 0x5B92
97:                			ret++;
005B90  E84000     INC.B W0, W0
005B92  B01001     ADD #0x100, W1
98:                	}
99:                	return ret;
100:               }
005B98  060000     RETURN
101:               
102:               // return index of packets buffers
103:               U8	Tcp_StartMemPacket (U8 type)
005BDE  E8848A     INC2 W10, W9
005BE0  44848B     ADD W9, W11, W9
104:               {
005B9A  BE9F88     MOV.D W8, [W15++]
005B9C  BE9F8A     MOV.D W10, [W15++]
005B9E  BE9F8C     MOV.D W12, [W15++]
005BA0  784680     MOV.B W0, W13
105:               	if (!FL_INIT)
005BA2  AB08EA     BTST TcpFlags, #0
005BA4  3A0001     BRA NZ, 0x5BA8
106:               		Tcp_Init();
005BA6  07FFAB     RCALL Tcp_Init
107:               	UNI32 addr = {.u32 = Mem_GetWriteAddress()};
005BA8  070398     RCALL Mem_GetWriteAddress
005BAA  BE0400     MOV.D W0, W8
108:               	register U16 i;
109:               
110:               	if (addr.u8ll)
005BAC  E00400     CP0.B W0
005BAE  320004     BRA Z, 0x5BB8
111:               	{
112:               /*		while (addr.u8ll)
113:               		{
114:               			Mem_WriteByte_1(0xFF);			// 
115:               			addr.u8ll++;
116:               		}
117:               */
118:               		addr.u8ll = 0;
005BB0  2FF000     MOV #0xFF00, W0
005BB2  600408     AND W0, W8, W8
119:               		addr.u32 += 0x100;
005BB4  B01008     ADD #0x100, W8
005BB6  B08009     ADDC #0x0, W9
120:               //		Mem_SetWriteAddress(addr.u32);
121:               //		addr.u32 = Mem_GetWriteAddress();
122:               	}
123:               /*
124:               	for (i = 0; i <= OUT_PACKET_COUNT; i++)
125:               	{
126:               		if (++OutPacketIdx >= OUT_PACKET_COUNT)
127:               			OutPacketIdx = 0;
128:               		if (!OutPackets[OutPacketIdx].start)
129:               			break;
130:               	}
131:               //	register TCP_PACKET* packet = &OutPackets[OutPacketIdx];	// point to next packet buffer
132:               	register TCP_PACKET* packet = OutPackets[OutPacketIdx];	// point to next packet buffer
133:               	memset(packet->bytes, 0xFF, TCP_DATA_LEN);
134:               */
135:               	register U8 idx = Tcp_GetPacketBuffer();
005BB8  07FFAF     RCALL Tcp_GetPacketBuffer
005BBA  784600     MOV.B W0, W12
136:               	register TCP_PACKET* packet = &OutPackets[idx];	// point to next packet buffer
137:               
138:               //	packet->start	= STX;
139:               	packet->len		= 0;
005BBC  2178CB     MOV #0x178C, W11
005BBE  DD6548     SL W12, #8, W10
005BC0  45800A     ADD W11, W10, W0
005BC2  EB4080     CLR.B W1
005BC4  984011     MOV.B W1, [W0+1]
140:               //	packet->crc		= 0;
141:               	packet->type	= type;
005BC6  E8808B     INC2 W11, W1
005BC8  40808A     ADD W1, W10, W1
005BCA  98409D     MOV.B W13, [W1+1]
142:               	packet->id		= DataFromFlash.DeviceId;
005BCC  81B971     MOV _Gsm_AtCommand, W1
005BCE  980021     MOV W1, [W0+4]
143:               //	packet->nr		= PacketNbr;
144:               	packet->bytes[6]	= addr.u8lh;		// aa nn NN aa	Packet number = address >> 8
005BD0  DE40C8     LSR W8, #8, W1
005BD2  458066     ADD W11, #0x6, W0
005BD4  7D7001     MOV.B W1, [W0+W10]
145:               	packet->bytes[7]	= addr.u8hl;		// aa NN nn aa	(little endian)
005BD6  E80000     INC W0, W0
005BD8  7D7009     MOV.B W9, [W0+W10]
146:               											// tcp-> STX Len CRC Type ID_ID AD_AD
147:               	Mem_WriteByte_1(STX);					//        |   '   ' /   /  /  /  /
005BDA  B3C020     MOV.B #0x2, W0
005BDC  070398     RCALL Mem_WriteByte_1
148:               	for (i = 3; i < TCP_PACKET_HEDER; i++)	//        |      /    /  /  /  /
005BE2  200038     MOV #0x3, W8
005BE8  E80408     INC W8, W8
005BEA  540FE8     SUB W8, #0x8, [W15]
005BEC  3AFFFB     BRA NZ, 0x5BE4
149:               		Mem_WriteByte_1(packet->bytes[i]);	// mem-> STX Type  ID_ID  AD_AD
005BE4  784059     MOV.B [++W9], W0
005BE6  070393     RCALL Mem_WriteByte_1
150:               
151:               //	return OutPacketIdx;
152:               	return idx;
153:               }
005BEE  78400C     MOV.B W12, W0
005BF0  BE064F     MOV.D [--W15], W12
005BF2  BE054F     MOV.D [--W15], W10
005BF4  BE044F     MOV.D [--W15], W8
005BF6  060000     RETURN
154:               
155:               // Return remain size of packet
156:               U8 Tcp_WriteMemPacket(U8 nr, U8* data, U8 len)
005C1C  DD6DC8     SL W13, #8, W11
005C1E  45058B     ADD W10, W11, W11
005C20  217930     MOV #0x1793, W0
005C22  458580     ADD W11, W0, W11
005C24  780409     MOV W9, W8
005C32  78050C     MOV W12, W10
157:               {
005BF8  BE9F88     MOV.D W8, [W15++]
005BFA  BE9F8A     MOV.D W10, [W15++]
005BFC  BE9F8C     MOV.D W12, [W15++]
158:               	register TCP_PACKET* packet = &OutPackets[nr];	// necessary packet buffer
005BFE  FB8680     ZE W0, W13
159:               	register U16	start	= packet->len;			// from previous point
005C00  DD6848     SL W13, #8, W0
005C02  2178C3     MOV #0x178C, W3
005C04  418000     ADD W3, W0, W0
005C06  904510     MOV.B [W0+1], W10
005C08  FB850A     ZE W10, W10
160:               	register U16	end		= start + len;			// till required
005C0A  FB8602     ZE W2, W12
005C0C  46060A     ADD W12, W10, W12
005C0E  200F80     MOV #0xF8, W0
005C10  560F80     SUB W12, W0, [W15]
005C12  360001     BRA LEU, 0x5C16
005C14  780600     MOV W0, W12
161:               	if (end > TCP_DATA_LEN)							// but not exceeding packet max data size
162:               		end = TCP_DATA_LEN;
163:               
164:               //	Mem_SetWriteAddress(addr);
165:               //	for (; start < end; start++)
166:               	while (start < end)
005C16  550F8C     SUB W10, W12, [W15]
005C18  31000D     BRA C, 0x5C34
005C1A  780481     MOV W1, W9
005C2E  550F8C     SUB W10, W12, [W15]
005C30  39FFF9     BRA NC, 0x5C24
167:               	{
168:               		Mem_WriteByte_1(*data);						// copy to memory
005C26  784039     MOV.B [W9++], W0
005C28  070372     RCALL Mem_WriteByte_1
169:               		packet->data[start++] = *data++;			// copy to packet buffer
005C2A  786D98     MOV.B [W8], [++W11]
005C2C  E8050A     INC W10, W10
170:               	}
171:               	packet->len = start;							// save reached size
005C34  DD6EC8     SL W13, #8, W13
005C36  2178C0     MOV #0x178C, W0
005C38  40000D     ADD W0, W13, W0
005C3A  98401A     MOV.B W10, [W0+1]
172:               	return (TCP_DATA_LEN - start);
005C3C  B3CF80     MOV.B #0xF8, W0
005C3E  50400A     SUB.B W0, W10, W0
173:               }
005C40  BE064F     MOV.D [--W15], W12
005C42  BE054F     MOV.D [--W15], W10
005C44  BE044F     MOV.D [--W15], W8
005C46  060000     RETURN
174:               
175:               void Tcp_SendPacket(U8 nr)
005C60  DD60C8     SL W12, #8, W1
005C62  2178E0     MOV #0x178E, W0
005C64  408080     ADD W1, W0, W1
176:               {
005C48  BE9F88     MOV.D W8, [W15++]
005C4A  BE9F8A     MOV.D W10, [W15++]
005C4C  781F8C     MOV W12, [W15++]
177:               	register TCP_PACKET* packet = &OutPackets[nr];	// necessary packet buffer
005C4E  FB8600     ZE W0, W12
178:               	register U8		crc = 0;
005C68  EB4480     CLR.B W9
005CB8  EB4480     CLR.B W9
179:               	register U16	i, end	= (U16)packet->len + TCP_PACKET_HEDER;
005C50  DD6048     SL W12, #8, W0
005C52  2178C1     MOV #0x178C, W1
005C54  408000     ADD W1, W0, W0
005C56  904510     MOV.B [W0+1], W10
005C58  FB850A     ZE W10, W10
005C5A  450568     ADD W10, #0x8, W10
180:               	for (i = 3; i < end; i++)						// from packet type till end of data
005C5C  550FE3     SUB W10, #0x3, [W15]
005C5E  360025     BRA LEU, 0x5CAA
005C66  200030     MOV #0x3, W0
005C6C  E80000     INC W0, W0
005C6E  550F80     SUB W10, W0, [W15]
005C70  3EFFFC     BRA GTU, 0x5C6A
005CBA  20003A     MOV #0x3, W10
005CBC  37FFE3     BRA 0x5C84
181:               		crc ^= packet->bytes[i];
005C6A  6CC4D1     XOR.B W9, [++W1], W9
182:               //	packet->len		= end;							//		LEN_CHANGES
183:               	packet->crc		= crc;
005C72  DD6048     SL W12, #8, W0
005C74  2178E1     MOV #0x178E, W1
005C76  787089     MOV.B W9, [W1+W0]
005CAA  DD6048     SL W12, #8, W0
005CAC  2178E1     MOV #0x178E, W1
005CAE  408080     ADD W1, W0, W1
005CB0  EB4880     CLR.B [W1]
184:               	packet->start	= STX;
005C78  B3C022     MOV.B #0x2, W2
005C7A  E98081     DEC2 W1, W1
005C7C  787082     MOV.B W2, [W1+W0]
005CB2  B3C022     MOV.B #0x2, W2
005CB4  2178C1     MOV #0x178C, W1
005CB6  787082     MOV.B W2, [W1+W0]
185:               
186:               	for (; i < TCP_PACKET_LEN; i++)
005C7E  200FF0     MOV #0xFF, W0
005C80  550F80     SUB W10, W0, [W15]
005C82  3E0007     BRA GTU, 0x5C92
005C86  200FF8     MOV #0xFF, W8
005C8C  E8050A     INC W10, W10
005C8E  550F88     SUB W10, W8, [W15]
005C90  36FFFB     BRA LEU, 0x5C88
187:               		Mem_WriteByte_1(MEMORY_EMPTY_CHAR);			// 
005C84  EBC580     SETM.B W11
005C88  78400B     MOV.B W11, W0
005C8A  070341     RCALL Mem_WriteByte_1
188:               	Mem_WriteByte_1(packet->len);					// write in memory saved packet len
005C92  DD6648     SL W12, #8, W12
005C94  2178C0     MOV #0x178C, W0
005C96  40000C     ADD W0, W12, W0
005C98  904010     MOV.B [W0+1], W0
005C9A  070339     RCALL Mem_WriteByte_1
189:               	Mem_WriteByte_1(crc);							// & calculated crc
005C9C  784009     MOV.B W9, W0
005C9E  070337     RCALL Mem_WriteByte_1
190:               
191:               	FL_TCP_READY = 1;
005CA0  A8892C     BSET SysFlags, #4
192:               }
005CA2  78064F     MOV [--W15], W12
005CA4  BE054F     MOV.D [--W15], W10
005CA6  BE044F     MOV.D [--W15], W8
005CA8  060000     RETURN
005CAA  DD6048     SL W12, #8, W0
005CAC  2178E1     MOV #0x178E, W1
005CAE  408080     ADD W1, W0, W1
005CB0  EB4880     CLR.B [W1]
005CB2  B3C022     MOV.B #0x2, W2
005CB4  2178C1     MOV #0x178C, W1
005CB6  787082     MOV.B W2, [W1+W0]
005CB8  EB4480     CLR.B W9
005CBA  20003A     MOV #0x3, W10
005CBC  37FFE3     BRA 0x5C84
193:               
194:               // Feel packet heder:
195:               // STX
196:               // len	(for known types of packet)
197:               // crc	(calculate)
198:               // type	(if type parameter == 0 -> no owerwrite existing)
199:               // ID
200:               void Tcp_PreparePacket	(TCP_PACKET* pack, U8 type)
005CF8  E88080     INC2 W0, W1
005CFA  FB8182     ZE W2, W3
005CFC  4181E7     ADD W3, #0x7, W3
005CFE  400183     ADD W0, W3, W3
201:               {
202:               	pack->id = DataFromFlash.DeviceId;	// id
005CBE  81B972     MOV _Gsm_AtCommand, W2
005CC0  980022     MOV W2, [W0+4]
203:               	if (type)
005CC2  E00401     CP0.B W1
005CC4  320001     BRA Z, 0x5CC8
204:               		pack->type	= type;				// type
005CC6  984031     MOV.B W1, [W0+3]
205:               
206:               	switch (pack->type)					//
005CC8  9040B0     MOV.B [W0+3], W1
005CCA  40CFF0     ADD.B W1, #0x10, [W15]
005CCC  320003     BRA Z, 0x5CD4
005CCE  40CFEF     ADD.B W1, #0xF, [W15]
005CD0  3A0007     BRA NZ, 0x5CE0
005CD2  370003     BRA 0x5CDA
207:               	{
208:               	case TYPE_OK_GPRS:		pack->len = 0;				break;	//		LEN_CHANGES
005CD4  EB4080     CLR.B W1
005CD6  984011     MOV.B W1, [W0+1]
005CD8  370008     BRA 0x5CEA
209:               	case TYPE_OK_WIFI:		pack->len = 0;				break;	//		LEN_CHANGES
005CDA  EB4080     CLR.B W1
005CDC  984011     MOV.B W1, [W0+1]
005CDE  370005     BRA 0x5CEA
210:               	default:			if (pack->len > TCP_DATA_LEN)			//		LEN_CHANGES
005CE0  904090     MOV.B [W0+1], W1
005CE2  40CFE8     ADD.B W1, #0x8, [W15]
005CE4  360002     BRA LEU, 0x5CEA
211:               							pack->len = TCP_DATA_LEN;	break;	// 		LEN_CHANGES
005CE6  B3CF81     MOV.B #0xF8, W1
005CE8  984011     MOV.B W1, [W0+1]
212:               	}
213:               	pack->crc = 0;						// crc
005CEA  EB4080     CLR.B W1
005CEC  984021     MOV.B W1, [W0+2]
214:               	register U16 i, end	= (TCP_PACKET_HEDER + pack->len);		//		LEN_CHANGES
005CEE  904110     MOV.B [W0+1], W2
005CF0  FB8082     ZE W2, W1
005CF2  4080E8     ADD W1, #0x8, W1
215:               	for (i = 3; i < end; i++)									//		LEN_CHANGES
005CF4  508FE3     SUB W1, #0x3, [W15]
005CF6  360009     BRA LEU, 0x5D0A
005D06  508F83     SUB W1, W3, [W15]
005D08  3AFFFB     BRA NZ, 0x5D00
216:               		pack->crc ^= pack->bytes[i];	// calculate crc
005D00  904120     MOV.B [W0+2], W2
005D02  694151     XOR.B W2, [++W1], W2
005D04  984022     MOV.B W2, [W0+2]
217:               	// STX must be writed as last one,
218:               	// because if packet in OutPackets buffer - now it's VISIBLE TO SEND
219:               	pack->start = STX;					// start
005D0A  B3C021     MOV.B #0x2, W1
005D0C  784801     MOV.B W1, [W0]
220:               }
005D0E  060000     RETURN
221:               
222:               TCP_PACKET* Tcp_GetUnsent	(void)
223:               {
224:               	register TCP_PACKET* pack = 0;
005D10  2178C1     MOV #0x178C, W1
005D14  EB0000     CLR W0
225:               	register U16 i;
226:               	for (i = 0; i < OUT_PACKET_COUNT; i++)
005D12  EB0100     CLR W2
005D34  E80102     INC W2, W2
005D36  B01001     ADD #0x100, W1
005D38  510FE8     SUB W2, #0x8, [W15]
005D3A  3AFFEE     BRA NZ, 0x5D18
227:               	{
228:               		if (OutPackets[i].start == STX)
005D18  B3C024     MOV.B #0x2, W4
005D1A  124F91     SUBR.B W4, [W1], [W15]
005D1C  3A000B     BRA NZ, 0x5D34
229:               		{
230:               			if (!pack)
005D1E  E00000     CP0 W0
005D20  3A0003     BRA NZ, 0x5D28
231:               				pack = &OutPackets[i];
005D22  DD1048     SL W2, #8, W0
005D24  400005     ADD W0, W5, W0
005D26  370006     BRA 0x5D34
232:               			else if (OutPackets[i].nr < pack->nr)
005D28  900231     MOV [W1+6], W4
005D2A  9001B0     MOV [W0+6], W3
005D2C  520F83     SUB W4, W3, [W15]
005D2E  310002     BRA C, 0x5D34
233:               				pack = &OutPackets[i];
005D16  780281     MOV W1, W5
005D30  DD1048     SL W2, #8, W0
005D32  400005     ADD W0, W5, W0
234:               		}
235:               	}
236:               	return pack;
237:               }
005D3C  060000     RETURN
238:               
239:               inline void Tcp_PacketReceived	(TCP_PACKET* PacketRec)
240:               {
005D3E  BE9F88     MOV.D W8, [W15++]
005D40  780400     MOV W0, W8
241:               	register TCP_PACKET* outPack = NULL;
242:               
243:               	switch (PacketRec->type)
005D42  904038     MOV.B [W8+3], W0
005D44  404FFD     ADD.B W0, #0x1D, [W15]
005D46  320051     BRA Z, 0x5DEA
005D48  3E000E     BRA GTU, 0x5D66
005D4A  B3C211     MOV.B #0x21, W1
005D4C  504F81     SUB.B W0, W1, [W15]
005D4E  320031     BRA Z, 0x5DB2
005D50  3E0005     BRA GTU, 0x5D5C
005D52  504FE1     SUB.B W0, #0x1, [W15]
005D54  32001A     BRA Z, 0x5D8A
005D56  504FEF     SUB.B W0, #0xF, [W15]
005D58  3A0076     BRA NZ, 0x5E46
005D5A  370025     BRA 0x5DA6
005D5C  404FFF     ADD.B W0, #0x1F, [W15]
005D5E  32003B     BRA Z, 0x5DD6
005D60  404FFE     ADD.B W0, #0x1E, [W15]
005D62  3A0071     BRA NZ, 0x5E46
005D64  37003E     BRA 0x5DE2
005D66  404FF8     ADD.B W0, #0x18, [W15]
005D68  320056     BRA Z, 0x5E16
005D6A  3E0005     BRA GTU, 0x5D76
005D6C  404FFA     ADD.B W0, #0x1A, [W15]
005D6E  320041     BRA Z, 0x5DF2
005D70  404FF9     ADD.B W0, #0x19, [W15]
005D72  3A0069     BRA NZ, 0x5E46
005D74  370005     BRA 0x5D80
005D76  404FF3     ADD.B W0, #0x13, [W15]
005D78  320062     BRA Z, 0x5E3E
005D7A  404FE3     ADD.B W0, #0x3, [W15]
005D7C  3A0064     BRA NZ, 0x5E46
005D7E  370062     BRA 0x5E44
244:               	{
245:               	case TYPE_GPS_DATA:		{
246:               		if (!FL_TCP_RESEND)
005D8A  AB492D     BTST 0x92D, #2
005D8C  3A0007     BRA NZ, 0x5D9C
247:               		{
248:               			if (ResendPacket != PacketRec->nr)
005D8E  900038     MOV [W8+6], W0
005D90  E308EC     CP ResendPacket
005D92  320003     BRA Z, 0x5D9A
249:               			{
250:               				ResendPacket = PacketRec->nr;
005D94  884760     MOV W0, ResendPacket
251:               				FL_TCP_RESEND = 1;
005D96  A8492D     BSET 0x92D, #2
005D98  370001     BRA 0x5D9C
252:               			}
253:               			else
254:               				ResendPacket = 0;
005D9A  EF28EC     CLR ResendPacket
255:               		}
256:               		if (!SysTime.year)
005D9C  E208A0     CP0 SysTime
005D9E  3A0053     BRA NZ, 0x5E46
257:               			SetTcpTime((U32*)&PacketRec->data[0]);
005DA0  440068     ADD W8, #0x8, W0
005DA2  070836     RCALL SetTcpTime
005DA4  370050     BRA 0x5E46
258:               		break;				}
259:               	case TYPE_CURRENT_DATA:	{
260:               		OnlineTimeoutSec	= FL_ONLINE_MAX_SEC;
005DA6  200020     MOV #0x2, W0
005DA8  884970     MOV W0, 0x92E
261:               		OnlineTimer			= (FL_ONLINE_MAX_SEC + 1);
005DAA  200030     MOV #0x3, W0
005DAC  884740     MOV W0, OnlineTimer
262:               		FL_WEB_ONLINE	= 1;
005DAE  A8A92C     BSET SysFlags, #5
263:               		break;				}
005DB0  37004A     BRA 0x5E46
264:               	case TYPE_ONLINE:		{
265:               		OnlineTimer				= *(U16*)&PacketRec->data[0];
005DB2  4400E8     ADD W8, #0x8, W1
005DB4  780011     MOV [W1], W0
005DB6  884740     MOV W0, OnlineTimer
266:               //		OnlineTimer				= (PacketRec->len > TCP_PACKET_HEDER)? *(U16*)&PacketRec->data[0] : 0;
267:               		if (PacketRec->len > (TCP_PACKET_HEDER + 2))
005DB8  904118     MOV.B [W8+1], W2
005DBA  514FEA     SUB.B W2, #0xA, [W15]
005DBC  360002     BRA LEU, 0x5DC2
268:               			OnlineTimeoutSec	= *(U16*)&PacketRec->data[2];
005DBE  9000D8     MOV [W8+10], W1
005DC0  884971     MOV W1, 0x92E
269:               		FL_WEB_ONLINE			= (OnlineTimer)?	1 : 0;
005DC2  A7F000     BTSC W0, #15
005DC4  EA0000     NEG W0, W0
005DC6  EA0000     NEG W0, W0
005DC8  DE004F     LSR W0, #15, W0
005DCA  DD0045     SL W0, #5, W0
005DCC  804961     MOV SysFlags, W1
005DCE  A15001     BCLR W1, #5
005DD0  700081     IOR W0, W1, W1
005DD2  884961     MOV W1, SysFlags
270:               //		DebugSprintf(tmp,"Online flag: %d, timer: %d, timeout %d", FL_WEB_ONLINE, OnlineTimer, OnlineTimeoutSec);
271:               //		DebugPrint(tmp);
272:               		break;				}
005DD4  370038     BRA 0x5E46
273:               	case TYPE_RESET:		{	// Reset
274:               		if (PacketRec->id == 0xA55A)
005DD6  9000A8     MOV [W8+4], W1
005DD8  2A55A0     MOV #0xA55A, W0
005DDA  508F80     SUB W1, W0, [W15]
005DDC  3A0034     BRA NZ, 0x5E46
275:               		{
276:               			__asm__ ("RESET");
005DDE  FE0000     RESET
005DE0  37FFFF     BRA 0x5DE0
277:               			while(1);
278:               		}
279:               		break;				}
280:               
281:               	case TYPE_FLASH:		{	TcpBootState = State_BootFlash;		FL_BOOT_TCP = 1;	break;	}
005DE2  200010     MOV #0x1, W0
005DE4  884770     MOV W0, TcpBootState
005DE6  A8292D     BSET 0x92D, #1
005DE8  37002E     BRA 0x5E46
282:               	case TYPE_MEM_STATUS:	{	TcpBootState = State_MemStatus;		FL_BOOT_TCP = 1;	break;	}
005DEA  200020     MOV #0x2, W0
005DEC  884770     MOV W0, TcpBootState
005DEE  A8292D     BSET 0x92D, #1
005DF0  37002A     BRA 0x5E46
283:               	case TYPE_MEM_BOOT_ADDR:{	TcpBootState = State_MemBootAddr;	FL_BOOT_TCP = 1;	break;	}
005DF2  200030     MOV #0x3, W0
005DF4  884770     MOV W0, TcpBootState
005DF6  A8292D     BSET 0x92D, #1
005DF8  370026     BRA 0x5E46
284:               	case TYPE_MEM_WRITE:	{
285:               		register U8 i;											//		LEN_CHANGES
286:               		for (i = 0; i < PacketRec->len; i++)					//		LEN_CHANGES
005D80  904018     MOV.B [W8+1], W0
005D82  EB4480     CLR.B W9
005D84  E00400     CP0.B W0
005D86  3A0039     BRA NZ, 0x5DFA
005D88  370042     BRA 0x5E0E
005E06  E84489     INC.B W9, W9
005E08  904018     MOV.B [W8+1], W0
005E0A  504F89     SUB.B W0, W9, [W15]
005E0C  3EFFF6     BRA GTU, 0x5DFA
287:               		{	while (Mem_WriteByte(PacketRec->data[i]) < 0);	}	//		LEN_CHANGES
005DFA  FB8009     ZE W9, W0
005DFC  400068     ADD W0, #0x8, W0
005DFE  784068     MOV.B [W8+W0], W0
005E00  070274     RCALL Mem_WriteByte
005E02  E00400     CP0.B W0
005E04  35FFFA     BRA LT, 0x5DFA
288:               								TcpBootState = State_MemWrite;		FL_BOOT_TCP = 1;	break;	}
005E0E  200040     MOV #0x4, W0
005E10  884770     MOV W0, TcpBootState
005E12  A8292D     BSET 0x92D, #1
005E14  370018     BRA 0x5E46
289:               	case TYPE_MEM_READ:		{
290:               		FL_WIFI_GPRS	= FL_WIFI_OFFLINE;
005E16  804960     MOV SysFlags, W0
005E18  DE0046     LSR W0, #6, W0
005E1A  600062     AND W0, #0x2, W0
005E1C  804751     MOV TcpFlags, W1
005E1E  A11001     BCLR W1, #1
005E20  700081     IOR W0, W1, W1
005E22  884751     MOV W1, TcpFlags
291:               		if (PacketRec->nr)
005E24  900038     MOV [W8+6], W0
005E26  E00000     CP0 W0
005E28  320006     BRA Z, 0x5E36
292:               		{
293:               			Mem_SetReadAddress (*(U32*)&PacketRec->data[0]);
005E2A  440468     ADD W8, #0x8, W8
005E2C  BE0018     MOV.D [W8], W0
005E2E  07023B     RCALL Mem_SetReadAddress
294:               			MemSendSize		=	*(U16*)&PacketRec->data[4];
005E30  900428     MOV [W8+4], W8
005E32  884798     MOV W8, MemSendSize
295:               			MemDataSent		= 0;
005E34  EF28F0     CLR MemDataSent
296:               		}						TcpBootState = State_MemRead;		FL_BOOT_TCP = 1;	break;	}
005E36  200050     MOV #0x5, W0
005E38  884770     MOV W0, TcpBootState
005E3A  A8292D     BSET 0x92D, #1
005E3C  370004     BRA 0x5E46
297:               	case TYPE_DEV_SW_INFO:	{	TcpBootState = State_Idle;			FL_BOOT_TCP	= 1;	break;	}
005E3E  EF28EE     CLR TcpBootState
005E40  A8292D     BSET 0x92D, #1
005E42  370001     BRA 0x5E46
298:               	case TYPE_GSM_SETUP:	{	Gsm_Setup();											break;	}
005E44  07ED19     RCALL Gsm_Setup
299:               
300:               	default:				{
301:               //		outPack = Tcp_GetOutPacketBuffer();
302:               //		outPack->len = TCP_PACKET_HEDER;
303:               //		DebugPrint("Uncnown Packet Type");
304:               		break;				}
305:               	}
306:               	if (outPack)
307:               	{
308:               		Tcp_PreparePacket(outPack, 0);
309:               		FL_TCP_READY = 1;
310:               	}
311:               }
005E46  BE044F     MOV.D [--W15], W8
005E48  060000     RETURN
312:               
313:               void Tcp_SendText (char* str)
005E5C  4001E8     ADD W0, #0x8, W3
314:               {
005E4A  781F88     MOV W8, [W15++]
005E4C  780400     MOV W0, W8
315:               	register TCP_PACKET* outPack = Tcp_GetOutPacketBuffer();
005E4E  07FE7D     RCALL Tcp_GetOutPacketBuffer
316:               	register U8 i = 0;
317:               	while (i < TCP_DATA_LEN)
005E68  40CFE8     ADD.B W1, #0x8, [W15]
005E6A  3AFFF9     BRA NZ, 0x5E5E
318:               	{
319:               		register char a = *str++;
005E50  784118     MOV.B [W8], W2
005E5A  E80408     INC W8, W8
005E5E  784138     MOV.B [W8++], W2
320:               		outPack->data[i++] = (U8)a;
005E52  984802     MOV.B W2, [W0+8]
005E54  B3C011     MOV.B #0x1, W1
005E60  786982     MOV.B W2, [++W3]
005E62  E84081     INC.B W1, W1
321:               		if (a == '\0')
005E56  E00402     CP0.B W2
005E58  320009     BRA Z, 0x5E6C
005E64  E00402     CP0.B W2
005E66  320002     BRA Z, 0x5E6C
322:               			break;
323:               	}
324:               	outPack->len = i;
005E6C  984011     MOV.B W1, [W0+1]
325:               
326:               	Tcp_PreparePacket(outPack, TYPE_TEXT);
005E6E  B3CFE1     MOV.B #0xFE, W1
005E70  07FF26     RCALL Tcp_PreparePacket
327:               	FL_TCP_READY = 1;
005E72  A8892C     BSET SysFlags, #4
328:               }
005E74  78044F     MOV [--W15], W8
005E76  060000     RETURN
329:               
330:               extern void BootFlashInit	(void);
331:               
332:               void Tcp_BootLoaderProcess	(void)
333:               {
005E78  BE9F88     MOV.D W8, [W15++]
005E7A  BE9F8A     MOV.D W10, [W15++]
334:                   static U16 waitCon = 0;
335:               	if ((!Wifi_Connected()) &&	(!GprsConnected()))
005E7C  07FB27     RCALL Wifi_Connected
005E7E  E00400     CP0.B W0
005E80  3A0003     BRA NZ, 0x5E88
005E82  07ECF6     RCALL GprsConnected
005E84  E00400     CP0.B W0
005E86  3200A8     BRA Z, 0x5FD8
336:               		return;
337:               
338:               	register TCP_PACKET* outPack = NULL;
005FC0  EB0400     CLR W8
339:               
340:               	switch (TcpBootState)
005E88  804770     MOV TcpBootState, W0
005E8A  500FE2     SUB W0, #0x2, [W15]
005E8C  320035     BRA Z, 0x5EF8
005E8E  3E0005     BRA GTU, 0x5E9A
005E90  E00000     CP0 W0
005E92  320009     BRA Z, 0x5EA6
005E94  500FE1     SUB W0, #0x1, [W15]
005E96  3A0097     BRA NZ, 0x5FC6
005E98  370025     BRA 0x5EE4
005E9A  500FE4     SUB W0, #0x4, [W15]
005E9C  32004B     BRA Z, 0x5F34
005E9E  390038     BRA NC, 0x5F10
005EA0  500FE5     SUB W0, #0x5, [W15]
005EA2  3A0091     BRA NZ, 0x5FC6
005EA4  370053     BRA 0x5F4C
341:               	{
342:               	case State_Idle:												{
343:               		outPack = Tcp_GetOutPacketBuffer();
005EA6  07FE51     RCALL Tcp_GetOutPacketBuffer
005EA8  780400     MOV W0, W8
344:               		sprintf((char*)outPack->data, "%s %s %s %s \r", DEVICE, VERSION, Build_Date, Build_Time);
005EAA  440068     ADD W8, #0x8, W0
005EAC  2B6431     MOV #0xB643, W1
005EAE  781F81     MOV W1, [W15++]
005EB0  2B6371     MOV #0xB637, W1
005EB2  781F81     MOV W1, [W15++]
005EB4  2B5FE1     MOV #0xB5FE, W1
005EB6  781F81     MOV W1, [W15++]
005EB8  2B6011     MOV #0xB601, W1
005EBA  781F81     MOV W1, [W15++]
005EBC  2B6091     MOV #0xB609, W1
005EBE  781F81     MOV W1, [W15++]
005EC0  07DA75     RCALL __sprintf_cdnopuxX, __sprintf_s, __sprintf_0, __sprintf_cdnopsuxX
345:               		outPack->len = 0;										//		LEN_CHANGES
005EC2  EB4000     CLR.B W0
005EC4  984410     MOV.B W0, [W8+1]
346:               		outPack->type = TYPE_DEV_SW_INFO;
005EC6  B3CED0     MOV.B #0xED, W0
005EC8  984430     MOV.B W0, [W8+3]
347:               		register U8* ptr = outPack->data;
348:               		while (*ptr++ != '\r')
005ECA  5787EA     SUB W15, #0xA, W15
005ECC  904808     MOV.B [W8+8], W0
005ECE  504FED     SUB.B W0, #0xD, [W15]
005ED0  320007     BRA Z, 0x5EE0
005ED2  440069     ADD W8, #0x9, W0
005EDA  B3C0D1     MOV.B #0xD, W1
005EDC  10CFB0     SUBR.B W1, [W0++], [W15]
005EDE  3AFFFA     BRA NZ, 0x5ED4
349:               			outPack->len++;
005ED4  904098     MOV.B [W8+1], W1
005ED6  E84081     INC.B W1, W1
005ED8  984411     MOV.B W1, [W8+1]
350:               		FL_BOOT_TCP = 0;
005EE0  A9292D     BCLR 0x92D, #1
351:               		break;														}
005EE2  370074     BRA 0x5FCC
352:               	case State_BootFlash:											{
353:               		BootFlashInit();
005EE4  070DBE     RCALL BootFlashInit
354:               		outPack			= Tcp_GetOutPacketBuffer();
005EE6  07FE31     RCALL Tcp_GetOutPacketBuffer
005EE8  780400     MOV W0, W8
355:               		outPack->type	= TYPE_FLASH;
005EEA  B3CE20     MOV.B #0xE2, W0
005EEC  984430     MOV.B W0, [W8+3]
356:               		outPack->len	= 0;									//		LEN_CHANGES
005EEE  EB4000     CLR.B W0
005EF0  984410     MOV.B W0, [W8+1]
357:               		TcpBootState	= State_Idle;
005EF2  EF28EE     CLR TcpBootState
358:               		FL_BOOT_TCP		= 0;
005EF4  A9292D     BCLR 0x92D, #1
359:               		break;														}
005EF6  37006A     BRA 0x5FCC
360:               	case State_MemStatus:											{
361:               		outPack			= Tcp_GetOutPacketBuffer();
005EF8  07FE28     RCALL Tcp_GetOutPacketBuffer
005EFA  780400     MOV W0, W8
362:               		outPack->type	= TYPE_MEM_STATUS;
005EFC  B3CE30     MOV.B #0xE3, W0
005EFE  984430     MOV.B W0, [W8+3]
363:               		outPack->len	= 0;									//		LEN_CHANGES
005F00  EB4000     CLR.B W0
005F02  984410     MOV.B W0, [W8+1]
364:               		outPack->nr		= MemStatus();
005F04  070215     RCALL MemStatus
005F06  FB8000     ZE W0, W0
005F08  980430     MOV W0, [W8+6]
365:               		TcpBootState	= State_Idle;
005F0A  EF28EE     CLR TcpBootState
366:               		FL_BOOT_TCP		= 0;
005F0C  A9292D     BCLR 0x92D, #1
367:               		break;														}
005F0E  37005E     BRA 0x5FCC
368:               	case State_MemBootAddr:											{
369:               		#ifdef GPS_IE			// if defined GPS interrupt
370:               			GPS_IE = 0;			// switch it off to avoid memory write
005F10  A9A099     BCLR 0x99, #5
371:               		#endif
372:               //		FL_BOOT = 1;			// Boot process should stop all other processes
373:               		_AD1IE	= 0;			// Disable ADC1 Interrupt
005F12  A9A095     BCLR 0x95, #5
374:               
375:               		Mem_SetWriteAddress(0);
005F14  B80060     MUL.UU W0, #0, W0
005F16  07019D     RCALL Mem_SetWriteAddress
376:               		outPack			= Tcp_GetOutPacketBuffer();
005F18  07FE18     RCALL Tcp_GetOutPacketBuffer
005F1A  780400     MOV W0, W8
377:               		outPack->type	= TYPE_MEM_BOOT_ADDR;
005F1C  B3CE60     MOV.B #0xE6, W0
005F1E  984430     MOV.B W0, [W8+3]
378:               		*(U32*)&outPack->data[0] = Mem_GetWriteAddress();
005F20  4404E8     ADD W8, #0x8, W9
005F22  0701DB     RCALL Mem_GetWriteAddress
005F24  BE8C80     MOV.D W0, [W9]
379:               		*(U16*)&outPack->data[4] = Mem_GetType();
005F26  0701DF     RCALL Mem_GetType
005F28  980460     MOV W0, [W8+12]
380:               		outPack->len	= (sizeof(U32) + sizeof(U16));			//		LEN_CHANGES
005F2A  B3C060     MOV.B #0x6, W0
005F2C  984410     MOV.B W0, [W8+1]
381:               		TcpBootState	= State_Idle;
005F2E  EF28EE     CLR TcpBootState
382:               		FL_BOOT_TCP		= 0;
005F30  A9292D     BCLR 0x92D, #1
383:               		break;														}
005F32  37004C     BRA 0x5FCC
384:               	case State_MemWrite:											{
385:               		if (!MemStatus())
005F34  0701FD     RCALL MemStatus
005F36  E00400     CP0.B W0
005F38  3A004F     BRA NZ, 0x5FD8
386:               		{
387:               			outPack			= Tcp_GetOutPacketBuffer();
005F3A  07FE07     RCALL Tcp_GetOutPacketBuffer
005F3C  780400     MOV W0, W8
388:               			outPack->type	= TYPE_MEM_WRITE;
005F3E  B3CE70     MOV.B #0xE7, W0
005F40  984430     MOV.B W0, [W8+3]
389:               			outPack->len	= 0;								//		LEN_CHANGES
005F42  EB4000     CLR.B W0
005F44  984410     MOV.B W0, [W8+1]
390:               			TcpBootState	= State_Idle;
005F46  EF28EE     CLR TcpBootState
391:               			FL_BOOT_TCP		= 0;
005F48  A9292D     BCLR 0x92D, #1
005F4A  370040     BRA 0x5FCC
392:               		}
393:               		break;														}
394:               	case State_MemRead:												{
395:               		if (FL_WIFI_GPRS != FL_WIFI_OFFLINE)
005F4C  804960     MOV SysFlags, W0
005F4E  DE0047     LSR W0, #7, W0
005F50  604061     AND.B W0, #0x1, W0
005F52  804751     MOV TcpFlags, W1
005F54  D10081     LSR W1, W1
005F56  60C0E1     AND.B W1, #0x1, W1
005F58  50CF80     SUB.B W1, W0, [W15]
005F5A  32000F     BRA Z, 0x5F7A
396:               		{
397:               			if (!waitCon)
005F5C  8047A0     MOV waitCon, W0
005F5E  E00000     CP0 W0
005F60  3A0002     BRA NZ, 0x5F66
398:                               waitCon = 0xFFFF;
005F62  EFA8F4     SETM waitCon
005F64  370039     BRA 0x5FD8
399:                           else if (!(--waitCon))
005F66  E90000     DEC W0, W0
005F68  8847A0     MOV W0, waitCon
005F6A  3A0036     BRA NZ, 0x5FD8
400:                           {
401:                               MemDataSent		= 0;
005F6C  EF28F0     CLR MemDataSent
402:                               MemSendSize		= 0;
005F6E  EF28F2     CLR MemSendSize
403:                               TcpBootState	= State_Idle;
005F70  EF28EE     CLR TcpBootState
404:                               FL_BOOT_TCP		= 0;
005F72  A9292D     BCLR 0x92D, #1
405:                               Tcp_SendText("Wifi offline Error");
005F74  2B6170     MOV #0xB617, W0
005F76  07FF69     RCALL Tcp_SendText
005F78  37002F     BRA 0x5FD8
406:                           }
407:               			return;
408:               		}
409:                       waitCon = 0;
005F7A  EF28F4     CLR waitCon
410:               		register UNI16 len	= {.u16 = (MemSendSize - MemDataSent)};
005F7C  804789     MOV MemDataSent, W9
005F7E  804790     MOV MemSendSize, W0
005F80  500489     SUB W0, W9, W9
005F82  780589     MOV W9, W11
411:               		if (len.u16)
005F84  32001A     BRA Z, 0x5FBA
412:               		{
413:               			outPack			= Tcp_GetOutPacketBuffer();
005F86  07FDE1     RCALL Tcp_GetOutPacketBuffer
005F88  780400     MOV W0, W8
414:               			outPack->type	= TYPE_MEM_READ;
005F8A  B3CE80     MOV.B #0xE8, W0
005F8C  984430     MOV.B W0, [W8+3]
415:               			outPack->nr		= MemDataSent;
005F8E  804781     MOV MemDataSent, W1
005F90  980431     MOV W1, [W8+6]
416:               //			if (len.u16 >= TCP_DATA_LEN)
417:               //				len.u16 = (TCP_DATA_LEN - 1);
418:               			if (len.u16 > 246)
005F92  200F60     MOV #0xF6, W0
005F94  548F80     SUB W9, W0, [W15]
005F96  360001     BRA LEU, 0x5F9A
419:               				len.u16 = 246;
005F98  780580     MOV W0, W11
420:               			register U8 i;
421:               			for (i = 0; i < len.u8l; i++)
005F9A  78450B     MOV.B W11, W10
005F9C  E0040B     CP0.B W11
005F9E  320009     BRA Z, 0x5FB2
005FA0  EB0480     CLR W9
005FAE  554F89     SUB.B W10, W9, [W15]
005FB0  3EFFF8     BRA GTU, 0x5FA2
422:               			{	while (Mem_ReadByte(&outPack->data[i]) < 0);	}
005FA2  448068     ADD W9, #0x8, W0
005FA4  440000     ADD W8, W0, W0
005FA6  0702B9     RCALL Mem_ReadByte
005FA8  E00400     CP0.B W0
005FAA  35FFFB     BRA LT, 0x5FA2
005FAC  E80489     INC W9, W9
423:               			outPack->len	= i;									//		LEN_CHANGES
005FB2  98441A     MOV.B W10, [W8+1]
424:               			MemDataSent	   += len.u16;
005FB4  78000B     MOV W11, W0
005FB6  B428F0     ADD MemDataSent
005FB8  370004     BRA 0x5FC2
425:               		}
426:               		else
427:               		{
428:               			MemDataSent		= 0;
005FBA  EF28F0     CLR MemDataSent
429:               			MemSendSize		= 0;
005FBC  EF28F2     CLR MemSendSize
430:               			TcpBootState	= State_Idle;
005FBE  EF28EE     CLR TcpBootState
431:               		}
432:               		FL_BOOT_TCP		= 0;
005FC2  A9292D     BCLR 0x92D, #1
433:               		break;														}
005FC4  370003     BRA 0x5FCC
434:               	default:														{
435:               		TcpBootState	= State_Idle;
005FC6  EF28EE     CLR TcpBootState
436:               		FL_BOOT_TCP		= 0;
005FC8  A9292D     BCLR 0x92D, #1
437:               		break;														}
005FCA  370006     BRA 0x5FD8
438:               	}
439:               	if (outPack)
005FCC  E00008     CP0 W8
005FCE  320004     BRA Z, 0x5FD8
440:               	{
441:               		Tcp_PreparePacket(outPack, 0);
005FD0  EB4080     CLR.B W1
005FD2  780008     MOV W8, W0
005FD4  07FE74     RCALL Tcp_PreparePacket
442:               		FL_TCP_READY = 1;
005FD6  A8892C     BSET SysFlags, #4
443:               	}
444:               }
005FD8  BE054F     MOV.D [--W15], W10
005FDA  BE044F     MOV.D [--W15], W8
005FDC  060000     RETURN
445:               
446:               void	Tcp_PacketResend	(void)
447:               {
005FDE  FA0002     LNK #0x2
005FE0  781F88     MOV W8, [W15++]
448:               	if (!FL_INIT)
005FE2  AB08EA     BTST TcpFlags, #0
005FE4  3A0041     BRA NZ, 0x6068
449:               		Tcp_Init();
005FE6  07FD8B     RCALL Tcp_Init
450:               
451:               //	Tcp_SendText("Resend Packet");
452:               	Mem_SetReadAddress((U32)(ResendPacket) << 8);			//        0   1    2   3  4  5  6  7  .   254 255
005FE8  804762     MOV ResendPacket, W2
005FEA  EB0180     CLR W3
005FEC  DD1848     SL W3, #8, W0
005FEE  DE10C8     LSR W2, #8, W1
005FF0  700081     IOR W0, W1, W1
005FF2  DD1048     SL W2, #8, W0
005FF4  070158     RCALL Mem_SetReadAddress
006068  804762     MOV ResendPacket, W2
00606A  EB0180     CLR W3
00606C  DD1848     SL W3, #8, W0
00606E  DE10C8     LSR W2, #8, W1
006070  700081     IOR W0, W1, W1
006072  DD1048     SL W2, #8, W0
006074  070118     RCALL Mem_SetReadAddress
453:               	TCP_PACKET* outPack = Tcp_GetOutPacketBuffer();
005FF6  07FDA9     RCALL Tcp_GetOutPacketBuffer
005FF8  780400     MOV W0, W8
006076  07FD69     RCALL Tcp_GetOutPacketBuffer
006078  780400     MOV W0, W8
454:               
455:               	U8 i;	// Copy header bytes from memory (Len & crc skipped)      0   1    2   3  4  5  6  7  .   254 255
456:               	for (i = 2; i < TCP_PACKET_HEDER; i++)					// mem-> STX Type  ID_ID  AD_AD .  .  .   len crc |
005FFA  B3C020     MOV.B #0x2, W0
005FFC  9FFFC0     MOV.B W0, [W15-4]
00600A  97F8CF     MOV.B [W15-4], W1
00600C  E84001     INC.B W1, W0
00600E  9FFFC0     MOV.B W0, [W15-4]
006010  504FE7     SUB.B W0, #0x7, [W15]
006012  36FFF5     BRA LEU, 0x5FFE
00607A  B3C020     MOV.B #0x2, W0
457:               	{	while (Mem_ReadByte(&outPack->bytes[i]) < 0);	}	//        |  \   \   \  \  \  \  \  \  \          |
005FFE  97F8CF     MOV.B [W15-4], W1
006000  FB8001     ZE W1, W0
006002  440000     ADD W8, W0, W0
006004  07028A     RCALL Mem_ReadByte
006006  E00400     CP0.B W0
006008  35FFFA     BRA LT, 0x5FFE
458:               	for (i = 0; i < TCP_DATA_LEN; i++)						//        |    \   \   \  \  \  \  \  \  \        |
006014  EB4000     CLR.B W0
006016  9FFFC0     MOV.B W0, [W15-4]
006034  E84000     INC.B W0, W0
006036  9FFFC0     MOV.B W0, [W15-4]
006038  404FE9     ADD.B W0, #0x9, [W15]
00603A  36FFEE     BRA LEU, 0x6018
459:               	{		// Copy data bytes, count recorded				//        |      \   \   \  \  \  \  \  \  \      |
460:               		while (Mem_ReadByte(&outPack->data[i]) < 0);		// tcp-> STX Len CRC Type ID_ID AD_AD  .  .  .    |
006018  97F8CF     MOV.B [W15-4], W1
00601A  FB8001     ZE W1, W0
00601C  400068     ADD W0, #0x8, W0
00601E  440000     ADD W8, W0, W0
006020  07027C     RCALL Mem_ReadByte
006022  E00400     CP0.B W0
006024  35FFF9     BRA LT, 0x6018
461:               		if (outPack->data[i] != MEMORY_EMPTY_CHAR)			//        0   1   2   3   4   5  6  7  8  9  .
006026  97F84F     MOV.B [W15-4], W0
006028  FB8080     ZE W0, W1
00602A  4080E8     ADD W1, #0x8, W1
00602C  78C0E8     MOV.B [W8+W1], W1
00602E  40CFE1     ADD.B W1, #0x1, [W15]
006030  320001     BRA Z, 0x6034
462:               			outPack->len = i;
006032  984410     MOV.B W0, [W8+1]
463:               	}
464:               /*	if (pack->crc != STX)						// TODO		// Verify STX in memory (shifted to CRC by copy)
465:               	{}														// TODO
466:               	if (pack->type != TYPE_GPS_DATA)						// Verify Tcp Packet Type
467:               	{}														// TODO
468:               	if (pack->id != DataFromFlash.DeviceId)					// Verify Device ID in packet
469:               	{}														// TODO
470:               	if (pack->nr != ResendPacket)							// Verify Packet number
471:               	{}														// TODO	*/
472:               //	while (Mem_ReadByte(&outPack->len) < 0);
473:               	while (Mem_ReadByte(&i) < 0);							// recorded len in memory
00603C  578064     SUB W15, #0x4, W0
00603E  07026D     RCALL Mem_ReadByte
006040  E00400     CP0.B W0
006042  35FFFC     BRA LT, 0x603C
474:               	if ((outPack->len != i) && (i <= TCP_DATA_LEN))			// if len in mem > counted & it's correct
006044  97F84F     MOV.B [W15-4], W0
006046  904098     MOV.B [W8+1], W1
006048  50CF80     SUB.B W1, W0, [W15]
00604A  320003     BRA Z, 0x6052
00604C  404FE8     ADD.B W0, #0x8, [W15]
00604E  3E0001     BRA GTU, 0x6052
475:               		outPack->len = i;									// use len from memory
006050  984410     MOV.B W0, [W8+1]
476:               //	while (Mem_ReadByte(&outPack->crc) < 0);		
477:               //	outPack->start	= STX;
478:               	if (outPack->type < TYPE_CURRENT_DATA)					// TODO		// Check also other types in future
006052  904038     MOV.B [W8+3], W0
006054  504FEE     SUB.B W0, #0xE, [W15]
006056  3E0004     BRA GTU, 0x6060
479:               	{
480:               		Tcp_PreparePacket(outPack, 0);
006058  EB4080     CLR.B W1
00605A  780008     MOV W8, W0
00605C  07FE30     RCALL Tcp_PreparePacket
481:               		FL_TCP_READY	= 1;
00605E  A8892C     BSET SysFlags, #4
482:               	}
483:               	FL_TCP_RESEND	= 0;
006060  A9492D     BCLR 0x92D, #2
484:               }
006062  78044F     MOV [--W15], W8
006064  FA8000     ULNK
006066  060000     RETURN
006068  804762     MOV ResendPacket, W2
00606A  EB0180     CLR W3
00606C  DD1848     SL W3, #8, W0
00606E  DE10C8     LSR W2, #8, W1
006070  700081     IOR W0, W1, W1
006072  DD1048     SL W2, #8, W0
006074  070118     RCALL Mem_SetReadAddress
006076  07FD69     RCALL Tcp_GetOutPacketBuffer
006078  780400     MOV W0, W8
00607A  B3C020     MOV.B #0x2, W0
00607C  9FFFC0     MOV.B W0, [W15-4]
00607E  37FFBF     BRA 0x5FFE
---  /home/pele/src/Auto_02/src/Spi_i2c.c  --------------------------------------------------------------
1:                 #include	"Spi_i2c.h"
2:                 #include	"Ports.h"
3:                 #include	"Timers.h"
4:                 
5:                 // _________________________________SPI2 functions__________________________________________________
6:                 #define	I2C_WRITE				0x00
7:                 #define	I2C_READ				0x01
8:                 
9:                 #define	SPI1STAT_VAL			0b0000000000010100	// SPI1STAT Register
10:                #define	SPI2STAT_VAL			0b0000000000001000;	// SPI2STAT Register
11:                #define	SPI3STAT_VAL			0b0000000000010100	// SPI3STAT Register
12:                							//	  |||||||||||||||+	-- SPIRBF: SPIx Receive Buffer Full Status
13:                							//	  ||||||||||||||+-	-- SPITBF: SPIx Transmit Buffer Full Status bit
14:                							//	  |||||||||||+++--	-- SISEL<2:0>: SPIx Buffer Interrupt Mode bits (valid in Enhanced Buffer mode)	101=Interrupt when the last bit is shifted out of SPIxSR; now the transmit is complete
15:                							//	  |||||||||||+++--	-- 																				110 = Interrupt when the last bit is shifted into SPIxSR; as a result, the TX FIFO is empty
16:                							//	  ||||||||||+-----	-- SRXMPT: Receive FIFO Empty bit (valid in Enhanced Buffer mode)
17:                							//	  |||||||||+------	-- SPIROV: Receive Overflow Flag
18:                							//	  ||||||||+-------	-- SRMPT: Shift Register (SPIxSR) Empty bit (valid in Enhanced Buffer mode)
19:                							//	  |||||+++--------	-- SPIBEC<2:0>: SPIx Buffer Element Count bits (valid in Enhanced Buffer mode)
20:                							//	  |||++-----------	-- Unimplemented
21:                							//	  ||+-------------	-- SPISIDL: Stop in Idle Mode
22:                							//	  |+--------------	-- Unimplemented
23:                							//	  +---------------	-- SPIEN: SPIx Enable
24:                
25:                #define	SPI1CON1_VAL			0b0000000001111111	// SPI1CON1 Register
26:                #define	SPI2CON1_VAL_CLK_HI		0b0000100001011111	// SPI2CON1 Register if SCK Idle state - high level
27:                #define	SPI2CON1_VAL_CLK_LO		0b0000100000011111	// SPI2CON1 Register if SCK Idle state - low level
28:                #define	SPI3CON1_VAL			0b0000000001111111;	// SPI3CON1 Register
29:                							//	  ||||||||||||||++	-- PPRE<1:0>: Primary Prescale bits (Master mode)	(1:1)
30:                							//	  |||||||||||+++--	-- SPRE<2:0>: Secondary Prescale bits (Master mode)	(1:2)
31:                							//	  ||||||||||+-----	-- MSTEN: Master Mode Enable
32:                							//	  |||||||||+------	-- CKP: Clock Polarity Select (1 = SCK Idle state - high level)
33:                							//	  ||||||||+-------	-- SSEN: Slave Select Enable
34:                							//	  |||||||+--------	-- CKE: SPIx Clock Edge Select (0- SDO data CHANGES on Idle to Active CLK)
35:                							//	  ||||||+---------	-- SMP: SPIx Data Input Sample Phase (0 = SDI sampled at the middle of data output time; 1 = at the end)
36:                							//	  |||||+----------	-- MODE16: Word/Byte Communication Select (0 = 8bit, 1 = 16bit)
37:                							//	  ||||+-----------	-- DISSDO: Disable SDOx Pin bit
38:                							//	  |||+------------	-- DISSCK: Disable SCKx Pin bit (SPI Master modes only)
39:                							//	  +++-------------	-- Unimplemented
40:                
41:                #define	SPI1CON2_VAL			0b0000000000000001	// SPI1CON2 Register
42:                #define	SPI2CON2_VAL			0b0000000000000001	// SPI2CON2 Register
43:                //		SPI2CON2_VAL			0b0000000000000000	// SPI2CON2 Register
44:                #define	SPI3CON2_VAL			0b0000000000000001	// SPI3CON2 Register
45:                							//	  |||||||||||||||+	-- SPIBEN: Enhanced Buffer Enable
46:                							//	  ||||||||||||||+-	-- SPIFE: Frame Sync Pulse Edge Select
47:                							//	  |||+++++++++++--	-- Unimplemented
48:                							//	  ||+-------------	-- SPIFPOL: Frame Sync Pulse Polarity bit (Frame mode only)
49:                							//	  |+--------------	-- SPIFSD: Frame Sync Pulse Direction Control on SSx Pin
50:                							//	  +---------------	-- FRMEN: Framed SPIx Support
51:                
52:                void Spi1_Init(void)
53:                {
54:                	SPI1STAT = SPI1STAT_VAL;
00783A  200140     MOV #0x14, W0
00783C  881200     MOV W0, SPI1STAT
55:                	SPI1CON1 = SPI1CON1_VAL;
00783E  2007F0     MOV #0x7F, W0
007840  881210     MOV W0, SPI1CON1
56:                	SPI1CON2 = SPI1CON2_VAL;
007842  200010     MOV #0x1, W0
007844  881220     MOV W0, SPI1CON2
57:                	_SPI1IP		= 3;				// SPI1 Interrupt priority level=3
007846  2F8FF0     MOV #0xF8FF, W0
007848  B600A8     AND IPC2, WREG
00784A  B33000     IOR #0x300, W0
00784C  880540     MOV W0, IPC2
58:                	_SPI1IF		= 1;				// Clear SPI1 Interrupt Flag
00784E  A84085     BSET 0x85, #2
59:                	_SPI1IE		= 0;				// Clear SPI1 Interrupt
007850  A94095     BCLR 0x95, #2
60:                	SPI1STATbits.SPIEN	= 1;		// Enable SPI1
007852  A8E241     BSET 0x241, #7
61:                }
007854  060000     RETURN
62:                
63:                void Spi3_Init(void)
64:                {
65:                	SPI3STAT = SPI3STAT_VAL;
007856  200140     MOV #0x14, W0
007858  881400     MOV W0, SPI3STAT
66:                	SPI3CON1 = SPI3CON1_VAL;
00785A  2007F0     MOV #0x7F, W0
00785C  881410     MOV W0, SPI3CON1
67:                	SPI3CON2 = SPI3CON2_VAL;
00785E  200010     MOV #0x1, W0
007860  881420     MOV W0, SPI3CON2
68:                	_SPI3IP		= 3;				// SPI3 Interrupt priority level=3
007862  28FFF1     MOV #0x8FFF, W1
007864  800680     MOV IPC22, W0
007866  608080     AND W1, W0, W1
007868  230000     MOV #0x3000, W0
00786A  700001     IOR W0, W1, W0
00786C  880680     MOV W0, IPC22
69:                	_SPI3IF		= 0;				// Clear SPI3 Interrupt Flag
00786E  A9608F     BCLR 0x8F, #3
70:                	_SPI3IE		= 0;				// Clear SPI3 Interrupt
007870  A9609F     BCLR 0x9F, #3
71:                	SPI3STATbits.SPIEN	= 1;		// Enable SPI3
007872  A8E281     BSET 0x281, #7
72:                }
007874  060000     RETURN
73:                
74:                void Spi2_Init(void)
75:                {
76:                	SPI2STAT = SPI2STAT_VAL;
007876  200080     MOV #0x8, W0
007878  881300     MOV W0, SPI2STAT
77:                //	SPI2CON1 = (FLAG_IDLE_PR_CLK)?	SPI2CON1_VAL_CLK_HI : SPI2CON1_VAL_CLK_LO;
78:                	SPI2CON1 = SPI2CON1_VAL_CLK_HI;
00787A  2085F0     MOV #0x85F, W0
00787C  881310     MOV W0, SPI2CON1
79:                	SPI2CON2 = SPI2CON2_VAL;
00787E  200010     MOV #0x1, W0
007880  881320     MOV W0, SPI2CON2
80:                	_SPI2IP		= 5;				// SPI1 Interrupt priority level=5
007882  2FF8F0     MOV #0xFF8F, W0
007884  B600B4     AND IPC8, WREG
007886  B30500     IOR #0x50, W0
007888  8805A0     MOV W0, IPC8
81:                	_SPI2IF		= 0;				// Clear SPI2 Interrupt Flag
00788A  A92088     BCLR IFS2, #1
82:                	_SPI2IE		= 1;				// Clear SPI2 Interrupt
00788C  A82098     BSET IEC2, #1
83:                	SPI2STATbits.SPIEN	= 1;		// Enable SPI2
00788E  A8E261     BSET 0x261, #7
84:                }
007890  060000     RETURN
85:                
86:                //	*********************************************************************
87:                //	*							SPI1 INTERRUPT							*
88:                //	*********************************************************************
89:                /*
90:                void __attribute__((interrupt, no_auto_psv)) _SPI1Interrupt(void)
91:                {
92:                	_SPI1IF	= 0;				// Clear SPI1 Interrupt Flag
93:                	SPI1STATbits.SPIROV = 0;	// Clear Receive Overflow Flag
94:                //	Mem1Irq();
95:                }
96:                */
97:                //	*********************************************************************
98:                //	*							SPI2 INTERRUPT							*
99:                //	*********************************************************************
100:               void __attribute__((interrupt, no_auto_psv)) _SPI2Interrupt(void)
101:               {
102:               	_SPI2IF	= 0;				// Clear SPI2 Interrupt Flag
007892  A92088     BCLR IFS2, #1
103:               	SPI2STATbits.SPIROV = 0;	// Clear Receive Overflow Flag
007894  A9C260     BCLR SPI2STAT, #6
104:               //	Printer_SPI_IRQ();
105:               }
007896  064000     RETFIE
106:               
107:               //	*********************************************************************
108:               //	*							SPI3 INTERRUPT							*
109:               //	*********************************************************************
110:               void __attribute__((interrupt, no_auto_psv)) _SPI3Interrupt(void)
111:               {
112:               	_SPI3IF	= 0;				// Clear SPI3 Interrupt Flag
007898  A9608F     BCLR 0x8F, #3
113:               	SPI3STATbits.SPIROV = 0;	// Clear Receive Overflow Flag
00789A  A9C280     BCLR SPI3STAT, #6
114:               //	Mem2Irq();
115:               }
00789C  064000     RETFIE
116:               
117:               void Spi1Clear (void)
118:               {
119:               	register U8 a;
120:               	while(SPI1_BUSY())		{a += SPI1BUF;}
00789E  207A31     MOV #0x7A3, W1
0078A0  801200     MOV SPI1STAT, W0
0078A2  608080     AND W1, W0, W1
0078A4  200A00     MOV #0xA0, W0
0078A6  508F80     SUB W1, W0, [W15]
0078A8  320007     BRA Z, 0x78B8
0078AA  207A32     MOV #0x7A3, W2
0078AC  780080     MOV W0, W1
0078AE  801240     MOV SPI1BUF, W0
0078B0  801203     MOV SPI1STAT, W3
0078B2  610003     AND W2, W3, W0
0078B4  500F81     SUB W0, W1, [W15]
0078B6  3AFFFB     BRA NZ, 0x78AE
121:               	SPI1STATbits.SPIROV = 0;	// Clear Receive Overflow Flag
0078B8  A9C240     BCLR SPI1STAT, #6
122:               }
0078BA  060000     RETURN
123:               
124:               void Spi3Clear (void)
125:               {
126:               	register U8 a;
127:               	while(SPI3_BUSY())		{a += SPI3BUF;}
0078BC  207A31     MOV #0x7A3, W1
0078BE  801400     MOV SPI3STAT, W0
0078C0  608080     AND W1, W0, W1
0078C2  200A00     MOV #0xA0, W0
0078C4  508F80     SUB W1, W0, [W15]
0078C6  320007     BRA Z, 0x78D6
0078C8  207A32     MOV #0x7A3, W2
0078CA  780080     MOV W0, W1
0078CC  801440     MOV SPI3BUF, W0
0078CE  801403     MOV SPI3STAT, W3
0078D0  610003     AND W2, W3, W0
0078D2  500F81     SUB W0, W1, [W15]
0078D4  3AFFFB     BRA NZ, 0x78CC
128:               	SPI3STATbits.SPIROV = 0;	// Clear Receive Overflow Flag
0078D6  A9C280     BCLR SPI3STAT, #6
129:               }
0078D8  060000     RETURN
130:               
131:               void Spi2Clear (void)
132:               {
133:               	U8 a,i = 8;
134:               	while(i--)
135:               		a += SPI2BUF;			// to clear SPIRBF (Receive Buffer Full Status bit)
0078DA  801340     MOV SPI2BUF, W0
0078DC  801340     MOV SPI2BUF, W0
0078DE  801340     MOV SPI2BUF, W0
0078E0  801340     MOV SPI2BUF, W0
0078E2  801340     MOV SPI2BUF, W0
0078E4  801340     MOV SPI2BUF, W0
0078E6  801340     MOV SPI2BUF, W0
0078E8  801340     MOV SPI2BUF, W0
136:               }
0078EA  060000     RETURN
137:               
138:               U8	Spi1Byte (U8 data)
139:               {
140:               	U8 a = SPI1BUF;				// to clear SPIRBF (Receive Buffer Full Status bit)
0078EC  801241     MOV SPI1BUF, W1
141:               	SPI1BUF = data;
0078EE  FB8000     ZE W0, W0
0078F0  881240     MOV W0, SPI1BUF
142:               	while (SPI1STATbits.SRXMPT) a++;
0078F2  200201     MOV #0x20, W1
0078F4  801202     MOV SPI1STAT, W2
0078F6  608002     AND W1, W2, W0
0078F8  3AFFFD     BRA NZ, 0x78F4
143:               	a = SPI1BUF;
0078FA  801240     MOV SPI1BUF, W0
144:               	return a;
145:               }
0078FC  060000     RETURN
146:               
147:               U8	Spi2Byte (U8 data)
148:               {
149:               	U8 a = SPI2BUF;				// to clear SPIRBF (Receive Buffer Full Status bit)
0078FE  801341     MOV SPI2BUF, W1
150:               	SPI2BUF = data;
007900  FB8000     ZE W0, W0
007902  881340     MOV W0, SPI2BUF
151:               	while (!SPI2STATbits.SPIRBF) a++;
007904  AB0260     BTST SPI2STAT, #0
007906  32FFFE     BRA Z, 0x7904
152:               	a = SPI2BUF;
007908  801340     MOV SPI2BUF, W0
153:               	return a;
154:               }
00790A  060000     RETURN
155:               
156:               U8	Spi3Byte (U8 data)
157:               {
158:               	U8 a = SPI3BUF;				// to clear SPIRBF (Receive Buffer Full Status bit)
00790C  801441     MOV SPI3BUF, W1
159:               	SPI3BUF = data;
00790E  FB8000     ZE W0, W0
007910  881440     MOV W0, SPI3BUF
160:               	while (SPI3STATbits.SRXMPT) a++;
007912  200201     MOV #0x20, W1
007914  801402     MOV SPI3STAT, W2
007916  608002     AND W1, W2, W0
007918  3AFFFD     BRA NZ, 0x7914
161:               	a = SPI3BUF;
00791A  801440     MOV SPI3BUF, W0
162:               	return a;
163:               }
00791C  060000     RETURN
164:               
165:               /* _________________________________I2C functions___________________________________________________
166:               #define	I2C_WRITE				0x00
167:               #define	I2C_READ				0x01
168:               
169:               inline void I2c2Start	(void);
170:               inline void I2c2Stop		(void);
171:               inline U8	I2c2Send		(U8 data);
172:               inline U8	I2c2Get		(U8 ack);
173:               inline void I2c2AltStart	(void);
174:               inline void I2c2AltStop	(void);
175:               inline U8	I2c2AltSend	(U8 data);
176:               inline U8	I2c2AltGet	(U8 ack);
177:               
178:               inline void I2c2Start(void)
179:               {
180:               	I2C2_SCL_HI();	DELAY_2uS();
181:               	I2C2_SDA_HI();	DELAY_2uS();
182:               	I2C2_SDA_LO();	DELAY_2uS();
183:               	I2C2_SCL_LO();	DELAY_2uS();
184:               }
185:               
186:               inline void I2c2Stop(void)
187:               {
188:               	I2C2_SDA_LO();	DELAY_2uS();
189:               	I2C2_SCL_HI();	DELAY_2uS();
190:               	I2C2_SDA_HI();	DELAY_2uS();
191:               }
192:               
193:               // return	1 if ack = OK
194:               //			0 if ack = NOK
195:               inline U8	I2c2Send(U8 data)
196:               {
197:               	U8 i = 0x80;
198:               	while (i)
199:               	{
200:               		I2C2_SDA = (i & data)? 1:0;
201:               		DELAY_I2C();
202:               		I2C2_SCL_HI();	DELAY_I2C();
203:               		I2C2_SCL_LO();	DELAY_I2C();
204:               		i >>= 1;
205:               	}
206:               	I2C2_SDA_IN();
207:               	DELAY_I2C();
208:               	I2C2_SCL_HI();		DELAY_I2C();
209:               	if (!I2C2_SDA_INPUT)	i = 1;
210:               	I2C2_SCL_LO();		DELAY_I2C();
211:               	return i;
212:               }
213:               
214:               // ack > 0 : OK
215:               // ack = 0 : NOK
216:               inline U8	I2c2Get(U8 ack)
217:               {
218:               	U8 i = 0x80, data = 0;
219:               	I2C2_SDA_IN();
220:               	while (i)
221:               	{
222:               		I2C2_SCL_HI();		DELAY_I2C();
223:               		if (I2C2_SDA_INPUT)	data |= i;
224:               		I2C2_SCL_LO();		DELAY_2uS();
225:               		i >>= 1;
226:               	}
227:               	if (ack)		I2C2_SDA_LO();
228:               	I2C2_SCL_HI();	DELAY_I2C();
229:               	I2C2_SCL_LO();	DELAY_I2C();
230:               	return data;
231:               }
232:               
233:               U8	I2c2Test(U8 data)
234:               {
235:               
236:               	U8 rc = 0x0F;								// OK
237:               	I2c2Start();
238:               	if (!I2c2Send(data))	rc = 0xEE;			// NOK
239:               	I2c2Stop();
240:               	return rc;
241:               }
242:               
243:               // _________________________________I2C functions for MPU6000/Compass_______________________________
244:               U8	I2c2WriteByte(U8 slave, U8 address, U8 data)
245:               {
246:               	I2c2Start();
247:               	if (!I2c2Send(slave | I2C_WRITE))					return 0;
248:               	if (!I2c2Send(address))								return 0;
249:               	if (!I2c2Send(data))								return 0;
250:               	I2c2Stop();
251:               	return 1;
252:               }
253:               
254:               U8	I2c2Write(U8 slave, U8 address, P_U8 data, U8 len)
255:               {
256:               	I2c2Start();
257:               	if (!I2c2Send(slave | I2C_WRITE))					return 0;
258:               	if (!I2c2Send(address))								return 0;
259:               	while (len)
260:               	{
261:               		if (!I2c2Send(*data++))							return 0;
262:               		len--;
263:               	}
264:               	I2c2Stop();
265:               	return 1;
266:               }
267:               
268:               U8	I2c2Read(U8 slave, P_U8 data, U8 len)
269:               {
270:               	I2c2Start();
271:               	if (!I2c2Send(slave | I2C_READ))					return 0;
272:               	while (len)
273:               	{
274:               		U8 ack = (--len)? 1:0;
275:               		*data++ = I2c2Get(ack);
276:               	}
277:               	I2c2Stop();
278:               	return 1;
279:               }
280:               
281:               U8	I2c2ReadReverse(U8 slave, P_U8 data, U8 len)
282:               {
283:               	I2c2Start();
284:               	if (!I2c2Send(slave | I2C_READ))					return 0;
285:               	while (len)
286:               	{
287:               		U8 ack = (--len)? 1:0;
288:               		data[len] = I2c2Get(ack);
289:               	}
290:               	I2c2Stop();
291:               	return 1;
292:               }
293:               
294:               U8	I2c2ReadFrom(U8 slave, U8 address, P_U8 data, U8 len)
295:               {
296:               	I2c2Start();
297:               	if (!I2c2Send(slave | I2C_WRITE))					return 0;
298:               	if (!I2c2Send(address))								return 0;
299:               	return I2c2Read(slave, data, len);
300:               }
301:               
302:               U8	I2c2ReadReverseFrom(U8 slave, U8 address, P_U8 data, U8 len)
303:               {
304:               	I2c2Start();
305:               	if (!I2c2Send(slave | I2C_WRITE))					return 0;
306:               	if (!I2c2Send(address))								return 0;
307:               	return I2c2ReadReverse(slave, data, len);
308:               }
309:               */
---  /home/pele/src/Auto_02/src/Ports.c  ----------------------------------------------------------------
1:                 #include	"Ports.h"
2:                 
3:                 char	__attribute__((space(auto_psv)))	Build_Date[] =	__DATE__;
4:                 char	__attribute__((space(auto_psv)))	Build_Time[] =	__TIME__;
5:                 
6:                 #ifdef	ROM_DATA_ADDR	//_____________ Flash read/write functions ____________________________________
7:                 	#include	"libpic30.h"
8:                 	#include	<string.h>
9:                 	#include	<stdio.h>
10:                	// Flash data runing copy in RAM
11:                	FLASH_DATA_STRUCT DataFromFlash;
12:                	// Flash data copy in ROM
13:                	
14:                	U16 __attribute__((space(prog),address(ROM_DATA_ADDR),aligned(ROM_DATA_SIZE),fillupper(0xFF))) FlashData[_FLASH_PAGE] = 
15:                	{
16:                		0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,
17:                		0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,
18:                		0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,
19:                		0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,
20:                		0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,
21:                		0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,
22:                		0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,
23:                		0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,
24:                	};
25:                
26:                	// Copy data from flash to ram structure
27:                	void FlashDataInit(void)
28:                	{
29:                		_prog_addressT	pFlash;
30:                		_init_prog_address(pFlash, FlashData);								// get address in program space
31:                		_memcpy_p2d16(&DataFromFlash, pFlash, sizeof(FLASH_DATA_STRUCT));	// copy data from program space
00771E  EB0200     CLR W4
007720  200643     MOV #0x64, W3
007722  2372C2     MOV #0x372C, W2
007724  20C000     MOV #0xC00, W0
007726  201001     MOV #0x100, W1
007728  07CD4B     RCALL __memcpy_helper
32:                
33:                		if ((memcmp(DataFromFlash.BuildTime, Build_Date, sizeof(Build_Date)) == 0)	&&
00772A  2000C2     MOV #0xC, W2
00772C  2B6371     MOV #0xB637, W1
00772E  237440     MOV #0x3744, W0
007730  07CD62     RCALL _memcmp
007732  E00000     CP0 W0
007734  3A0006     BRA NZ, 0x7742
00773E  E00000     CP0 W0
007740  320017     BRA Z, 0x7770
34:                			(memcmp(DataFromFlash.BuildDate, Build_Time, sizeof(Build_Time)) == 0)		)
007736  200092     MOV #0x9, W2
007738  2B6431     MOV #0xB643, W1
00773A  237300     MOV #0x3730, W0
00773C  07CD5C     RCALL _memcmp
35:                			return;
36:                
37:                		if (ROM_DATA_CLEARED)												// Flash data not initialized jet
007742  2372C0     MOV #0x372C, W0
007744  E00010     CP0 [W0]
007746  3D000A     BRA GE, 0x775C
38:                		{
39:                			memset((char*)(&DataFromFlash), NULL, sizeof(FLASH_DATA_STRUCT));
007748  2372C0     MOV #0x372C, W0
00774A  090031     REPEAT #0x31
00774C  EB1800     CLR [W0++]
40:                			DataFromFlash.flags.word		=	0x0000;
41:                			DataFromFlash.DeviceId			=	DEVICE_ID;
00774E  201000     MOV #0x100, W0
007750  89B970     MOV W0, _Gsm_AtCommand
42:                			#if (TEST != NO_TEST)
43:                				sprintf(DataFromFlash.Name,		DEVICE_NAME);
44:                			#endif
45:                			sprintf(DataFromFlash.GsmSmsNumber,	"+37129279661");
007752  2B62A0     MOV #0xB62A, W0
007754  237641     MOV #0x3764, W1
007756  09000C     REPEAT #0xC
007758  7858B0     MOV.B [W0++], [W1++]
00775A  B100D0     SUB #0xD, W0
46:                		}
47:                		memcpy(DataFromFlash.BuildTime, Build_Date, sizeof(Build_Date));
00775C  237440     MOV #0x3744, W0
00775E  2B6371     MOV #0xB637, W1
007760  09000B     REPEAT #0xB
007762  785831     MOV.B [W1++], [W0++]
48:                		memcpy(DataFromFlash.BuildDate, Build_Time, sizeof(Build_Time));
007764  237300     MOV #0x3730, W0
007766  2B6431     MOV #0xB643, W1
007768  090008     REPEAT #0x8
00776A  785831     MOV.B [W1++], [W0++]
49:                		FL_BOOT_TCP = 1;
00776C  A8292D     BSET 0x92D, #1
50:                		FlashDataBurn();
00776E  07FFCB     RCALL FlashDataBurn
51:                	}
007770  060000     RETURN
52:                
53:                	// Burn actual ram data to nonvolatile memory (flash)
54:                	void FlashDataBurn(void)
55:                	{
007706  BE9F88     MOV.D W8, [W15++]
56:                		_prog_addressT	pFlash;
57:                		_init_prog_address(pFlash, FlashData);								// get address in program space
007708  20C008     MOV #0xC00, W8
00770A  201009     MOV #0x100, W9
58:                		_erase_flash(pFlash);												// erase a page
00770C  240422     MOV #0x4042, W2
00770E  BE0008     MOV.D W8, W0
007710  07CD2A     RCALL __flash_helper1
59:                		_write_flash16(pFlash, (int*)(&DataFromFlash));						// write first row with 16-bit data
007712  200403     MOV #0x40, W3
007714  2372C2     MOV #0x372C, W2
007716  BE0008     MOV.D W8, W0
007718  07CD34     RCALL __flash_helper2
60:                	}
00771A  BE044F     MOV.D [--W15], W8
00771C  060000     RETURN
61:                #endif	// ROM_DATA___________________________________________________________________________
62:                
63:                volatile FLAGS		SysFlags;
64:                
65:                void InitPorts(void)
66:                {
67:                	InitPort_B();
007772  220000     MOV #0x2000, W0
007774  881660     MOV W0, LATB
007776  25BFF0     MOV #0x5BFF, W0
007778  881640     MOV W0, TRISB
00777A  EF22CE     CLR ODCB
00777C  2003F0     MOV #0x3F, W0
00777E  882710     MOV W0, ANSB
68:                	InitPort_C();
007780  EF22D4     CLR LATC
007782  EFA2D0     SETM TRISC
007784  EF22D6     CLR ODCC
007786  EF24E4     CLR ANSC
69:                	InitPort_D();
007788  EF22DC     CLR LATD
00778A  2FF1E0     MOV #0xFF1E, W0
00778C  8816C0     MOV W0, TRISD
00778E  200100     MOV #0x10, W0
007790  8816F0     MOV W0, ODCD
007792  EF24E6     CLR ANSD
70:                	InitPort_E();
007794  EF22E4     CLR LATE
007796  2FFFD1     MOV #0xFFFD, W1
007798  881701     MOV W1, TRISE
00779A  EF22E6     CLR ODCE
71:                	InitPort_F();
00779C  881760     MOV W0, LATF
00779E  2FFEA0     MOV #0xFFEA, W0
0077A0  881740     MOV W0, TRISF
0077A2  200020     MOV #0x2, W0
0077A4  881770     MOV W0, ODCF
0077A6  EF24EA     CLR ANSF
72:                	InitPort_G();
0077A8  EF22F4     CLR LATG
0077AA  2FDFF0     MOV #0xFDFF, W0
0077AC  881780     MOV W0, TRISG
0077AE  EF22F6     CLR ODCG
0077B0  EF24EC     CLR ANSG
73:                	SysFlags.word	= 0;
0077B2  EF292C     CLR SysFlags
74:                }
0077B4  060000     RETURN
75:                
76:                
77:                //-------------------------------------------------------------------------------------------------
78:                //	Default PPS configuration after RESET
79:                //-------------------------------------------------------------------------------------------------
80:                void PPSconfig(enum ppsConfig ppsSwitch)
81:                {
82:                //	SistemState = ppsSwitch;
83:                	// Unlock Registers
84:                	__builtin_write_OSCCONL(OSCCONL & 0xbf);
0077B6  207423     MOV #0x742, W3
0077B8  784193     MOV.B [W3], W3
0077BA  B20BF3     AND #0xBF, W3
0077BC  200572     MOV #0x57, W2
0077BE  200461     MOV #0x46, W1
0077C0  207424     MOV #0x742, W4
0077C2  784A01     MOV.B W1, [W4]
0077C4  784A02     MOV.B W2, [W4]
0077C6  784A03     MOV.B W3, [W4]
85:                
86:                	switch (ppsSwitch)
0077C8  E00000     CP0 W0
0077CA  3A0021     BRA NZ, 0x780E
87:                	{
88:                	case pps_system:
89:                		#ifdef UART1_GPS
90:                			_U1RXR	= GPS_RX;		// RB9	< Rx_GPS
91:                			GPS_TX	= IO_U1TX;		// RB8	< Tx_GPS
92:                		#endif
93:                
94:                		#ifdef UART2_GSM
95:                			_U2RXR	= GSM_RX;		// RD2	< Rx_GSM
96:                			GSM_TX	= IO_U2TX;		// RD1	< Tx_GSM
97:                		#endif
98:                
99:                //		_U3RXR		= SET_RX;		// RB6	< Rx_PGC
100:               //		SET_TX		= IO_U3TX;		// RB7	< Tx_PGD
101:                       SET_TX		= IO_PORT;		// RB7	< IO
0077CC  2C0FF0     MOV #0xC0FF, W0
0077CE  B626C6     AND RPOR3
102:                       _U3RXR		= PPS_IN_VSS;	// RB6	< IO
0077D0  803511     MOV RPINR17, W1
0077D2  600101     AND W0, W1, W2
0077D4  21F001     MOV #0x1F00, W1
0077D6  708082     IOR W1, W2, W1
0077D8  883511     MOV W1, RPINR17
103:               		
104:               		#ifdef UART4_WIFI
105:               			_U4RXR	= WIFI_RX;		// RD2	< Rx_WIFI
0077DA  2FFC01     MOV #0xFFC0, W1
0077DC  8035B3     MOV RPINR27, W3
0077DE  608103     AND W1, W3, W2
0077E0  B30252     IOR #0x25, W2
0077E2  8835B2     MOV W2, RPINR27
106:               			WIFI_TX	= IO_U4TX;		// RD1	< Tx_WIFI
0077E4  803623     MOV RPOR2, W3
0077E6  608103     AND W1, W3, W2
0077E8  B301E2     IOR #0x1E, W2
0077EA  883622     MOV W2, RPOR2
107:               		#endif
108:               
109:               		#if     (LCD != LCD_NO)
110:               			LCD_SCK	= IO_SCK1OUT;	// RD11	< SCK1 (LCD)
111:               			LCD_SDA	= IO_SDO1;		// RD0	< SDO1 (LCD)
112:               		#endif
113:               
114:               		#if		(MEMORY1_PORT == SPI_1)
115:               			_SDI1R	= MEM_SI;		// RB14	< SDI1 (MEM)
0077EC  803543     MOV RPINR20, W3
0077EE  608103     AND W1, W3, W2
0077F0  B300E2     IOR #0xE, W2
0077F2  883542     MOV W2, RPINR20
116:               			MEM_SCK	= IO_SCK1OUT;	// RF4	< SCK1 (MEM)
0077F4  803652     MOV RPOR5, W2
0077F6  608082     AND W1, W2, W1
0077F8  A03001     BSET W1, #3
0077FA  883651     MOV W1, RPOR5
117:               			MEM_SO	= IO_SDO1;		// RB15	< SDO1 (MEM)
0077FC  8036E3     MOV RPOR14, W3
0077FE  600103     AND W0, W3, W2
007800  207001     MOV #0x700, W1
007802  708082     IOR W1, W2, W1
007804  8836E1     MOV W1, RPOR14
118:               		#elif	(MEMORY1_PORT == SPI_2)
119:               			_SDI2R	= MEM_SI;		// RB14	< SDI2 (MEM)
120:               			MEM_SCK	= IO_SCK2OUT;	// RF4	< SCK2 (MEM)
121:               			MEM_SO	= IO_SDO2;		// RB15	< SDO2 (MEM)
122:               		#endif
123:               
124:               		PWM_DC		= IO_OC1;		// G9	< PWM for DC_DC_Up
007806  B606DA     AND RPOR13, WREG
007808  212001     MOV #0x1200, W1
00780A  708080     IOR W1, W0, W1
00780C  8836D1     MOV W1, RPOR13
125:               //		PWM			= IO_OC2;		// F5	< PWM for GSM test "sound"
126:               		break;
127:               	default:
128:               		break;
129:               	}
130:               
131:               	// Lock Registers
132:               	__builtin_write_OSCCONL(OSCCONL | 0x40);
00780E  207422     MOV #0x742, W2
007810  784112     MOV.B [W2], W2
007812  A06402     BSET.B W2, #6
007814  FB8102     ZE W2, W2
007816  200571     MOV #0x57, W1
007818  200460     MOV #0x46, W0
00781A  207423     MOV #0x742, W3
00781C  784980     MOV.B W0, [W3]
00781E  784981     MOV.B W1, [W3]
007820  784982     MOV.B W2, [W3]
133:               }
007822  060000     RETURN
134:               
135:               extern void Gsm_Off	(void);
136:               void PowerOff (void)
137:               {
138:               	GPS_POW_OFF();
007824  A942CD     BCLR 0x2CD, #2
139:               	LedStatus1 = LedStatus2 = LedStatus3 = LED_STATUS_ERROR;
007826  2AAAA0     MOV #0xAAAA, W0
007828  8844C0     MOV W0, LedStatus3
00782A  F80898     PUSH LedStatus3
00782C  F90896     POP LedStatus2
00782E  F80896     PUSH LedStatus2
007830  F90894     POP LedStatus1
140:               	Gsm_Off();
007832  07DF47     RCALL Gsm_Off
141:               	FL_POWER_OFF = 0;
007834  A9892D     BCLR 0x92D, #4
142:               	__asm__ ("RESET");	while(1);
007836  FE0000     RESET
007838  37FFFF     BRA 0x7838
143:               }
---  /home/pele/src/Auto_02/src/Memory.c  ---------------------------------------------------------------
1:                 #include	"Memory.h"
2:                 #include	"MemDefines.h"
3:                 #include	"Spi_i2c.h"
4:                 #include	"Timers.h"
5:                 #include	"Ports.h"
6:                 #include	<string.h>
7:                 #include	<stdio.h>
8:                 #if	(TEST == MEMORY_TEST)
9:                 	#include	"Debug.h"
10:                #else
11:                	#define	DebugPrint(X)
12:                #endif
13:                
14:                
15:                #define MEM_TIMEOUT_MS		500
16:                #define MEM_BUFF_MASK		0x3FF
17:                #define MEM_BUFF_SIZE		(MEM_BUFF_MASK + 1)
18:                /*
19:                #if (MEMORY == S25FL512S)
20:                	#define	NEW_WRITE_PAGE		(!(CurrentWriteAddress.u16l & 0x1FF))
21:                	#define	NEW_WRITE_SECTOR	(!(CurrentWriteAddress.u32 & 0x0003FFFF))
22:                #else
23:                //	#define	NEW_WRITE_PAGE		(!(CurrentWriteAddress.u8ll))
24:                //	#define	NEW_WRITE_SECTOR	(!(CurrentWriteAddress.u16l))
25:                	#define	NEW_WRITE_PAGE		(!(CurrentWriteAddress.u16l & PageMask))
26:                	#define	NEW_WRITE_SECTOR	((!CurrentWriteAddress.u16l) && (!(CurrentWriteAddress.u16h & SectorMask)))	
27:                #endif
28:                */
29:                
30:                #define	MEM_CS_ON()				MEM_CS = 0; DELAY_2uS()
31:                #define	MEM_CS_OFF()			DELAY_2uS(); MEM_CS	= 1
32:                #define	MEM_CS_IS_ON()			(!MEM_CS)
33:                #define	MEM_SPI_INIT			Spi1_Init
34:                #define	MEM_IRQ					IRQ_SPI_1
35:                #define	MEM_WRITE_IE			_SPI1IE
36:                #define	MEM_WRITE_IF			_SPI1IF
37:                #define	MEM_WRITE_ACTIVE		_SPI1IE				// if Interrupt enabled -> MemWrite = active
38:                #define	MEM_SPI_BUF_REG			SPI1BUF
39:                #define	MEM_SPI_RX_FIFO_EMPTY	SPI1_RX_FIFO_EMPTY
40:                #define	MEM_SPI_CLEAR			Spi1Clear
41:                #define	MEM_SPI_BYTE			Spi1Byte
42:                #define	MEM_SPI_TX_FULL			SPI1_TX_FULL
43:                
44:                #define	CurrentWriteAddress		ServiceStruct.WriteAddr
45:                #define	ServiceSector			ServiceAddress.u16h
46:                #define	MEM_FLAGS				MemFlags.word
47:                #define	MEM_FLAG_ERASED			MemFlags.flag_0
48:                #define	MEM_FLAG_WRITE_STARTED	MemFlags.flag_1
49:                #define	MEM_FLAG_WRITE_ACTIVE	MemFlags.flag_2
50:                #define	MEM_FLAG_READ_ACTIVE	MemFlags.flag_3
51:                #define	MEM_FLAG_READ_WAIT		MemFlags.flag_4
52:                #define	MEM_FLAG_SERVICE_WRITE	MemFlags.flag_5
53:                typedef struct					tagMEM_STATUS	{
54:                	union
55:                	{
56:                		U8		byte;
57:                		struct
58:                		{
59:                			U8	WIP		:1;
60:                			U8	WEL		:1;
61:                			U8	BP0		:1;
62:                			U8	BP1		:1;
63:                			U8	BP2		:1;
64:                			U8	E_ERR	:1;
65:                			U8	P_ERR	:1;
66:                			U8	SRWD	:1;
67:                		};
68:                	};
69:                } MEM_STATUS;
70:                typedef	struct					tagSERVICE_STR	{
71:                	U8			clear;
72:                	U8			tmp8;
73:                	UNI16		tmp16;
74:                	UNI32		WriteAddr;
75:                } SERVICE_STR;
76:                typedef	volatile enum			tagMEM_STATE	{
77:                	MemState_Idle		= 0,
78:                	MemState_Status,
79:                	MemState_WriteAddress,
80:                	MemState_WriteData,
81:                	MemState_ReadData,
82:                
83:                	MemState_ServiceNull,
84:                	MemState_ServiceSave,
85:                	MemState_ServiceClear,
86:                	MemState_SaveAddress,
87:                	MemState_CsOff,
88:                } MEM_STATE;
89:                static	SERVICE_STR				ServiceStruct;
90:                static	MEM_STATE				MemIrqState;
91:                static	UNI32					CurrentReadAddress, ServiceAddress;
92:                static	UNI32*					pWrAddr;
93:                static	U16						MemTimeOut = 0;
94:                static	FLAGS					MemFlags;
95:                		U8						ManufacturerId = 0, MemoryType = 0, MemoryCapacity = 0;
96:                static	U16						MemType = 0, PageMask = 0, SectorMask = 0;
97:                static	U8						MemBuff[MEM_BUFF_SIZE];
98:                static	U16						MemBuff_in, MemBuff_out;
99:                
100:               void MemReadDeviceId		(void);
101:               void MemCurrentAddrInit		(void);
102:               void Mem_ReadStart			(void);
103:               U8	 Mem_ReadStatus			(U8 wait);
104:               void Mem_WriteStatus		(U8 status);
105:               void Mem_WriteEnable		(void);
106:               void Mem_WriteDisable		(void);
107:               //void Mem_WriteStart			(void);
108:               //void Mem_PageErase			(void);
109:               extern U8	BootFlashNew	(void);
110:               
111:               inline void SpiMemTimer 	(void)	// 100Hz			TODO...!!!!!!!!!!!!!!!!!!
112:               {
113:               	if ((MemTimeOut) && (!--MemTimeOut))
006080  804270     MOV MemTimeOut, W0
006082  E00000     CP0 W0
006084  320005     BRA Z, 0x6090
006086  E90000     DEC W0, W0
006088  884270     MOV W0, MemTimeOut
00608A  3A0002     BRA NZ, 0x6090
114:               	{
115:               		MEM_WRITE_IF = 1;
00608C  A84085     BSET 0x85, #2
116:               		MEM_WRITE_IE = 1;
00608E  A84095     BSET 0x95, #2
117:               	}
118:               /*
119:               #if	(TEST == MEMORY_TEST)
120:               	static U16 testTimer = 3000;
121:               	if (!--testTimer)
122:               	{
123:               		testTimer = 30000;
124:               		DebugPrint("MemTest");
125:               	}
126:               #endif
127:               */
128:               }
006090  060000     RETURN
129:               
130:               MEM_IRQ
006092  F80036     PUSH RCOUNT
006094  BE9F80     MOV.D W0, [W15++]
006096  BE9F82     MOV.D W2, [W15++]
006098  BE9F84     MOV.D W4, [W15++]
00609A  BE9F86     MOV.D W6, [W15++]
00609C  BE9F88     MOV.D W8, [W15++]
00609E  BE9F8A     MOV.D W10, [W15++]
0060A0  A94085     BCLR 0x85, #2
0060A2  A9C240     BCLR SPI1STAT, #6
006218  400168     ADD W0, #0x8, W2
131:               	if		(MemIrqState == MemState_Status)	goto mem_irq_status;
0060A4  8041D0     MOV MemIrqState, W0
0060A6  500FE1     SUB W0, #0x1, [W15]
0060A8  320017     BRA Z, 0x60D8
132:               	else if	(MemIrqState == MemState_WriteData)	goto mem_irq_writeData;
0060AA  8041D0     MOV MemIrqState, W0
0060AC  500FE3     SUB W0, #0x3, [W15]
0060AE  320062     BRA Z, 0x6174
133:               	else if	(MemBuff_in != MemBuff_out)			goto mem_irq_start;
0060B0  804240     MOV MemBuff_out, W0
0060B2  E30846     CP MemBuff_in
0060B4  3A000A     BRA NZ, 0x60CA
134:               	else if (!MemTimeOut)						{
0060B6  E2084E     CP0 MemTimeOut
0060B8  3A00C4     BRA NZ, 0x6242
135:               		MemIrqState = MemState_Idle;
0060BA  EF283A     CLR MemIrqState
136:               		MEM_WRITE_IE		= 0;
0060BC  A94095     BCLR 0x95, #2
137:               		MEM_WRITE_IF		= 1;
0060BE  A84085     BSET 0x85, #2
138:               		MEM_CS_OFF();
0060C0  200200     MOV #0x20, W0
0060C2  200001     MOV #0x0, W1
0060C4  07D173     RCALL ___delay32
0060C6  A8A2CD     BSET 0x2CD, #5
0060C8  3700BC     BRA 0x6242
139:               	}
140:               	return;
141:               mem_irq_start:			{
142:               	MemIrqState = MemState_Status;
0060CA  200010     MOV #0x1, W0
0060CC  8841D0     MOV W0, MemIrqState
143:               	MEM_SPI_CLEAR();
0060CE  070BE7     RCALL Spi1Clear
144:               	MEM_CS_OFF();
0060D0  200200     MOV #0x20, W0
0060D2  200001     MOV #0x0, W1
0060D4  07D16B     RCALL ___delay32
0060D6  A8A2CD     BSET 0x2CD, #5
145:               }
146:               mem_irq_status:			{
147:               	register	MEM_STATUS	status;
148:               	while (true)
149:               	{
150:               		if (!MEM_CS_IS_ON())					// ChipSelect = Hi -> spi not started jet
0060D8  22000B     MOV #0x2000, W11
0060DE  801661     MOV LATB, W1
0060E0  658001     AND W11, W1, W0
0060E2  320006     BRA Z, 0x60F0
151:               		{
152:               			MEM_SPI_CLEAR();
0060E4  070BDC     RCALL Spi1Clear
153:               			MEM_CS_ON();
0060DA  200208     MOV #0x20, W8
0060DC  200009     MOV #0x0, W9
0060E6  A9A2CD     BCLR 0x2CD, #5
0060E8  BE0008     MOV.D W8, W0
0060EA  07D160     RCALL ___delay32
154:               			MEM_SPI_BYTE(MEM_CMD_RDSR);			// Send Status Register Read command
0060EC  B3C050     MOV.B #0x5, W0
0060EE  070BFE     RCALL Spi1Byte
155:               		}
156:               		status.byte = MEM_SPI_BYTE(0);			// Read status
0060F0  EB4000     CLR.B W0
0060F2  070BFC     RCALL Spi1Byte
157:               		if (status.WIP)							// Write in Progress (Memory busy)
0060F4  784500     MOV.B W0, W10
0060F6  A3080A     BTST.Z W10, #0
0060F8  320003     BRA Z, 0x6100
158:               		{
159:               			MemTimeOut = 10;					// check after 100mS
0060FA  2000A0     MOV #0xA, W0
0060FC  884270     MOV W0, MemTimeOut
160:               			return;
0060FE  3700A1     BRA 0x6242
161:               		}
162:               		MEM_CS_OFF();
006100  BE0008     MOV.D W8, W0
006102  07D154     RCALL ___delay32
006104  A8A2CD     BSET 0x2CD, #5
163:               		if (status.WEL)							// Write enabled - device ready to write data
006106  A3180A     BTST.Z W10, #1
006108  3A0009     BRA NZ, 0x611C
164:               			goto mem_irq_writeAddress;
165:               
166:               		MEM_CS_ON();
00610A  A9A2CD     BCLR 0x2CD, #5
00610C  BE0008     MOV.D W8, W0
00610E  07D14E     RCALL ___delay32
167:               		MEM_SPI_BYTE(MEM_CMD_WREN);				// Send Write Enable command
006110  B3C060     MOV.B #0x6, W0
006112  070BEC     RCALL Spi1Byte
168:               		MEM_CS_OFF();
006114  BE0008     MOV.D W8, W0
006116  07D14A     RCALL ___delay32
006118  A8A2CD     BSET 0x2CD, #5
169:               	}
00611A  37FFE1     BRA 0x60DE
170:                }
171:               mem_irq_writeAddress:	{
172:               	MEM_CS_ON();
00611C  A9A2CD     BCLR 0x2CD, #5
00611E  200200     MOV #0x20, W0
006120  200001     MOV #0x0, W1
006122  07D144     RCALL ___delay32
173:               	if (!pWrAddr->u16l)							// New sector check (must be erased before write)
006124  804260     MOV pWrAddr, W0
006126  E00010     CP0 [W0]
006128  3A000C     BRA NZ, 0x6142
174:               	{
175:               		if (MEM_FLAG_ERASED)					// sector already erased
00612A  AB084A     BTST MemFlags, #0
00612C  320002     BRA Z, 0x6132
176:               			MEM_FLAG_ERASED = 0;
00612E  A9084A     BCLR MemFlags, #0
006130  370008     BRA 0x6142
177:               		else if ((MemType < MEM_SECTORS_S25FL512S) || (!(pWrAddr->u16h & SectorMask)))
006132  203FF1     MOV #0x3FF, W1
006134  804202     MOV MemType, W2
006136  510F81     SUB W2, W1, [W15]
006138  36005A     BRA LEU, 0x61EE
00613A  900090     MOV [W0+2], W1
00613C  804222     MOV SectorMask, W2
00613E  608082     AND W1, W2, W1
006140  320056     BRA Z, 0x61EE
178:               			goto mem_irq_eraseSector;
179:               	}
180:               
181:               	if (pWrAddr->u8hh)
006142  804260     MOV pWrAddr, W0
006144  904030     MOV.B [W0+3], W0
006146  E00400     CP0.B W0
006148  320005     BRA Z, 0x6154
182:               	{
183:               		MEM_SPI_BUF_REG = MEM_CMD_4PP;
00614A  200121     MOV #0x12, W1
00614C  881241     MOV W1, SPI1BUF
184:               		MEM_SPI_BUF_REG = pWrAddr->u8hh;
00614E  FB8000     ZE W0, W0
006150  881240     MOV W0, SPI1BUF
006152  370002     BRA 0x6158
185:               	}
186:               	else
187:               		MEM_SPI_BUF_REG = MEM_CMD_PP;
006154  200020     MOV #0x2, W0
006156  881240     MOV W0, SPI1BUF
188:               	MEM_SPI_BUF_REG = pWrAddr->u8hl;
006158  804260     MOV pWrAddr, W0
00615A  9040A0     MOV.B [W0+2], W1
00615C  FB8081     ZE W1, W1
00615E  881241     MOV W1, SPI1BUF
189:               	MEM_SPI_BUF_REG = pWrAddr->u8lh;
006160  904090     MOV.B [W0+1], W1
006162  FB8081     ZE W1, W1
006164  881241     MOV W1, SPI1BUF
190:               	MEM_SPI_BUF_REG = pWrAddr->u8ll;
006166  FB8010     ZE [W0], W0
006168  881240     MOV W0, SPI1BUF
191:               	if (MEM_FLAG_SERVICE_WRITE)
00616A  ABA84A     BTST MemFlags, #5
00616C  3A0052     BRA NZ, 0x6212
192:               		goto mem_irq_serviceSector;
193:               	MemIrqState = MemState_WriteData;
00616E  200030     MOV #0x3, W0
006170  8841D0     MOV W0, MemIrqState
194:               	MEM_SPI_CLEAR();
006172  070B95     RCALL Spi1Clear
195:                }
196:               mem_irq_writeData:		{
197:               	while (!MEM_SPI_TX_FULL)
006174  AB2240     BTST SPI1STAT, #1
006176  3A0065     BRA NZ, 0x6242
0061E0  AB2240     BTST SPI1STAT, #1
0061E2  32FFD9     BRA Z, 0x6196
0061E4  884242     MOV W2, MemBuff_out
0061E6  B7E832     MOV.B WREG, 0x832
0061E8  2000A0     MOV #0xA, W0
0061EA  884270     MOV W0, MemTimeOut
0061EC  37002A     BRA 0x6242
198:               	{
199:               		if (MemBuff_in == MemBuff_out)
006178  804231     MOV MemBuff_in, W1
00617A  804240     MOV MemBuff_out, W0
00617C  508F80     SUB W1, W0, [W15]
00617E  320012     BRA Z, 0x61A4
006196  508F82     SUB W1, W2, [W15]
006198  3A000B     BRA NZ, 0x61B0
00619A  884242     MOV W2, MemBuff_out
00619C  B7E832     MOV.B WREG, 0x832
00619E  2000A0     MOV #0xA, W0
0061A0  884270     MOV W0, MemTimeOut
0061A2  37004F     BRA 0x6242
200:               		{
201:               			if (!MemTimeOut)
0061A4  E2084E     CP0 MemTimeOut
0061A6  3A004D     BRA NZ, 0x6242
202:               			{
203:               				MEM_FLAG_SERVICE_WRITE = 1;
0061A8  A8A84A     BSET MemFlags, #5
204:               				pWrAddr = &ServiceAddress;
0061AA  2083C0     MOV #0x83C, W0
0061AC  884260     MOV W0, pWrAddr
205:               				goto mem_irq_start;
0061AE  37FF8D     BRA 0x60CA
206:               			}
207:               			return;
208:               		}
209:               		else
210:               		{
211:               			MEM_SPI_BUF_REG = MemBuff[MemBuff_out];
006180  227942     MOV #0x2794, W2
006182  784162     MOV.B [W2+W0], W2
006184  FB8102     ZE W2, W2
006186  881242     MOV W2, SPI1BUF
0061B0  7941E5     MOV.B [W5+W2], W3
0061B2  FB8183     ZE W3, W3
0061B4  881243     MOV W3, SPI1BUF
0061DC  227945     MOV #0x2794, W5
212:               			MemBuff_out = (MemBuff_out + 1) & MEM_BUFF_MASK;
006188  E80000     INC W0, W0
00618A  B23FF0     AND #0x3FF, W0
00618C  884240     MOV W0, MemBuff_out
0061B6  E80102     INC W2, W2
0061B8  610104     AND W2, W4, W2
0061BA  E84000     INC.B W0, W0
0061DE  203FF4     MOV #0x3FF, W4
213:               			if (!(++CurrentWriteAddress.u8ll))
00618E  EC4832     INC.B 0x832, WREG
006190  B7E832     MOV.B WREG, 0x832
006192  3A0023     BRA NZ, 0x61DA
006194  370018     BRA 0x61C6
0061BC  3A0011     BRA NZ, 0x61E0
0061BE  884242     MOV W2, MemBuff_out
0061C0  B7E832     MOV.B WREG, 0x832
0061C2  2000A0     MOV #0xA, W0
0061C4  884270     MOV W0, MemTimeOut
214:               			{
215:               				if ((++CurrentWriteAddress.u8lh == 0)	&&
0061C6  EC4833     INC.B 0x833, WREG
0061C8  B7E833     MOV.B WREG, 0x833
0061CA  3AFF7F     BRA NZ, 0x60CA
0061CE  8841A0     MOV W0, 0x834
0061D0  E3083E     CP 0x83E
0061D2  3EFF7B     BRA GTU, 0x60CA
216:               					(++CurrentWriteAddress.u16h >= ServiceSector)	)
0061CC  EC0834     INC 0x834, WREG
217:               					CurrentWriteAddress.u32 = 0;
0061D4  EF2832     CLR 0x832
0061D6  EF2834     CLR 0x834
0061D8  37FF78     BRA 0x60CA
0061DA  804242     MOV MemBuff_out, W2
218:               				
219:               				goto mem_irq_start;
220:               			}
221:               			MemTimeOut		= MEM_SPI_TIMEOUT;
222:               		}
223:               	}
224:               	return;
225:                }
226:               mem_irq_eraseSector:	{
227:               	if (pWrAddr->u8hh)
0061EE  904030     MOV.B [W0+3], W0
0061F0  E00400     CP0.B W0
0061F2  320005     BRA Z, 0x61FE
228:               	{
229:               		MEM_SPI_BUF_REG = MEM_CMD_4SE;
0061F4  200DC1     MOV #0xDC, W1
0061F6  881241     MOV W1, SPI1BUF
230:               		MEM_SPI_BUF_REG = pWrAddr->u8hh;
0061F8  FB8000     ZE W0, W0
0061FA  881240     MOV W0, SPI1BUF
0061FC  370002     BRA 0x6202
231:               	}
232:               	else
233:               		MEM_SPI_BUF_REG = MEM_CMD_SE;
0061FE  200D80     MOV #0xD8, W0
006200  881240     MOV W0, SPI1BUF
234:               	MEM_SPI_BUF_REG = pWrAddr->u8hl;
006202  804260     MOV pWrAddr, W0
006204  904020     MOV.B [W0+2], W0
006206  FB8000     ZE W0, W0
006208  881240     MOV W0, SPI1BUF
235:               	MEM_SPI_BUF_REG = 0;
00620A  EF2248     CLR SPI1BUF
236:               	MEM_SPI_BUF_REG = 0;
00620C  EF2248     CLR SPI1BUF
237:               
238:               	MEM_FLAG_ERASED	= 1;				// set Flag to avoid second erase of same sector
00620E  A8084A     BSET MemFlags, #0
239:               	goto mem_irq_start;
006210  37FF5C     BRA 0x60CA
240:                }
241:               mem_irq_serviceSector:	{
242:               	register U8* ptr	= (U8*)&ServiceStruct;
243:               	register U16 i		= sizeof(SERVICE_STR);
244:               	ServiceAddress.u16l += i;
006212  200080     MOV #0x8, W0
006214  B4283C     ADD ServiceAddress
006216  2082E0     MOV #0x82E, W0
245:               	while (i--)
006222  500F82     SUB W0, W2, [W15]
006224  3AFFFA     BRA NZ, 0x621A
246:               	{
247:               		while (MEM_SPI_TX_FULL);
00621A  AB2240     BTST SPI1STAT, #1
00621C  3AFFFE     BRA NZ, 0x621A
248:               		MEM_SPI_BUF_REG = *ptr++;
00621E  FB80B0     ZE [W0++], W1
006220  881241     MOV W1, SPI1BUF
249:               	}
250:               	pWrAddr = &ServiceStruct.WriteAddr;
006226  208320     MOV #0x832, W0
006228  884260     MOV W0, pWrAddr
251:               	MEM_FLAG_SERVICE_WRITE = 0;
00622A  A9A84A     BCLR MemFlags, #5
252:               	if (MemBuff_in != MemBuff_out)
00622C  804240     MOV MemBuff_out, W0
00622E  E30846     CP MemBuff_in
006230  3AFF4C     BRA NZ, 0x60CA
253:               		goto mem_irq_start;
254:               
255:               	MemIrqState = MemState_Idle;
006232  EF283A     CLR MemIrqState
256:               	MEM_SPI_CLEAR();
006234  070B34     RCALL Spi1Clear
257:               	MEM_CS_OFF();
006236  200200     MOV #0x20, W0
006238  200001     MOV #0x0, W1
00623A  07D0B8     RCALL ___delay32
00623C  A8A2CD     BSET 0x2CD, #5
258:               	MEM_WRITE_IE = 0;
00623E  A94095     BCLR 0x95, #2
259:               	MEM_WRITE_IF = 1;
006240  A84085     BSET 0x85, #2
260:               	return;
261:                }
262:               }
006242  BE054F     MOV.D [--W15], W10
006244  BE044F     MOV.D [--W15], W8
006246  BE034F     MOV.D [--W15], W6
006248  BE024F     MOV.D [--W15], W4
00624A  BE014F     MOV.D [--W15], W2
00624C  BE004F     MOV.D [--W15], W0
00624E  F90036     POP RCOUNT
006250  064000     RETFIE
263:               //	--	Public Functions	------------------------------------------------------------
264:               void MemInit (void)
265:               {
266:               	MEM_CS		= 1;				// MEM_CS_OFF();
00647C  A8A2CD     BSET 0x2CD, #5
267:               	MEM_FLAGS	= 0;
00647E  EF284A     CLR MemFlags
268:               	MemBuff_in	= MemBuff_out = 0;
006480  EF2848     CLR MemBuff_out
006482  EF2846     CLR MemBuff_in
269:               	pWrAddr = &ServiceStruct.WriteAddr;
006484  208320     MOV #0x832, W0
006486  884260     MOV W0, pWrAddr
270:               	MEM_SPI_INIT();
006488  0709D8     RCALL Spi1_Init
271:               	MemIrqState = MemState_Idle;
00648A  EF283A     CLR MemIrqState
272:               	MemReadDeviceId();
00648C  07FF58     RCALL MemReadDeviceId
273:               	MemCurrentAddrInit();
00648E  07FFAD     RCALL MemCurrentAddrInit
274:               }
006490  060000     RETURN
275:               
276:               void Mem_SetWriteAddress	(U32 addr)
277:               {
006252  FA003C     LNK #0x3C
006254  BE9F88     MOV.D W8, [W15++]
006256  BE0300     MOV.D W0, W6
278:               	while (MEM_WRITE_IE)	// wait if write process active
006260  204002     MOV #0x400, W2
006262  370005     BRA 0x626E
00626E  8004A0     MOV IEC0, W0
006270  610080     AND W2, W0, W1
006272  3AFFF8     BRA NZ, 0x6264
279:               	{
280:               		if ((MemBuff_in == MemBuff_out)		&&
006258  804234     MOV MemBuff_in, W4
00625A  804243     MOV MemBuff_out, W3
006264  520F83     SUB W4, W3, [W15]
006266  3A0003     BRA NZ, 0x626E
006268  540F86     SUB W8, W6, [W15]
00626A  5C8F87     SUBB W9, W7, [W15]
00626C  320019     BRA Z, 0x62A0
281:               			(CurrentWriteAddress.u32 == addr)	)
00625C  804198     MOV 0x832, W8
00625E  8041A9     MOV 0x834, W9
282:               			return;
283:               	}
284:               	CurrentWriteAddress.u32	= addr;
006274  2082E0     MOV #0x82E, W0
006276  980026     MOV W6, [W0+4]
006278  980037     MOV W7, [W0+6]
285:               	if (CurrentWriteAddress.u16h >= ServiceSector)
00627A  900030     MOV [W0+6], W0
00627C  E3083E     CP 0x83E
00627E  3E0002     BRA GTU, 0x6284
286:               		CurrentWriteAddress.u32	= 0;
006280  EF2832     CLR 0x832
006282  EF2834     CLR 0x834
287:               	#if	(TEST == MEMORY_TEST)
288:               		char tmp[60];
289:               		sprintf(tmp, "New Write Addr: 0x%X%04X", CurrentWriteAddress.u16h, CurrentWriteAddress.u16l);
006284  2082E0     MOV #0x82E, W0
006286  9000A0     MOV [W0+4], W1
006288  781F81     MOV W1, [W15++]
00628A  900030     MOV [W0+6], W0
00628C  781F80     MOV W0, [W15++]
00628E  2B5180     MOV #0xB518, W0
006290  781F80     MOV W0, [W15++]
006292  2FFBA0     MOV #0xFFBA, W0
006294  40000F     ADD W0, W15, W0
006296  07D88A     RCALL __sprintf_cdnopuxX, __sprintf_s, __sprintf_0, __sprintf_cdnopsuxX
290:               		DebugPrint(tmp);
006298  2FFBA0     MOV #0xFFBA, W0
00629A  40000F     ADD W0, W15, W0
00629C  07F810     RCALL Usb_SendText
00629E  5787E6     SUB W15, #0x6, W15
291:               	#endif
292:               //	MEM_FLAG_SERVICE_WRITE = 1;
293:               //	pWrAddr		= &ServiceAddress;
294:               //	MemIrqState	= MemState_Status;
295:               //	MEM_WRITE_IE = 1;
296:               }
0062A0  BE044F     MOV.D [--W15], W8
0062A2  FA8000     ULNK
0062A4  060000     RETURN
297:               
298:               void Mem_SetReadAddress		(U32 addr)
299:               {
0062A6  FA003C     LNK #0x3C
300:               	if (CurrentReadAddress.u32	!= addr)
0062A8  8041B2     MOV CurrentReadAddress, W2
0062AA  8041C3     MOV 0x838, W3
0062AC  510F80     SUB W2, W0, [W15]
0062AE  598F81     SUBB W3, W1, [W15]
0062B0  320007     BRA Z, 0x62C0
301:               	{
302:               		if (MemIrqState == MemState_ReadData)		// if Read process active
0062B2  8041D2     MOV MemIrqState, W2
0062B4  510FE4     SUB W2, #0x4, [W15]
0062B6  3A0002     BRA NZ, 0x62BC
303:               		{											// stop read to init read from new address
304:               			MemIrqState = MemState_Idle;			// in next read
0062B8  EF283A     CLR MemIrqState
305:               			MEM_CS		= 1;						// MEM_CS_OFF();
0062BA  A8A2CD     BSET 0x2CD, #5
306:               		}
307:               		CurrentReadAddress.u32	= addr;
0062BC  8841B0     MOV W0, CurrentReadAddress
0062BE  8841C1     MOV W1, 0x838
308:               	}
309:               	#if	(TEST == MEMORY_TEST)
310:               		char tmp[60];
311:               		sprintf(tmp, "New Read Addr: 0x%X%04X", CurrentReadAddress.u16h, CurrentReadAddress.u16l);
0062C0  F80836     PUSH CurrentReadAddress
0062C2  F80838     PUSH 0x838
0062C4  2B5310     MOV #0xB531, W0
0062C6  781F80     MOV W0, [W15++]
0062C8  2FFBE0     MOV #0xFFBE, W0
0062CA  40000F     ADD W0, W15, W0
0062CC  07D86F     RCALL __sprintf_cdnopuxX, __sprintf_s, __sprintf_0, __sprintf_cdnopsuxX
312:               		DebugPrint(tmp);
0062CE  2FFBE0     MOV #0xFFBE, W0
0062D0  40000F     ADD W0, W15, W0
0062D2  07F7F5     RCALL Usb_SendText
0062D4  5787E6     SUB W15, #0x6, W15
313:               	#endif
314:               }
0062D6  FA8000     ULNK
0062D8  060000     RETURN
315:               
316:               U32	 Mem_GetWriteAddress	(void)
317:               {
318:               	return	CurrentWriteAddress.u32;
319:               }
0062DA  804190     MOV 0x832, W0
0062DC  8041A1     MOV 0x834, W1
0062DE  060000     RETURN
320:               
321:               U32	 Mem_GetReadAddress		(void)
322:               {
323:               	return	CurrentReadAddress.u32;
324:               }
0062E0  8041B0     MOV CurrentReadAddress, W0
0062E2  8041C1     MOV 0x838, W1
0062E4  060000     RETURN
325:               
326:               U16	 Mem_GetType			(void)
327:               {
328:               	return	MemType;
329:               }
0062E6  804200     MOV MemType, W0
0062E8  060000     RETURN
330:               
331:               // Write one byte to memory (save in spi buffer & enable spi interrupt)
332:               // ret = 0:		Ok
333:               // ret = -1:	Nok - spi buffer full, try again later
334:               inline S8	Mem_WriteByte	(U8 data)
335:               {
0062EA  784100     MOV.B W0, W2
336:               	register U16 next = (MemBuff_in + 1) & MEM_BUFF_MASK;
0062EC  804231     MOV MemBuff_in, W1
0062EE  E80001     INC W1, W0
0062F0  B23FF0     AND #0x3FF, W0
337:               	if (next == MemBuff_out)					// previous data not sent
0062F2  E30848     CP MemBuff_out
0062F4  3A0006     BRA NZ, 0x6302
338:               	{
339:               		DebugPrint("Write buffer full");
0062F6  2B5490     MOV #0xB549, W0
0062F8  07F7E2     RCALL Usb_SendText
340:               		MEM_WRITE_IF	= 1;
0062FA  A84085     BSET 0x85, #2
341:               		MEM_WRITE_IE	= 1;
0062FC  A84095     BSET 0x95, #2
342:               		return -1;
0062FE  EBC000     SETM.B W0
006300  370005     BRA 0x630C
343:               	}
344:               	MemBuff[MemBuff_in]	= data;					// feel buffer
006302  227943     MOV #0x2794, W3
006304  78F182     MOV.B W2, [W3+W1]
345:               	MemBuff_in			= next;					// next address in buffer
006306  884230     MOV W0, MemBuff_in
346:               //	MEM_WRITE_IF	= 1;
347:               	MEM_WRITE_IE		= 1;					// enable irq
006308  A84095     BSET 0x95, #2
348:               	return 0;
00630A  EB4000     CLR.B W0
349:               }
00630C  060000     RETURN
350:               
351:               // Write one byte to memory (save in spi buffer & enable spi interrupt)
352:               // note: no return while not sucess (write buffer full) 
353:               // ret = -1:	Nok - spi buffer full, try again later
354:               inline void	Mem_WriteByte_1	(U8 data)
355:               {
00630E  784180     MOV.B W0, W3
356:               	register U16 next = (MemBuff_in + 1) & MEM_BUFF_MASK;
006310  804231     MOV MemBuff_in, W1
006312  E80001     INC W1, W0
006314  B23FF0     AND #0x3FF, W0
357:               	while (next == MemBuff_out)					// previous data not sent
006316  E30848     CP MemBuff_out
006318  3A0003     BRA NZ, 0x6320
358:               	{
359:               		MEM_WRITE_IF	= 1;
00631A  A84085     BSET 0x85, #2
00632A  A84085     BSET 0x85, #2
360:               		MEM_WRITE_IE	= 1;
00631C  A84095     BSET 0x95, #2
00631E  370005     BRA 0x632A
00632C  A84095     BSET 0x95, #2
00632E  37FFFD     BRA 0x632A
361:               	}
362:               	MemBuff[MemBuff_in]	= data;					// feel buffer
006320  227942     MOV #0x2794, W2
006322  78F103     MOV.B W3, [W2+W1]
363:               	MemBuff_in			= next;					// next address in buffer
006324  884230     MOV W0, MemBuff_in
364:               //	MEM_WRITE_IF	= 1;
365:               	MEM_WRITE_IE		= 1;					// enable irq
006326  A84095     BSET 0x95, #2
366:               }
006328  060000     RETURN
00632A  A84085     BSET 0x85, #2
00632C  A84095     BSET 0x95, #2
00632E  37FFFD     BRA 0x632A
367:               
368:               inline U8	 MemStatus	(void)
369:               {
370:               	return (MemBuff_in == MemBuff_out)?	0 : 1;
006330  804230     MOV MemBuff_in, W0
006332  B68848     XOR MemBuff_out, WREG
006334  A7F000     BTSC W0, #15
006336  EA0000     NEG W0, W0
006338  EA0000     NEG W0, W0
00633A  DE004F     LSR W0, #15, W0
371:               }
00633C  060000     RETURN
372:               // Read one byte from memory by 'CurrentReadAddress'
373:               // ret = 0:		Ok	- data in *ptr
374:               // ret = 1: 	Ok	- data in *ptr, memory roll ower to '0'
375:               // ret = -1:	Nok	- cann't read data, write process active
376:               inline S8	Mem_ReadByte	(U8* ptr)
377:               {
00651A  781F88     MOV W8, [W15++]
00651C  780400     MOV W0, W8
378:               	if (MEM_WRITE_ACTIVE)
00651E  AB4095     BTST 0x95, #2
006520  320004     BRA Z, 0x652A
379:               	{
380:               		DebugPrint("Write active");
006522  2B55B0     MOV #0xB55B, W0
006524  07F6CC     RCALL Usb_SendText
381:               		return -1;
006526  EBC000     SETM.B W0
006528  370019     BRA 0x655C
382:               	}
383:               	if (MemIrqState != MemState_ReadData)
00652A  8041D0     MOV MemIrqState, W0
00652C  500FE4     SUB W0, #0x4, [W15]
00652E  320001     BRA Z, 0x6532
384:               		Mem_ReadStart();
006530  07FFD1     RCALL Mem_ReadStart
385:               	while (MEM_SPI_RX_FIFO_EMPTY);
006532  200201     MOV #0x20, W1
006534  801202     MOV SPI1STAT, W2
006536  608002     AND W1, W2, W0
006538  3AFFFD     BRA NZ, 0x6534
386:               	*ptr = MEM_SPI_BUF_REG;
00653A  801240     MOV SPI1BUF, W0
00653C  784C00     MOV.B W0, [W8]
387:               	MEM_SPI_BUF_REG = 0;
00653E  EF2248     CLR SPI1BUF
388:               	if ((!++CurrentReadAddress.u16l) && (++CurrentReadAddress.u16h >= ServiceSector))
006540  8041B1     MOV CurrentReadAddress, W1
006542  E80081     INC W1, W1
006544  8841B1     MOV W1, CurrentReadAddress
006548  3A0009     BRA NZ, 0x655C
00654A  8041C1     MOV 0x838, W1
00654C  E80081     INC W1, W1
00654E  8841C1     MOV W1, 0x838
006550  8041F2     MOV 0x83E, W2
006552  510F81     SUB W2, W1, [W15]
006554  3E0003     BRA GTU, 0x655C
389:               	{
390:               		CurrentReadAddress.u16h = 0;
006556  EF2838     CLR 0x838
391:               		MemIrqState	= MemState_Idle;
006558  EF283A     CLR MemIrqState
392:               		return 1;
00655A  B3C010     MOV.B #0x1, W0
393:               	}
394:               	return 0;
006546  EB4000     CLR.B W0
395:               }
00655C  78044F     MOV [--W15], W8
00655E  060000     RETURN
396:               
397:               /*
398:               U8 Mem_ReadByte			(void)
399:               {
400:               	if (!MEM_FLAG_READ_ACTIVE)
401:               		Mem_ReadStart();
402:               	register U8 data = SPI1BUF;
403:               	SPI1BUF = 0;
404:               	CurrentReadAddress.u32++;
405:               	return data;
406:               }
407:               
408:               void Mem_WriteEnd			(void)
409:               {
410:               	MEM_FLAG_WRITE_ACTIVE	= 0;
411:               	Spi1Clear();
412:               	MEM_CS_OFF();
413:               }
414:               */
415:               //	--	Internal Functions	------------------------------------------------------------
416:               void MemReadDeviceId		(void)
417:               {
00633E  BE9F88     MOV.D W8, [W15++]
006340  781F8A     MOV W10, [W15++]
418:               	register U8 Id, Type, Capacity;
419:               	MEM_SPI_CLEAR();
006342  070AAD     RCALL Spi1Clear
420:               	MEM_CS_ON();
006344  A9A2CD     BCLR 0x2CD, #5
006346  200200     MOV #0x20, W0
006348  200001     MOV #0x0, W1
00634A  07D030     RCALL ___delay32
421:               	MEM_SPI_BYTE(MEM_CMD_RDID);
00634C  B3C9F0     MOV.B #0x9F, W0
00634E  070ACE     RCALL Spi1Byte
422:               	Id			= MEM_SPI_BYTE(0);
006350  EB4000     CLR.B W0
006352  070ACC     RCALL Spi1Byte
006354  784400     MOV.B W0, W8
423:               	Type		= MEM_SPI_BYTE(0);
006356  EB4000     CLR.B W0
006358  070AC9     RCALL Spi1Byte
00635A  784480     MOV.B W0, W9
424:               	Capacity	= MEM_SPI_BYTE(0);
00635C  EB4000     CLR.B W0
00635E  070AC6     RCALL Spi1Byte
006360  784500     MOV.B W0, W10
425:               	MEM_CS_OFF();
006362  200200     MOV #0x20, W0
006364  200001     MOV #0x0, W1
006366  07D022     RCALL ___delay32
006368  A8A2CD     BSET 0x2CD, #5
426:               
427:               	if	(	(Id == 0x01) &&	(Type == 0x02) &&	(Capacity == 0x20)	)	MemType = MEM_SECTORS_S25FL512S;
00636A  544FE1     SUB.B W8, #0x1, [W15]
00636C  3A0008     BRA NZ, 0x637E
00636E  54CFE2     SUB.B W9, #0x2, [W15]
006370  3A0006     BRA NZ, 0x637E
006372  B3C200     MOV.B #0x20, W0
006374  554F80     SUB.B W10, W0, [W15]
006376  3A001A     BRA NZ, 0x63AC
006378  204000     MOV #0x400, W0
00637A  884200     MOV W0, MemType
00637C  37002D     BRA 0x63D8
428:               	else if	(Id == 0x20)
00637E  B3C200     MOV.B #0x20, W0
006380  544F80     SUB.B W8, W0, [W15]
006382  3A0014     BRA NZ, 0x63AC
429:               	{
430:               		if					(Type == 0x20)
006384  54CF80     SUB.B W9, W0, [W15]
006386  3A000A     BRA NZ, 0x639C
431:               		{
432:               			if									(Capacity == 0x16)		MemType = MEM_SECTORS_MP25P32;
006388  554FF6     SUB.B W10, #0x16, [W15]
00638A  3A0003     BRA NZ, 0x6392
00638C  200400     MOV #0x40, W0
00638E  884200     MOV W0, MemType
006390  370017     BRA 0x63C0
433:               			else if								(Capacity == 0x17)		MemType = MEM_SECTORS_MP25P64;
006392  554FF7     SUB.B W10, #0x17, [W15]
006394  3A000B     BRA NZ, 0x63AC
006396  200800     MOV #0x80, W0
006398  884200     MOV W0, MemType
00639A  370018     BRA 0x63CC
434:               		}
435:               		else if	(			(Type == 0xBA) &&	(Capacity == 0x16)	)	MemType = MEM_SECTORS_MP25P32;
00639C  B3CBA0     MOV.B #0xBA, W0
00639E  54CF80     SUB.B W9, W0, [W15]
0063A0  3A0005     BRA NZ, 0x63AC
0063A2  554FF6     SUB.B W10, #0x16, [W15]
0063A4  3A0003     BRA NZ, 0x63AC
0063A6  200400     MOV #0x40, W0
0063A8  884200     MOV W0, MemType
0063AA  37000A     BRA 0x63C0
436:               	}	
437:               	switch (MemType)
0063AC  804200     MOV MemType, W0
0063AE  200801     MOV #0x80, W1
0063B0  500F81     SUB W0, W1, [W15]
0063B2  32000C     BRA Z, 0x63CC
0063B4  B03801     ADD #0x380, W1
0063B6  500F81     SUB W0, W1, [W15]
0063B8  32000F     BRA Z, 0x63D8
0063BA  200401     MOV #0x40, W1
0063BC  500F81     SUB W0, W1, [W15]
0063BE  3A0012     BRA NZ, 0x63E4
438:               	{
439:               		case MEM_SECTORS_MP25P32:		ServiceSector = (MEM_SECTORS_MP25P32	- 1);PageMask = 0x00FF;	SectorMask = 0x0000;	break;
0063C0  2003F0     MOV #0x3F, W0
0063C2  8841F0     MOV W0, 0x83E
0063C4  200FF0     MOV #0xFF, W0
0063C6  884210     MOV W0, PageMask
0063C8  EF2844     CLR SectorMask
0063CA  37000C     BRA 0x63E4
440:               		case MEM_SECTORS_MP25P64:		ServiceSector = (MEM_SECTORS_MP25P64	- 1);PageMask = 0x00FF;	SectorMask = 0x0000;	break;
0063CC  2007F0     MOV #0x7F, W0
0063CE  8841F0     MOV W0, 0x83E
0063D0  200FF0     MOV #0xFF, W0
0063D2  884210     MOV W0, PageMask
0063D4  EF2844     CLR SectorMask
0063D6  370006     BRA 0x63E4
441:               		case MEM_SECTORS_S25FL512S:		ServiceSector = (MEM_SECTORS_S25FL512S	- 4);PageMask = 0x01FF;	SectorMask = 0x0003;	break;
0063D8  203FC0     MOV #0x3FC, W0
0063DA  8841F0     MOV W0, 0x83E
0063DC  201FF0     MOV #0x1FF, W0
0063DE  884210     MOV W0, PageMask
0063E0  200030     MOV #0x3, W0
0063E2  884220     MOV W0, SectorMask
442:               		default:						/* ERROR	*/								break;
443:               	}
444:               }
0063E4  78054F     MOV [--W15], W10
0063E6  BE044F     MOV.D [--W15], W8
0063E8  060000     RETURN
445:               
446:               void MemCurrentAddrInit		(void)
00642E  430267     ADD W6, #0x7, W4
447:               {
448:               	memset((char*)&ServiceStruct, 0, sizeof(ServiceStruct));
0063EA  2082E0     MOV #0x82E, W0
0063EC  090003     REPEAT #0x3
0063EE  EB1800     CLR [W0++]
449:               	ServiceAddress.u16l = 0;
0063F0  EF283C     CLR ServiceAddress
450:               	MEM_SPI_CLEAR();
0063F2  070A55     RCALL Spi1Clear
451:               	MEM_CS_OFF();
0063F4  200200     MOV #0x20, W0
0063F6  200001     MOV #0x0, W1
0063F8  07CFD9     RCALL ___delay32
0063FA  A8A2CD     BSET 0x2CD, #5
452:               	MEM_CS_ON();
0063FC  A9A2CD     BCLR 0x2CD, #5
0063FE  200200     MOV #0x20, W0
006400  200001     MOV #0x0, W1
006402  07CFD4     RCALL ___delay32
453:               	if (ServiceAddress.u8hh)
006404  BFC83F     MOV.B 0x83F, WREG
006406  320005     BRA Z, 0x6412
454:               	{
455:               		MEM_SPI_BUF_REG = MEM_CMD_4READ;
006408  200131     MOV #0x13, W1
00640A  881241     MOV W1, SPI1BUF
456:               		MEM_SPI_BUF_REG = ServiceAddress.u8hh;
00640C  FB8000     ZE W0, W0
00640E  881240     MOV W0, SPI1BUF
006410  370002     BRA 0x6416
457:               	}
458:               	else
459:               		MEM_SPI_BUF_REG = MEM_CMD_READ;
006412  200030     MOV #0x3, W0
006414  881240     MOV W0, SPI1BUF
460:               	MEM_SPI_BUF_REG = ServiceAddress.u8hl;
006416  BFC83E     MOV.B 0x83E, WREG
006418  FB8000     ZE W0, W0
00641A  881240     MOV W0, SPI1BUF
461:               	MEM_SPI_BUF_REG = 0;
00641C  EF2248     CLR SPI1BUF
462:               	MEM_SPI_BUF_REG = 0;
00641E  EF2248     CLR SPI1BUF
463:               	MEM_SPI_CLEAR();
006420  070A3E     RCALL Spi1Clear
464:               	MEM_SPI_BUF_REG = 0;
006422  EF2248     CLR SPI1BUF
465:               	MEM_SPI_BUF_REG = 0;
006424  EF2248     CLR SPI1BUF
006426  8041E5     MOV ServiceAddress, W5
466:               	while (true)
467:               	{
468:               		while (MEM_SPI_RX_FIFO_EMPTY);
006428  200201     MOV #0x20, W1
006430  801202     MOV SPI1STAT, W2
006432  608002     AND W1, W2, W0
006434  3AFFFD     BRA NZ, 0x6430
469:               		register U8	i = MEM_SPI_BUF_REG;				// read 1st byte
006436  801240     MOV SPI1BUF, W0
470:               		if (i == 0xFF)									// 0xFF -> current area not saved:
006438  404FE1     ADD.B W0, #0x1, [W15]
00643A  3A0002     BRA NZ, 0x6440
00643C  8841E5     MOV W5, ServiceAddress
00643E  370011     BRA 0x6462
471:               			break;										// previously readed area = actual service sector (or cleared sector if memory is clear)
472:               		MEM_SPI_BUF_REG = 0;							// initiate next spi transfer
00642A  EB0180     CLR W3
006440  881243     MOV W3, SPI1BUF
473:               		register U8* ptr	= (U8*)&ServiceStruct;		// ptr = start of service sector
474:               		*ptr++ = i;										// save already readed byte
00642C  2082F6     MOV #0x82F, W6
006442  B7E82E     MOV.B WREG, ServiceStruct
006444  780106     MOV W6, W2
475:               		
476:               		for (i = 1; i < sizeof(ServiceStruct); i++)		// read all structure
006452  510F84     SUB W2, W4, [W15]
006454  3AFFF8     BRA NZ, 0x6446
006456  4282E8     ADD W5, #0x8, W5
477:               		{
478:               			while (MEM_SPI_RX_FIFO_EMPTY);
006446  801207     MOV SPI1STAT, W7
006448  608007     AND W1, W7, W0
00644A  3AFFFD     BRA NZ, 0x6446
479:               			*ptr++ = MEM_SPI_BUF_REG;
00644C  801240     MOV SPI1BUF, W0
00644E  785900     MOV.B W0, [W2++]
480:               			MEM_SPI_BUF_REG = 0;
006450  881243     MOV W3, SPI1BUF
481:               		}
482:               		ServiceAddress.u16l += i;						// set service address to next free area
483:               		if (!ServiceAddress.u16l)						// if address returned around - error
006458  3AFFEB     BRA NZ, 0x6430
00645A  8841E5     MOV W5, ServiceAddress
484:               		{												// memory is defective - define as clear (will be cleared at first time of writing)
485:               			memset((char*)&ServiceStruct, 0, sizeof(ServiceStruct));
00645C  2082E0     MOV #0x82E, W0
00645E  090003     REPEAT #0x3
006460  EB1800     CLR [W0++]
486:               			break;
487:               		}
488:               	}
489:               	MEM_CS_OFF();
006462  200200     MOV #0x20, W0
006464  200001     MOV #0x0, W1
006466  07CFA2     RCALL ___delay32
006468  A8A2CD     BSET 0x2CD, #5
490:               	if (BootFlashNew())
00646A  070B17     RCALL BootFlashNew
00646C  E00400     CP0.B W0
00646E  320003     BRA Z, 0x6476
491:               	{
492:               		CurrentWriteAddress.u32	= 0;	// Memory used for bootLoader - clear
006470  EF2832     CLR 0x832
006472  EF2834     CLR 0x834
493:               		FL_BOOT_TCP = 1;
006474  A8292D     BSET 0x92D, #1
494:               	}
495:               	CurrentReadAddress.u32	= 0;	// temporary
006476  EF2836     CLR CurrentReadAddress
006478  EF2838     CLR 0x838
496:               }
00647A  060000     RETURN
497:               
498:               void Mem_ReadStart			(void)
499:               {
500:               	Mem_ReadStatus(1);
0064D4  B3C010     MOV.B #0x1, W0
0064D6  07FFDD     RCALL Mem_ReadStatus
501:               
502:               //	DebugPrint("Memory Read start");
503:               	MEM_SPI_CLEAR();
0064D8  0709E2     RCALL Spi1Clear
504:               	MEM_CS_OFF();
0064DA  200200     MOV #0x20, W0
0064DC  200001     MOV #0x0, W1
0064DE  07CF66     RCALL ___delay32
0064E0  A8A2CD     BSET 0x2CD, #5
505:               	MEM_CS_ON();
0064E2  A9A2CD     BCLR 0x2CD, #5
0064E4  200200     MOV #0x20, W0
0064E6  200001     MOV #0x0, W1
0064E8  07CF61     RCALL ___delay32
506:               	if (CurrentReadAddress.u8hh)
0064EA  BFC839     MOV.B 0x839, WREG
0064EC  320005     BRA Z, 0x64F8
507:               	{
508:               		MEM_SPI_BUF_REG = MEM_CMD_4READ;
0064EE  200131     MOV #0x13, W1
0064F0  881241     MOV W1, SPI1BUF
509:               		MEM_SPI_BUF_REG = CurrentReadAddress.u8hh;
0064F2  FB8000     ZE W0, W0
0064F4  881240     MOV W0, SPI1BUF
0064F6  370002     BRA 0x64FC
510:               	}
511:               	else
512:               		MEM_SPI_BUF_REG = MEM_CMD_READ;
0064F8  200030     MOV #0x3, W0
0064FA  881240     MOV W0, SPI1BUF
513:               	MEM_SPI_BUF_REG = CurrentReadAddress.u8hl;
0064FC  BFC838     MOV.B 0x838, WREG
0064FE  FB8000     ZE W0, W0
006500  881240     MOV W0, SPI1BUF
514:               	MEM_SPI_BUF_REG = CurrentReadAddress.u8lh;
006502  BFC837     MOV.B 0x837, WREG
006504  FB8000     ZE W0, W0
006506  881240     MOV W0, SPI1BUF
515:               	MEM_SPI_BUF_REG = CurrentReadAddress.u8ll;
006508  BFC836     MOV.B CurrentReadAddress, WREG
00650A  FB8000     ZE W0, W0
00650C  881240     MOV W0, SPI1BUF
516:               	MemIrqState		= MemState_ReadData;
00650E  200040     MOV #0x4, W0
006510  8841D0     MOV W0, MemIrqState
517:               	MEM_SPI_CLEAR();
006512  0709C5     RCALL Spi1Clear
518:               	MEM_SPI_BUF_REG	= 0;
006514  EF2248     CLR SPI1BUF
519:               	MEM_SPI_BUF_REG	= 0;
006516  EF2248     CLR SPI1BUF
520:               }
006518  060000     RETURN
521:               /*
522:               void Mem_WriteStart			(void)
523:               {
524:               	MEM_FLAG_READ_ACTIVE	= 0;
525:               	Spi1Clear();
526:               	MEM_CS_OFF();
527:               	if (NEW_WRITE_SECTOR)
528:               		Mem_PageErase();
529:               	Mem_WriteEnable();
530:               	MEM_CS_ON();
531:               	#if (MEMORY > 256)
532:               		if (CurrentWriteAddress.u8hh)
533:               		{
534:               			SPI1BUF = MEM_CMD_4PP;
535:               			SPI1BUF = CurrentWriteAddress.u8hh;
536:               		}
537:               		else
538:               	#endif
539:               	SPI1BUF = MEM_CMD_PP;
540:               	SPI1BUF = CurrentWriteAddress.u8hl;
541:               	SPI1BUF = CurrentWriteAddress.u8lh;
542:               	SPI1BUF = CurrentWriteAddress.u8ll;
543:               	MEM_FLAG_WRITE_ACTIVE	= 1;
544:               	Spi1Clear();
545:               }
546:               */
547:               void Mem_PageErase			(void)
548:               {
549:               	DebugPrint("Erase current sector");
0065A0  2B5680     MOV #0xB568, W0
0065A2  07F68D     RCALL Usb_SendText
550:               	Spi1Clear();
0065A4  07097C     RCALL Spi1Clear
551:               	Mem_WriteEnable();
0065A6  07FFED     RCALL Mem_WriteEnable
552:               	MEM_CS_ON();
0065A8  A9A2CD     BCLR 0x2CD, #5
0065AA  200200     MOV #0x20, W0
0065AC  200001     MOV #0x0, W1
0065AE  07CEFE     RCALL ___delay32
553:               	if (CurrentWriteAddress.u8hh)
0065B0  BFC835     MOV.B 0x835, WREG
0065B2  320005     BRA Z, 0x65BE
554:               	{
555:               		SPI1BUF = MEM_CMD_4SE;
0065B4  200DC1     MOV #0xDC, W1
0065B6  881241     MOV W1, SPI1BUF
556:               		SPI1BUF = CurrentWriteAddress.u8hh;
0065B8  FB8000     ZE W0, W0
0065BA  881240     MOV W0, SPI1BUF
0065BC  370002     BRA 0x65C2
557:               	}
558:               	else
559:               		SPI1BUF = MEM_CMD_SE;
0065BE  200D80     MOV #0xD8, W0
0065C0  881240     MOV W0, SPI1BUF
560:               	SPI1BUF = CurrentWriteAddress.u8hl;
0065C2  BFC834     MOV.B 0x834, WREG
0065C4  FB8000     ZE W0, W0
0065C6  881240     MOV W0, SPI1BUF
561:               	SPI1BUF = 0;
0065C8  EF2248     CLR SPI1BUF
562:               	SPI1BUF = 0;
0065CA  EF2248     CLR SPI1BUF
563:               	Spi1Clear();
0065CC  070968     RCALL Spi1Clear
564:               	MEM_CS_OFF();
0065CE  200200     MOV #0x20, W0
0065D0  200001     MOV #0x0, W1
0065D2  07CEEC     RCALL ___delay32
0065D4  A8A2CD     BSET 0x2CD, #5
565:               }
0065D6  060000     RETURN
566:               
567:               //	--	Service Functions	------------------------------------------------------------
568:               U8	 Mem_ReadStatus		(U8 wait)
569:               {
006492  BE9F88     MOV.D W8, [W15++]
006494  784480     MOV.B W0, W9
570:               	Spi1Clear();
006496  070A03     RCALL Spi1Clear
571:               	MEM_CS_ON();
006498  A9A2CD     BCLR 0x2CD, #5
00649A  200200     MOV #0x20, W0
00649C  200001     MOV #0x0, W1
00649E  07CF86     RCALL ___delay32
572:               	Spi1Byte(MEM_CMD_RDSR);
0064A0  B3C050     MOV.B #0x5, W0
0064A2  070A24     RCALL Spi1Byte
573:               	U8 status	= Spi1Byte(0);
0064A4  EB4000     CLR.B W0
0064A6  070A22     RCALL Spi1Byte
0064A8  784400     MOV.B W0, W8
574:               	while(wait && (status & MEM_STATUS_WIP))
0064AA  E00409     CP0.B W9
0064AC  320008     BRA Z, 0x64BE
0064AE  A30808     BTST.Z W8, #0
0064B0  320006     BRA Z, 0x64BE
0064BA  A30808     BTST.Z W8, #0
0064BC  3A0007     BRA NZ, 0x64CC
575:               		status	= Spi1Byte(0);
0064B2  EB4000     CLR.B W0
0064B4  070A1B     RCALL Spi1Byte
0064B6  784400     MOV.B W0, W8
0064B8  EB4480     CLR.B W9
0064CC  784009     MOV.B W9, W0
0064CE  070A0E     RCALL Spi1Byte
0064D0  784400     MOV.B W0, W8
0064D2  37FFF3     BRA 0x64BA
576:               	MEM_CS_OFF();
0064BE  200200     MOV #0x20, W0
0064C0  200001     MOV #0x0, W1
0064C2  07CF74     RCALL ___delay32
0064C4  A8A2CD     BSET 0x2CD, #5
577:               	return status;
578:               }
0064C6  784008     MOV.B W8, W0
0064C8  BE044F     MOV.D [--W15], W8
0064CA  060000     RETURN
0064CC  784009     MOV.B W9, W0
0064CE  070A0E     RCALL Spi1Byte
0064D0  784400     MOV.B W0, W8
0064D2  37FFF3     BRA 0x64BA
579:               
580:               void Mem_WriteStatus		(U8 status)
581:               {
006560  781F88     MOV W8, [W15++]
006562  784400     MOV.B W0, W8
582:               	Spi1Clear();
006564  07099C     RCALL Spi1Clear
583:               	MEM_CS_ON();
006566  A9A2CD     BCLR 0x2CD, #5
006568  200200     MOV #0x20, W0
00656A  200001     MOV #0x0, W1
00656C  07CF1F     RCALL ___delay32
584:               	Spi1Byte(MEM_CMD_WRSR);
00656E  B3C010     MOV.B #0x1, W0
006570  0709BD     RCALL Spi1Byte
585:               	Spi1Byte(status);
006572  784008     MOV.B W8, W0
006574  0709BB     RCALL Spi1Byte
586:               	MEM_CS_OFF();
006576  200200     MOV #0x20, W0
006578  200001     MOV #0x0, W1
00657A  07CF18     RCALL ___delay32
00657C  A8A2CD     BSET 0x2CD, #5
587:               }
00657E  78044F     MOV [--W15], W8
006580  060000     RETURN
588:               
589:               void Mem_WriteEnable		(void)
590:               {
591:               	Mem_ReadStatus(1);
006582  B3C010     MOV.B #0x1, W0
006584  07FF86     RCALL Mem_ReadStatus
592:               	MEM_CS_ON();
006586  A9A2CD     BCLR 0x2CD, #5
006588  200200     MOV #0x20, W0
00658A  200001     MOV #0x0, W1
00658C  07CF0F     RCALL ___delay32
593:               	Spi1Byte(MEM_CMD_WREN);
00658E  B3C060     MOV.B #0x6, W0
006590  0709AD     RCALL Spi1Byte
594:               	MEM_CS_OFF();
006592  200200     MOV #0x20, W0
006594  200001     MOV #0x0, W1
006596  07CF0A     RCALL ___delay32
006598  A8A2CD     BSET 0x2CD, #5
595:               	Mem_ReadStatus(1);
00659A  B3C010     MOV.B #0x1, W0
00659C  07FF7A     RCALL Mem_ReadStatus
596:               }
00659E  060000     RETURN
597:               
598:               void Mem_WriteDisable		(void)
599:               {
600:               	Mem_ReadStatus(1);
0065D8  B3C010     MOV.B #0x1, W0
0065DA  07FF5B     RCALL Mem_ReadStatus
601:               	MEM_CS_ON();
0065DC  A9A2CD     BCLR 0x2CD, #5
0065DE  200200     MOV #0x20, W0
0065E0  200001     MOV #0x0, W1
0065E2  07CEE4     RCALL ___delay32
602:               	Spi1Byte(MEM_CMD_WRDI);
0065E4  B3C040     MOV.B #0x4, W0
0065E6  070982     RCALL Spi1Byte
603:               	MEM_CS_OFF();
0065E8  200200     MOV #0x20, W0
0065EA  200001     MOV #0x0, W1
0065EC  07CEDF     RCALL ___delay32
0065EE  A8A2CD     BSET 0x2CD, #5
604:               	Mem_ReadStatus(1);
0065F0  B3C010     MOV.B #0x1, W0
0065F2  07FF4F     RCALL Mem_ReadStatus
605:               }
0065F4  060000     RETURN
606:               
---  /home/pele/src/Auto_02/src/Main.c  -----------------------------------------------------------------
1:                 #include	"Typedef.h"
2:                 #include	"Config.h"
3:                 
4:                 #include		"Ports.h"
5:                 #include		"Timers.h"
6:                 #include		"Memory.h"
7:                 #include		"Gps.h"
8:                 #include		"Gsm.h"
9:                 #include		"Tcp.h"
10:                #include		"Adc.h"
11:                //#include		"Input.h"
12:                
13:                #ifdef		ETH_W5100
14:                	#include		"W5100.h"
15:                #endif
16:                //#ifdef		USB_PORT
17:                //	#include	"system.h"
18:                //#endif
19:                //#ifdef		UART4_WIFI
20:                //	#include	"Wifi.h"
21:                //#endif
22:                #if			(LCD != LCD_NO)
23:                	#include	"Lcd.h"
24:                #endif
25:                
26:                #include		<stdio.h>
27:                
28:                
29:                /*
30:                #ifdef		BOOT_LOADER
31:                	extern void BootLoader	(void);
32:                #else
33:                	#define		BootLoader();
34:                #endif
35:                *
36:                UNI32	testVal __attribute__ ((noload));		// for tests
37:                U8		testBuf[20] __attribute__ ((noload));	// for tests
38:                extern volatile	U8	SysHour, SysMin, SysSec;
39:                extern void Usb_SendText (char* str);
40:                
41:                char	time[30];
42:                */
43:                int main (void)
44:                {
45:                	InitPorts();
0003C8  0739D4     RCALL InitPorts
46:                //	OSCconfig(Osc_32_MHz);
47:                	PPSconfig(pps_system);
0003CA  EB0000     CLR W0
0003CC  0739F4     RCALL PPSconfig
48:                
49:                	#if	(LCD != LCD_NO)
50:                		LcdInit();
51:                	#endif
52:                	#ifdef	ROM_DATA_ADDR
53:                		FlashDataInit();
0003CE  0739A7     RCALL FlashDataInit
0003D0  37FFFF     BRA 0x3D0
54:                	#endif
55:                	#if	(LCD > LCD_NO)
56:                		LcdString(0, 48, DEVICE, font_ss16);
57:                	#endif
58:                
59:                //	AdcInit();
60:                //	MemInit();
61:                //	InputInit();
62:                //	#ifdef		USB_PORT
63:                //		Usb_Init();
64:                //	#endif
65:                	#if	((TEST != GSM_TEST) && (TEST != WIFI_TEST))
66:                //		Gsm_On();
67:                	#endif
68:                	#if	(TEST != GPS_TEST)
69:                //		Gps_On();
70:                	#endif
71:                //	#ifdef UART4_WIFI
72:                ////		#if (TEST != WIFI_TEST)
73:                //			Wifi_On();
74:                ////		#endif
75:                //	#endif
76:                
77:                //	#ifdef		USB_PORT
78:                //		Usb_SendText("Start");
79:                //	#endif
80:                	while(true)
81:                	{
82:                //		#ifdef		USB_PORT
83:                //			Usb_RegularFunctions();
84:                //		#endif
85:                //		#if	(TEST == WIFI_TEST)
86:                ////			Wifi_Test();
87:                //		#endif
88:                
89:                //		if (FL_BOOT_TCP)	{	Tcp_BootLoaderProcess();	continue;	}
90:                //		if (FL_TCP_RESEND)		Tcp_PacketResend();
91:                //        if (FL_POWER_OFF)       PowerOff();
92:                ////		if (FL_POWER_CHANGES)	Tcp_AdcPacket();
93:                
94:                //		static U8 lastSec = 0;
95:                //		if (lastSec != SysTime.sec)
96:                //		{
97:                //			lastSec = SysTime.sec;
98:                //		}
99:                	}
100:               	return 0;
101:               }
102:               
---  /home/pele/src/Auto_02/src/Gsm.c  ------------------------------------------------------------------
1:                 #include		"Gsm.h"
2:                 #include		"GsmDefines.h"
3:                 #include		"Ports.h"
4:                 #include		"Tcp.h"
5:                 #include		<string.h>
6:                 #include		<stdio.h>
7:                 #include		<stdlib.h>
8:                 
9:                 #if	(TEST == GSM_TEST)
10:                  #include		"Debug.h"
11:                  static char	tmp[80];
12:                #else
13:                  extern void	Usb_SendText (char* str);
14:                  #define		DebugPrint(X)
15:                  #define		DebugSprintf(stream,fmt,a...)
16:                #endif
17:                
18:                static	char		gsmBuff[256];
19:                static	char		irqBuf[256];
20:                static	char		callTxt[20], callNr[20];
21:                static	char		OkPacket[TCP_PACKET_HEDER];
22:                static	char*		recGsmData = NULL;
23:                static	GSM_STATE	GsmState;
24:                static	U16			TimeOut;			// 0.01 sec
25:                static	U16			PackRecTimeout;	
26:                static	GSM_FLAGS	Flags;
27:                static	U8			Csq	= 0, LastCsq = 0;
28:                //static	U8			IdleSeconds	= 0;
29:                static	TCP_PACKET	PacketIn[2];
30:                static	TCP_PACKET	PacketOut;
31:                static	TCP_PACKET*	PacketRec	= 0;
32:                static	char*		DataToSend;
33:                static	U16			SendDataLen = 0, OkSeconds = 0, IdleSeconds = 0, CsqTime;
34:                
35:                #ifndef GSM_POWER
36:                	U8 GSM_POWER = 1;
37:                #endif
38:                
39:                // Public Functions ---------------------------------------------------------------------------------
40:                void Gsm_On	(void)
41:                {
42:                	#if	(TEST == GSM_TEST)
43:                		if (GSM_IE)
003698  AB0096     BTST IEC1, #0
00369A  320005     BRA Z, 0x36A6
44:                		{
45:                			GSM_IE	= 0;	DebugPrint("Turn GSM Interrupt Off");
00369C  A90096     BCLR IEC1, #0
00369E  29E070     MOV #0x9E07, W0
0036A0  070E0E     RCALL Usb_SendText
46:                			GSM_LED	= LED_STATUS_OFF;
0036A2  EF2894     CLR LedStatus1
47:                			return;
0036A4  37000D     BRA 0x36C0
48:                		}
49:                	#endif
50:                	GsmIrq_Off();
0036A6  A90096     BCLR IEC1, #0
51:                	TimeOut		= 1;
0036A8  200010     MOV #0x1, W0
0036AA  884010     MOV W0, TimeOut
52:                	GsmFlags	= 0;
0036AC  EF2800     CLR Flags
53:                	GsmState	= GsmState_PowerOn;
0036AE  2000D0     MOV #0xD, W0
0036B0  8840F0     MOV W0, GsmState
54:                	Tcp_PreparePacket((TCP_PACKET*)OkPacket, TYPE_OK_GPRS);	// Prepare OK packet for use in interrupt
0036B2  B3CF01     MOV.B #0xF0, W1
0036B4  227880     MOV #0x2788, W0
0036B6  071303     RCALL Tcp_PreparePacket
55:                	GsmIrq_On();		DebugPrint("Turn GSM Interrupt On");
0036B8  A90086     BCLR IFS1, #0
0036BA  A80096     BSET IEC1, #0
0036BC  29E1E0     MOV #0x9E1E, W0
0036BE  070DFF     RCALL Usb_SendText
56:                }
0036C0  060000     RETURN
57:                
58:                void Gsm_Off	(void)
59:                {
60:                	GSM_IE	= 0;
0036C2  A90096     BCLR IEC1, #0
61:                	GSM_RTS_OFF();
0036C4  A842E0     BSET TRISE, #2
62:                	GsmFlags	= 0;
0036C6  EF2800     CLR Flags
63:                	GsmState	= GsmState_Idle;
0036C8  EF281E     CLR GsmState
64:                	GSM_LED		= LED_STATUS_ERROR;
0036CA  2AAAA0     MOV #0xAAAA, W0
0036CC  8844A0     MOV W0, LedStatus1
65:                	while (GSM_STATUS)
0036CE  AB42E2     BTST PORTE, #2
0036D0  320003     BRA Z, 0x36D8
0036D4  AB42E2     BTST PORTE, #2
0036D6  3AFFFD     BRA NZ, 0x36D2
66:                	{
67:                		GSM_PK_ON();
0036D2  A982D8     BCLR TRISD, #4
68:                	}
69:                	GSM_DTR_OFF();
0036D8  A922E4     BCLR LATE, #1
70:                	GSM_LED		= LED_STATUS_OFF;
0036DA  EF2894     CLR LedStatus1
71:                }
0036DC  060000     RETURN
72:                
73:                void Gsm_PwrOn	(void)
74:                {
75:                	GSM_POWER = !GSM_POWER;
0036DE  801740     MOV TRISF, W0
0036E0  600062     AND W0, #0x2, W0
0036E2  E90000     DEC W0, W0
0036E4  DE004F     LSR W0, #15, W0
0036E6  400000     ADD W0, W0, W0
0036E8  801741     MOV TRISF, W1
0036EA  A11001     BCLR W1, #1
0036EC  700081     IOR W0, W1, W1
0036EE  881741     MOV W1, TRISF
76:                	#if	(TEST == GSM_TEST)
77:                		if (GSM_POWER)		DebugPrint("GSM Power Off");
0036F0  AB22E8     BTST TRISF, #1
0036F2  320003     BRA Z, 0x36FA
0036F4  29E340     MOV #0x9E34, W0
0036F6  070DE3     RCALL Usb_SendText
0036F8  370002     BRA 0x36FE
78:                		else				DebugPrint("GSM Power On");
0036FA  29E420     MOV #0x9E42, W0
0036FC  070DE0     RCALL Usb_SendText
79:                	#endif
80:                }
0036FE  060000     RETURN
81:                
82:                void Gsm_PwrKey	(void)
83:                {
84:                	GSM_P_KEY = !GSM_P_KEY;
003700  8016C0     MOV TRISD, W0
003702  600070     AND W0, #0x10, W0
003704  E90000     DEC W0, W0
003706  DE004F     LSR W0, #15, W0
003708  DD0044     SL W0, #4, W0
00370A  8016C1     MOV TRISD, W1
00370C  A14001     BCLR W1, #4
00370E  700081     IOR W0, W1, W1
003710  8816C1     MOV W1, TRISD
85:                	#if	(TEST == GSM_TEST)
86:                		if (GSM_P_KEY)
003712  AB82D8     BTST TRISD, #4
003714  320004     BRA Z, 0x371E
87:                		{
88:                			GSM_RTS_ON();	DebugPrint("GSM Power key Off");
003716  A942E0     BCLR TRISE, #2
003718  29E4F0     MOV #0x9E4F, W0
00371A  070DD1     RCALL Usb_SendText
00371C  370002     BRA 0x3722
89:                //			GSM_DTR_ON();
90:                		}
91:                		else				DebugPrint("GSM Power key On");
00371E  29E610     MOV #0x9E61, W0
003720  070DCE     RCALL Usb_SendText
92:                	#endif
93:                }
003722  060000     RETURN
94:                
95:                void Gsm_AT		(void)
96:                {
97:                	DebugPrint("Set GSM module to factory setings (AT&F)");
003724  29E720     MOV #0x9E72, W0
003726  070DCB     RCALL Usb_SendText
98:                	GsmUart_SendText("AT&F;&W\r\n");
003728  29E9B0     MOV #0x9E9B, W0
00372A  071DB5     RCALL Uart2_SendText
99:                //	GsmUart_SendText("ATE0;&W;+CMEE=0;&W;+IFC=2,2;&W;+IPR=38400;&W;&D0;&W\r\n");
100:               //	GsmUart_SendText("AT\r\n");
101:               }
00372C  060000     RETURN
102:               
103:               void Gsm_AtCommand	(char* str)
104:               {
00372E  781F88     MOV W8, [W15++]
003730  780400     MOV W0, W8
105:               	DebugPrint("Send to GSM:");
003732  29EA50     MOV #0x9EA5, W0
003734  070DC4     RCALL Usb_SendText
106:               	DebugPrint(str);
003736  780008     MOV W8, W0
003738  070DC2     RCALL Usb_SendText
107:               	GsmUart_SendText(str);
00373A  780008     MOV W8, W0
00373C  071DAC     RCALL Uart2_SendText
108:               	if (memcmp(str, "+++", 3) != 0)
00373E  200032     MOV #0x3, W2
003740  29EB21     MOV #0x9EB2, W1
003742  780008     MOV W8, W0
003744  07ED58     RCALL _memcmp
003746  E00000     CP0 W0
003748  320001     BRA Z, 0x374C
109:               		GsmUart_SendEnter();
00374A  071DBB     RCALL Uart2_SendEnter
110:               }
00374C  78044F     MOV [--W15], W8
00374E  060000     RETURN
111:               
112:               void Gsm_DTR		(void)
113:               {
114:               	GSM_DTR = !GSM_DTR;
003750  801720     MOV LATE, W0
003752  600062     AND W0, #0x2, W0
003754  E90000     DEC W0, W0
003756  DE004F     LSR W0, #15, W0
003758  400000     ADD W0, W0, W0
00375A  801721     MOV LATE, W1
00375C  A11001     BCLR W1, #1
00375E  700081     IOR W0, W1, W1
003760  881721     MOV W1, LATE
115:               	#if	(TEST == GSM_TEST)
116:               		if (GSM_DTR)		DebugPrint("GSM GSM_DTR signal High");
003762  AB22E4     BTST LATE, #1
003764  320003     BRA Z, 0x376C
003766  29EB60     MOV #0x9EB6, W0
003768  070DAA     RCALL Usb_SendText
00376A  370002     BRA 0x3770
117:               		else				DebugPrint("GSM GSM_DTR signal Low");
00376C  29ECE0     MOV #0x9ECE, W0
00376E  070DA7     RCALL Usb_SendText
118:               	#endif
119:               }
003770  060000     RETURN
120:               
121:               U16 Gsm_AUTO		(void)
122:               {
123:               	FL_TEST_MANUAL = !FL_TEST_MANUAL;
003772  804960     MOV SysFlags, W0
003774  600062     AND W0, #0x2, W0
003776  E90000     DEC W0, W0
003778  DE004F     LSR W0, #15, W0
00377A  400000     ADD W0, W0, W0
00377C  804961     MOV SysFlags, W1
00377E  A11001     BCLR W1, #1
003780  700081     IOR W0, W1, W1
003782  884961     MOV W1, SysFlags
124:               	#if	(TEST == GSM_TEST)
125:               		if (FL_TEST_MANUAL)	DebugPrint("GSM Manual Mode");
003784  AB292C     BTST SysFlags, #1
003786  320003     BRA Z, 0x378E
003788  29EE50     MOV #0x9EE5, W0
00378A  070D99     RCALL Usb_SendText
00378C  370002     BRA 0x3792
126:               		else				DebugPrint("GSM Automatic Mode");
00378E  29EF50     MOV #0x9EF5, W0
003790  070D96     RCALL Usb_SendText
127:               	#endif
128:               	return	Flags.word;
129:               }
003792  804000     MOV Flags, W0
003794  060000     RETURN
130:               
131:               void Gsm_OnLine		(void)
132:               {
133:               	FL_GPRS_OFFLINE = !FL_GPRS_OFFLINE;
003796  804960     MOV SysFlags, W0
003798  600068     AND W0, #0x8, W0
00379A  E90000     DEC W0, W0
00379C  DE004F     LSR W0, #15, W0
00379E  DD0043     SL W0, #3, W0
0037A0  804961     MOV SysFlags, W1
0037A2  A13001     BCLR W1, #3
0037A4  700081     IOR W0, W1, W1
0037A6  884961     MOV W1, SysFlags
134:               	#if	(TEST == GSM_TEST)
135:               		if (FL_GPRS_OFFLINE)	Usb_SendText("GSM Offline Mode");
0037A8  AB692C     BTST SysFlags, #3
0037AA  320003     BRA Z, 0x37B2
0037AC  29F080     MOV #0x9F08, W0
0037AE  070D87     RCALL Usb_SendText
0037B0  370002     BRA 0x37B6
136:               		else					Usb_SendText("GSM Online  Mode");
0037B2  29F190     MOV #0x9F19, W0
0037B4  070D84     RCALL Usb_SendText
137:               	#endif
138:               }
0037B6  060000     RETURN
139:               
140:               // Internal Functions -------------------------------------------------------------------------------
141:               inline	void Gsm_ResponseAction	(void)
142:               {
003978  BE9F88     MOV.D W8, [W15++]
00397A  BE9F8A     MOV.D W10, [W15++]
143:               	while (GsmStringReceived())
00397E  37003E     BRA 0x39FC
0039FC  071C20     RCALL Uart2_StringReceived
0039FE  E00400     CP0.B W0
003A00  3AFFBF     BRA NZ, 0x3980
144:               	{
145:               		if (Flags.sms)
003980  AB8800     BTST Flags, #4
003982  320003     BRA Z, 0x398A
146:               			return GetSmsText(irqBuf);
003984  224100     MOV #0x2410, W0
003986  07FFE0     RCALL GetSmsText
003988  37003C     BRA 0x3A02
147:               
148:               		register char d = irqBuf[0];
00397C  224108     MOV #0x2410, W8
00398A  784498     MOV.B [W8], W9
149:               		GsmUart_GetString((P_U8)irqBuf);
00398C  780008     MOV W8, W0
00398E  071C75     RCALL Uart2_GetString
150:               		if (!irqBuf[0])							// if received string is empty
003990  E00418     CP0.B [W8]
003992  3A0002     BRA NZ, 0x3998
151:               		{	irqBuf[0] = d;	continue;	}		// restore previous value of buffer ("" = '\0')
003994  784C09     MOV.B W9, [W8]
003996  370032     BRA 0x39FC
152:               		
153:               		#if	(TEST == GSM_TEST)
154:               			if (FL_TEST_MANUAL)
003998  AB292C     BTST SysFlags, #1
00399A  320003     BRA Z, 0x39A2
155:               			{
156:               				DebugPrint(irqBuf);
00399C  224100     MOV #0x2410, W0
00399E  070C8F     RCALL Usb_SendText
157:               				return;
0039A0  370030     BRA 0x3A02
158:               			}
159:               		#endif
160:               
161:               		Flags.Ack = 0b01000;					// sms=0, rec=1, ackData=0, ackErr=0, ackOk=0
0039A2  2FFE00     MOV #0xFFE0, W0
0039A4  B60800     AND Flags, WREG
0039A6  A03000     BSET W0, #3
0039A8  884000     MOV W0, Flags
0039AA  2A74C8     MOV #0xA74C, W8
162:               		register U16 i;
163:               		for(i = 0; i < (sizeof(GsmResponses) / sizeof(GSM_RESPONSE)); i++)
0039AC  EB0480     CLR W9
0039E6  E80489     INC W9, W9
0039E8  44046A     ADD W8, #0xA, W8
0039EA  548FF5     SUB W9, #0x15, [W15]
0039EC  3AFFE1     BRA NZ, 0x39B0
164:               		{
165:               			if(!(memcmp(irqBuf, GsmResponses[i].text, GsmResponses[i].size)))
0039AE  22410B     MOV #0x2410, W11
0039B0  FB8518     ZE [W8], W10
0039B2  97B8F8     MOV [W8-2], W1
0039B4  78010A     MOV W10, W2
0039B6  78000B     MOV W11, W0
0039B8  07EC1E     RCALL _memcmp
0039BA  E00000     CP0 W0
0039BC  3A0014     BRA NZ, 0x39E6
166:               			{
167:               				if (GsmResponses[i].newState)
0039BE  B9486A     MUL.SU W9, #10, W0
0039C0  400064     ADD W0, #0x4, W0
0039C2  2A74A1     MOV #0xA74A, W1
0039C4  780061     MOV [W1+W0], W0
0039C6  E00000     CP0 W0
0039C8  320001     BRA Z, 0x39CC
168:               					GsmState = GsmResponses[i].newState;
0039CA  8840F0     MOV W0, GsmState
169:               				TimeOut = GsmResponses[i].newTimeout;
0039CC  B9486A     MUL.SU W9, #10, W0
0039CE  780480     MOV W0, W9
0039D0  4480E6     ADD W9, #0x6, W1
0039D2  2A74A0     MOV #0xA74A, W0
0039D4  7880E0     MOV [W0+W1], W1
0039D6  884011     MOV W1, TimeOut
170:               				GsmFlags |= GsmResponses[i].orFlags;
0039D8  4484E8     ADD W9, #0x8, W9
0039DA  7C8060     MOV [W0+W9], W0
0039DC  B72800     IOR Flags
171:               				recGsmData = irqBuf + GsmResponses[i].size;
0039DE  224100     MOV #0x2410, W0
0039E0  450500     ADD W10, W0, W10
0039E2  88402A     MOV W10, recGsmData
172:               				#ifdef	SHOW_AT_RESPONSE
173:               					DebugPrint(irqBuf);
174:               //					DebugPrint(recGsmData);
175:               				#endif
176:               				return;
0039E4  37000E     BRA 0x3A02
177:               			}
178:               		}
179:               		DebugPrint("Uncnown response:");
0039EE  29F9C0     MOV #0x9F9C, W0
0039F0  070C66     RCALL Usb_SendText
180:               		DebugPrint(irqBuf);
0039F2  224100     MOV #0x2410, W0
0039F4  070C64     RCALL Usb_SendText
181:               		recGsmData = irqBuf;
0039F6  224100     MOV #0x2410, W0
0039F8  884020     MOV W0, recGsmData
182:               		return;
0039FA  370003     BRA 0x3A02
183:               	}
184:               }
003A02  BE054F     MOV.D [--W15], W10
003A04  BE044F     MOV.D [--W15], W8
003A06  060000     RETURN
185:               
186:               // **********************************************************************
187:               //	GSM Interrupt (I2C1 Slave Event used for 16bit proc) 100Hz if enabled
188:               // **********************************************************************
189:               //void Gsm_Interrupt(void)
190:               void GSM_INTERRUPT(void)
004100  E80000     INC W0, W0
191:               {
003A8C  F80036     PUSH RCOUNT
003A8E  BE9F80     MOV.D W0, [W15++]
003A90  BE9F82     MOV.D W2, [W15++]
003A92  BE9F84     MOV.D W4, [W15++]
003A94  BE9F86     MOV.D W6, [W15++]
003A96  BE9F88     MOV.D W8, [W15++]
192:               	static	GSM_STATE	lastGsmState = GsmState_Idle;
193:               	static	U8			stateTimeout = 0, lastStatus;	//, retry = 0, cpas;
194:               	static	U16			ledStatus;
195:               	static	char		recSmsNr[4] = "";
196:               	GSM_IF = 0;
003A98  A90086     BCLR IFS1, #0
197:               
198:               	if (lastStatus != Flags.Status)
003A9A  804000     MOV Flags, W0
003A9C  DE004A     LSR W0, #10, W0
003A9E  E34826     CP.B lastStatus
003AA0  320021     BRA Z, 0x3AE4
199:               	{
200:               		lastStatus = Flags.Status;
003AA2  B7E826     MOV.B WREG, lastStatus
201:               		if		(lastStatus >= STATUS_CONNECTED)	ledStatus	= LED_STATUS_ON;
003AA4  B3C3D1     MOV.B #0x3D, W1
003AA6  504F81     SUB.B W0, W1, [W15]
003AA8  360002     BRA LEU, 0x3AAE
003AAA  EFA824     SETM ledStatus
003AAC  370013     BRA 0x3AD4
202:               		else if	(lastStatus >= STATUS_NETWORK)		ledStatus	= LED_STATUS_3;
003AAE  B3C371     MOV.B #0x37, W1
003AB0  504F81     SUB.B W0, W1, [W15]
003AB2  360003     BRA LEU, 0x3ABA
003AB4  292000     MOV #0x9200, W0
003AB6  884120     MOV W0, ledStatus
003AB8  37000D     BRA 0x3AD4
203:               		else if	(lastStatus >= STATUS_ACTIVE)		ledStatus	= LED_STATUS_2;
003ABA  B3C2F1     MOV.B #0x2F, W1
003ABC  504F81     SUB.B W0, W1, [W15]
003ABE  360003     BRA LEU, 0x3AC6
003AC0  290000     MOV #0x9000, W0
003AC2  884120     MOV W0, ledStatus
003AC4  370007     BRA 0x3AD4
204:               		else if	(lastStatus >= STATUS_POWER)		ledStatus	= LED_STATUS_1;
003AC6  504FFF     SUB.B W0, #0x1F, [W15]
003AC8  360003     BRA LEU, 0x3AD0
003ACA  280000     MOV #0x8000, W0
003ACC  884120     MOV W0, ledStatus
003ACE  370002     BRA 0x3AD4
205:               		else										ledStatus	= LED_STATUS_ERROR;
003AD0  2AAAA0     MOV #0xAAAA, W0
003AD2  884120     MOV W0, ledStatus
206:               		CsqTime = (Flags.home && Flags.csq)?	30 : 10;
003AD4  230000     MOV #0x3000, W0
003AD6  804001     MOV Flags, W1
003AD8  600101     AND W0, W1, W2
003ADA  2000A1     MOV #0xA, W1
003ADC  510F80     SUB W2, W0, [W15]
003ADE  3A0001     BRA NZ, 0x3AE2
003AE0  2001E1     MOV #0x1E, W1
003AE2  8840C1     MOV W1, CsqTime
0040EE  EB4080     CLR.B W1
207:               	}
208:               
209:               	if (FL_GSM_SEC)
003AE4  AB092C     BTST SysFlags, #0
003AE6  320003     BRA Z, 0x3AEE
210:               	{
211:               		FL_GSM_SEC = 0;
003AE8  A9092C     BCLR SysFlags, #0
212:               		IdleSeconds++;
003AEA  EC281A     INC IdleSeconds
213:               		OkSeconds++;
003AEC  EC281C     INC OkSeconds
214:               	}
215:               	GSM_LED		= ledStatus;
003AEE  F80824     PUSH ledStatus
003AF0  F90894     POP LedStatus1
216:               	
217:               	if (PacketRec)
003AF2  804070     MOV PacketRec, W0
003AF4  E00000     CP0 W0
003AF6  320012     BRA Z, 0x3B1C
218:               	{
219:               		DebugSprintf(tmp,"Tcp Packet - Type: %02X, ID: %04X, Len: %d", PacketRec->type, PacketRec->id, PacketRec->len);
003AF8  904090     MOV.B [W0+1], W1
003AFA  FB8081     ZE W1, W1
003AFC  781F81     MOV W1, [W15++]
003AFE  9000A0     MOV [W0+4], W1
003B00  781F81     MOV W1, [W15++]
003B02  904030     MOV.B [W0+3], W0
003B04  FB8000     ZE W0, W0
003B06  781F80     MOV W0, [W15++]
003B08  29FAE0     MOV #0x9FAE, W0
003B0A  781F80     MOV W0, [W15++]
003B0C  225380     MOV #0x2538, W0
003B0E  07EC4E     RCALL __sprintf_cdnopuxX, __sprintf_s, __sprintf_0, __sprintf_cdnopsuxX
220:               		DebugPrint(tmp);
003B10  225380     MOV #0x2538, W0
003B12  070BD5     RCALL Usb_SendText
221:               		Tcp_PacketReceived(PacketRec);
003B14  804070     MOV PacketRec, W0
003B16  071113     RCALL Tcp_PacketReceived
222:               		PacketRec = NULL;
003B18  EF280E     CLR PacketRec
003B1A  5787E8     SUB W15, #0x8, W15
223:               	}
224:               
225:               	if (PackRecTimeout)
003B1C  804060     MOV PackRecTimeout, W0
003B1E  E00000     CP0 W0
003B20  320009     BRA Z, 0x3B34
226:               	{
227:               		if (!--PackRecTimeout)
003B22  E90000     DEC W0, W0
003B24  884060     MOV W0, PackRecTimeout
003B26  3A0361     BRA NZ, 0x41EA
228:               		{
229:               			FL_GPRS_REC	= 0;
003B28  A9492C     BCLR SysFlags, #2
230:               			DebugPrint("Error: Tcp Packet Receive Timeout !!!");
003B2A  29FD90     MOV #0x9FD9, W0
003B2C  070BC8     RCALL Usb_SendText
231:               			Tcp_SendText("Error: Tcp Packet Receive Timeout !!!");		// for debug
003B2E  29FD90     MOV #0x9FD9, W0
003B30  07118C     RCALL Tcp_SendText
003B32  37035B     BRA 0x41EA
232:               		}
233:               		return;
234:               	}
235:               
236:               	Gsm_ResponseAction();
003B34  07FF21     RCALL Gsm_ResponseAction
237:               	
238:               	if (TimeOut)
003B36  804010     MOV TimeOut, W0
003B38  E00000     CP0 W0
003B3A  320003     BRA Z, 0x3B42
239:               	{
240:               		TimeOut--;
003B3C  E90000     DEC W0, W0
003B3E  884010     MOV W0, TimeOut
241:               		return;
003B40  370354     BRA 0x41EA
242:               	}
243:               
244:               	if (lastGsmState != GsmState)		// GSM state changed
003B42  804141     MOV lastGsmState, W1
003B44  8040F0     MOV GsmState, W0
003B46  508F80     SUB W1, W0, [W15]
003B48  32000C     BRA Z, 0x3B62
245:               	{
246:               		lastGsmState = GsmState;
003B4A  884140     MOV W0, lastGsmState
247:               		stateTimeout = 0;
003B4C  EF6827     CLR.B stateTimeout
248:               		DebugSprintf(gsmBuff, "State nr: %d, Flags: 0x%04X", lastGsmState, Flags.word);
003B4E  F80800     PUSH Flags
003B50  781F80     MOV W0, [W15++]
003B52  29FFF0     MOV #0x9FFF, W0
003B54  781F80     MOV W0, [W15++]
003B56  222100     MOV #0x2210, W0
003B58  07EC29     RCALL __sprintf_cdnopuxX, __sprintf_s, __sprintf_0, __sprintf_cdnopsuxX
249:               		DebugPrint(gsmBuff);
003B5A  222100     MOV #0x2210, W0
003B5C  070BB0     RCALL Usb_SendText
003B5E  5787E6     SUB W15, #0x6, W15
003B60  370011     BRA 0x3B84
250:               //		sprintf(gsmBuff, "State nr: %d, Flags: 0x%04X", lastGsmState, Flags.word);
251:               //		Tcp_SendText(gsmBuff);
252:               	}
253:               	else if (!++stateTimeout)
003B62  EC4827     INC.B stateTimeout, WREG
003B64  B7E827     MOV.B WREG, stateTimeout
003B66  3A000E     BRA NZ, 0x3B84
254:               	{
255:               		#if	(TEST == GSM_TEST)
256:               			if (!FL_TEST_MANUAL)
003B68  AB292C     BTST SysFlags, #1
003B6A  3A000C     BRA NZ, 0x3B84
257:               		#endif
258:               		{
259:               			DebugSprintf(gsmBuff, "State nr: %d, Flags: 0x%04X - TimeOut Error !!!", lastGsmState, Flags.word);
003B6C  F80800     PUSH Flags
003B6E  781F81     MOV W1, [W15++]
003B70  2A01B0     MOV #0xA01B, W0
003B72  781F80     MOV W0, [W15++]
003B74  222100     MOV #0x2210, W0
003B76  07EC1A     RCALL __sprintf_cdnopuxX, __sprintf_s, __sprintf_0, __sprintf_cdnopsuxX
260:               			DebugPrint(gsmBuff);
003B78  222100     MOV #0x2210, W0
003B7A  070BA1     RCALL Usb_SendText
261:               //			sprintf(gsmBuff, "State nr: %d, Flags: 0x%04X - TimeOut Error !!!", lastGsmState, Flags.word);
262:               //			Tcp_SendText(gsmBuff);
263:               //			GsmState = GsmState_PowerOn;	// restart !!!
264:               			GsmState = GsmState_PowerKeyOn;	// restart !!!
003B7C  2000E0     MOV #0xE, W0
003B7E  8840F0     MOV W0, GsmState
003B80  5787E6     SUB W15, #0x6, W15
003B82  3701BA     BRA 0x3EF8
265:               		}
266:               	}
267:               
268:               	switch (GsmState)
003B84  8040F2     MOV GsmState, W2
003B86  B81061     MUL.UU W2, #1, W0
003B88  500FFC     SUB W0, #0x1C, [W15]
003B8A  588FE0     SUBB W1, #0x0, [W15]
003B8C  3E0320     BRA GTU, 0x41CE
003B8E  016000     BRA W0
003B90  37001C     BRA 0x3BCA
003B92  370085     BRA 0x3C9E
003B94  3700A2     BRA 0x3CDA
003B96  3700F7     BRA 0x3D86
003B98  370112     BRA 0x3DBE
003B9A  370149     BRA 0x3E2E
003B9C  37011B     BRA 0x3DD4
003B9E  37014F     BRA 0x3E3E
003BA0  37015E     BRA 0x3E5E
003BA2  370182     BRA 0x3EA8
003BA4  370185     BRA 0x3EB0
003BA6  37018D     BRA 0x3EC2
003BA8  370312     BRA 0x41CE
003BAA  37018E     BRA 0x3EC8
003BAC  3701A5     BRA 0x3EF8
003BAE  3701B3     BRA 0x3F16
003BB0  3701CC     BRA 0x3F4A
003BB2  3701D3     BRA 0x3F5A
003BB4  3701DD     BRA 0x3F70
003BB6  370201     BRA 0x3FBA
003BB8  37030A     BRA 0x41CE
003BBA  37020A     BRA 0x3FD0
003BBC  370251     BRA 0x4060
003BBE  370261     BRA 0x4082
003BC0  370271     BRA 0x40A4
003BC2  37028C     BRA 0x40DC
003BC4  3702B7     BRA 0x4134
003BC6  3702D2     BRA 0x416C
003BC8  370300     BRA 0x41CA
269:               	{
270:               	case GsmState_Idle:			{
271:               		#if	(TEST == GSM_TEST)
272:               			if (FL_TEST_MANUAL)			break;
003BCA  AB292C     BTST SysFlags, #1
003BCC  3A030A     BRA NZ, 0x41E2
273:               		#endif
274:               		if (*recSmsNr)							// SMS received
003BCE  227900     MOV #0x2790, W0
003BD0  E00410     CP0.B [W0]
003BD2  32000E     BRA Z, 0x3BF0
275:               		{
276:               			GsmUart_SendText("AT+CMGR=");		// read it
003BD4  2A04B0     MOV #0xA04B, W0
003BD6  071B5F     RCALL Uart2_SendText
277:               			GsmUart_SendText(recSmsNr);
003BD8  227900     MOV #0x2790, W0
003BDA  071B5D     RCALL Uart2_SendText
278:               			GsmUart_SendText(";+CMGD=");		// an delete it
003BDC  2A0540     MOV #0xA054, W0
003BDE  071B5B     RCALL Uart2_SendText
279:               			GsmUart_SendText(recSmsNr);
003BE0  227900     MOV #0x2790, W0
003BE2  071B59     RCALL Uart2_SendText
280:               			GsmUart_SendEnter();		// AT+CMGR=1;+CMGD=1\r\n
003BE4  071B6E     RCALL Uart2_SendEnter
281:               			*recSmsNr = '\0';
003BE6  227900     MOV #0x2790, W0
003BE8  EB4800     CLR.B [W0]
282:               			TimeOut = 200;						// wait 2 seconds
003BEA  200C80     MOV #0xC8, W0
003BEC  884010     MOV W0, TimeOut
003BEE  370055     BRA 0x3C9A
283:               		}
284:               		else if (IdleSeconds >= CsqTime)
003BF0  8040C1     MOV CsqTime, W1
003BF2  8040D0     MOV IdleSeconds, W0
003BF4  500F81     SUB W0, W1, [W15]
003BF6  390004     BRA NC, 0x3C00
285:               		{
286:               			IdleSeconds	= 0;
003BF8  EF281A     CLR IdleSeconds
287:               			GsmState	= GsmState_AT;
003BFA  200010     MOV #0x1, W0
003BFC  8840F0     MOV W0, GsmState
003BFE  37004D     BRA 0x3C9A
288:               		}
289:               		else if (Flags.Status == STATUS_TCP_ACTIVE)
003C00  804000     MOV Flags, W0
003C02  2FC003     MOV #0xFC00, W3
003C04  600103     AND W0, W3, W2
003C06  510F83     SUB W2, W3, [W15]
003C08  3A0037     BRA NZ, 0x3C78
290:               		{
291:               		#if	(TEST == GSM_TEST) || (!defined UART4_WIFI)
292:               			if (FL_TCP_READY)
003C0A  AB892C     BTST SysFlags, #4
003C0C  32001B     BRA Z, 0x3C44
293:               		#else
294:               			if ((FL_TCP_READY) && (FL_WIFI_OFFLINE))
295:               		#endif
296:               			{
297:               				register TCP_PACKET* packet = Tcp_GetUnsent();
003C0E  071080     RCALL Tcp_GetUnsent
003C10  780400     MOV W0, W8
298:               				if (packet)
003C12  E00008     CP0 W8
003C14  320015     BRA Z, 0x3C40
299:               				{
300:               //					register U16 len = TCP_PACKET_HEDER + packet->len;
301:               					register UNI16 a = {.u16 = 0};
302:               					a.u8l  = packet->len;
003C16  904018     MOV.B [W8+1], W0
003C18  FB8000     ZE W0, W0
303:               					a.u16 += TCP_PACKET_HEDER;					//		LEN_CHANGES
003C1A  4004E8     ADD W0, #0x8, W9
304:               					DebugSprintf(tmp, "Send GPRS Packet: Type_%02X, Len_%03u, Nr_%04X",	packet->type, packet->len, packet->nr);
003C1C  9000B8     MOV [W8+6], W1
003C1E  781F81     MOV W1, [W15++]
003C20  781F80     MOV W0, [W15++]
003C22  904038     MOV.B [W8+3], W0
003C24  FB8000     ZE W0, W0
003C26  781F80     MOV W0, [W15++]
003C28  2A05C0     MOV #0xA05C, W0
003C2A  781F80     MOV W0, [W15++]
003C2C  225380     MOV #0x2538, W0
003C2E  07EBBE     RCALL __sprintf_cdnopuxX, __sprintf_s, __sprintf_0, __sprintf_cdnopsuxX
305:               					DebugPrint(tmp);
003C30  225380     MOV #0x2538, W0
003C32  070B45     RCALL Usb_SendText
306:               					GsmUart_SendData((char*)packet->bytes, a.u16);
003C34  BE0008     MOV.D W8, W0
003C36  071B3A     RCALL Uart2_SendData
307:               //					GsmUart_SendData((char*)packet->bytes, len);
308:               					packet->start = 0;
003C38  EB4C00     CLR.B [W8]
309:               //					TimeOut		= 2;				// Timeout 0.02 sec
310:               					OkSeconds	= 0;
003C3A  EF281C     CLR OkSeconds
003C3C  5787E8     SUB W15, #0x8, W15
003C3E  37002D     BRA 0x3C9A
311:               				}
312:               				else
313:               					FL_TCP_READY = 0;
003C40  A9892C     BCLR SysFlags, #4
003C42  37002B     BRA 0x3C9A
314:               			}
315:               			else if (SendDataLen)
003C44  804041     MOV SendDataLen, W1
003C46  E00001     CP0 W1
003C48  32000B     BRA Z, 0x3C60
316:               			{
317:               				GsmUart_SendData(DataToSend, SendDataLen);
003C4A  804050     MOV DataToSend, W0
003C4C  071B2F     RCALL Uart2_SendData
318:               				DebugPrint("Gsm -> TCP Data send");
003C4E  2A08B0     MOV #0xA08B, W0
003C50  070B36     RCALL Usb_SendText
319:               				SendDataLen = 0;
003C52  EF2808     CLR SendDataLen
320:               				*DataToSend	= 0;
003C54  804050     MOV DataToSend, W0
003C56  EB4800     CLR.B [W0]
321:               				TimeOut		= 50;				// Timeout 0.5 sec
003C58  200320     MOV #0x32, W0
003C5A  884010     MOV W0, TimeOut
322:               				OkSeconds	= 0;
003C5C  EF281C     CLR OkSeconds
003C5E  37001D     BRA 0x3C9A
323:               			}
324:               			else if (OkSeconds >= GPRS_OK_TIMEOUT_S)
003C60  201670     MOV #0x167, W0
003C62  E3081C     CP OkSeconds
003C64  36001A     BRA LEU, 0x3C9A
325:               			{
326:               				DebugPrint("Gsm -> TCP OK send");
003C66  2A0A00     MOV #0xA0A0, W0
003C68  070B2A     RCALL Usb_SendText
327:               				GsmUart_SendData(OkPacket, TCP_PACKET_HEDER);			// TODO: feel OkPackets statuss (.nr)
003C6A  200081     MOV #0x8, W1
003C6C  227880     MOV #0x2788, W0
003C6E  071B1E     RCALL Uart2_SendData
328:               //				GsmUart_SendText("Ok\r\n");
329:               				TimeOut		= 2;				// Timeout 0.02 sec
003C70  200020     MOV #0x2, W0
003C72  884010     MOV W0, TimeOut
330:               				OkSeconds	= 0;
003C74  EF281C     CLR OkSeconds
003C76  370011     BRA 0x3C9A
331:               			}
332:               		}
333:               		else if (Flags.setup)
003C78  A39800     BTST.Z W0, #9
003C7A  320003     BRA Z, 0x3C82
334:               			GsmState = GsmState_newModule;
003C7C  200150     MOV #0x15, W0
003C7E  8840F0     MOV W0, GsmState
003C80  37000C     BRA 0x3C9A
335:               		else if (Flags.Status == STATUS_HOME)
003C82  2F0003     MOV #0xF000, W3
003C84  510F83     SUB W2, W3, [W15]
003C86  3A0003     BRA NZ, 0x3C8E
336:               		{
337:               			#if (GPRS == OFF_LINE)
338:               				if (!FL_GPRS_OFFLINE)
339:               			#endif
340:               			GsmState = GsmState_Connect;
003C88  200080     MOV #0x8, W0
003C8A  8840F0     MOV W0, GsmState
003C8C  370006     BRA 0x3C9A
341:               		}
342:               		else if (Flags.ackErr)
003C8E  A31800     BTST.Z W0, #1
003C90  320004     BRA Z, 0x3C9A
343:               		{
344:               			Flags.csq		= 0;
003C92  A9A801     BCLR 0x801, #5
345:               			Flags.home		= 0;
003C94  A98801     BCLR 0x801, #4
346:               			Flags.connect	= 0;
003C96  A96801     BCLR 0x801, #3
347:               			IdleSeconds		= CsqTime;
003C98  8840D1     MOV W1, IdleSeconds
348:               		}
349:               //		else if (OkSeconds < GPRS_RESTERT_TIMEOUT_S)
350:               			stateTimeout = 0;						// TODO ??????????????????????????
003C9A  EF6827     CLR.B stateTimeout
351:               		break;					}
003C9C  3702A2     BRA 0x41E2
352:               	case GsmState_AT:			{
353:               		if (!stateTimeout)
003C9E  E24827     CP0.B stateTimeout
003CA0  3A000A     BRA NZ, 0x3CB6
354:               //		if (!(stateTimeout & 0x3F))
355:               		{
356:               			Flags.Ack = 0;
003CA2  2FFE00     MOV #0xFFE0, W0
003CA4  B60800     AND Flags, WREG
003CA6  884000     MOV W0, Flags
357:               			if (Flags.transp)
003CA8  A3A800     BTST.Z W0, #10
003CAA  320002     BRA Z, 0x3CB0
358:               				GSM_DTR_ON();			// switch to command mode
003CAC  A822E4     BSET LATE, #1
003CAE  370299     BRA 0x41E2
359:               			else
360:               				GsmUart_SendText("AT\r\n");
003CB0  2A0B30     MOV #0xA0B3, W0
003CB2  071AF1     RCALL Uart2_SendText
003CB4  370296     BRA 0x41E2
361:               //			DebugPrint("Gsm - send AT (idle)");
362:               			break;
363:               		}
364:               		else if (Flags.ackOk)
003CB6  804000     MOV Flags, W0
003CB8  A30800     BTST.Z W0, #0
003CBA  320007     BRA Z, 0x3CCA
365:               		{
366:               			GSM_DTR_OFF();				// end of command mode switch impulss
003CBC  A922E4     BCLR LATE, #1
367:               			Flags.transp = 0;
003CBE  A94801     BCLR 0x801, #2
368:               			GsmState = GsmState_Csq;
003CC0  200020     MOV #0x2, W0
003CC2  8840F0     MOV W0, GsmState
369:               			lastGsmState = GsmState;	// continio imidiately
003CC4  884140     MOV W0, lastGsmState
370:               			stateTimeout = 0;
003CC6  EF6827     CLR.B stateTimeout
003CC8  37000A     BRA 0x3CDE
371:               		}
372:               		else
373:               		{
374:               			if (Flags.ackErr)
003CCA  A31800     BTST.Z W0, #1
003CCC  32028A     BRA Z, 0x41E2
375:               			{
376:               				GSM_DTR_OFF();				// end of command mode switch impulss
003CCE  A922E4     BCLR LATE, #1
377:               				Flags.transp	= 0;
003CD0  A94801     BCLR 0x801, #2
378:               				Flags.connect	= 0;
003CD2  A96801     BCLR 0x801, #3
379:               				GsmState		= GsmState_ChipStatus;
003CD4  200070     MOV #0x7, W0
003CD6  8840F0     MOV W0, GsmState
003CD8  370284     BRA 0x41E2
380:               			}
381:               			break;
382:               		}						}
383:               	case GsmState_Csq:			{
384:               		if (!stateTimeout)
003CDA  E24827     CP0.B stateTimeout
003CDC  3A0005     BRA NZ, 0x3CE8
385:               		{
386:               			Flags.Ack = 0;
003CDE  2FFE00     MOV #0xFFE0, W0
003CE0  B62800     AND Flags
387:               			GsmUart_SendText("AT+CSQ\r\n");
003CE2  2A0B80     MOV #0xA0B8, W0
003CE4  071AD8     RCALL Uart2_SendText
003CE6  37027D     BRA 0x41E2
388:               		}
389:               		else if (Flags.ackData)
003CE8  804000     MOV Flags, W0
003CEA  A32800     BTST.Z W0, #2
003CEC  32000A     BRA Z, 0x3D02
390:               		{
391:               			Csq = atoi(recGsmData);
003CEE  2000A2     MOV #0xA, W2
003CF0  EB0080     CLR W1
003CF2  804020     MOV recGsmData, W0
003CF4  07EAA5     RCALL __Stoul
003CF6  B7E820     MOV.B WREG, Csq
392:               			Flags.Ack = 0;
003CF8  2FFE00     MOV #0xFFE0, W0
003CFA  B62800     AND Flags
393:               			stateTimeout = 1;
003CFC  B3C010     MOV.B #0x1, W0
003CFE  B7E827     MOV.B WREG, stateTimeout
003D00  370270     BRA 0x41E2
394:               		}
395:               		else if (Flags.ackOk)
003D02  A30800     BTST.Z W0, #0
003D04  320037     BRA Z, 0x3D74
396:               		{
397:               			Flags.csq	= ((Csq >= 6) && (Csq <= 31))?	1 : 0;
003D06  208201     MOV #0x820, W1
003D08  784091     MOV.B [W1], W1
003D0A  50C0E6     SUB.B W1, #0x6, W1
003D0C  B3C010     MOV.B #0x1, W0
003D0E  50CFF9     SUB.B W1, #0x19, [W15]
003D10  360001     BRA LEU, 0x3D14
003D12  EB4000     CLR.B W0
003D14  600061     AND W0, #0x1, W0
003D16  DD004D     SL W0, #13, W0
003D18  804001     MOV Flags, W1
003D1A  A1D001     BCLR W1, #13
003D1C  700001     IOR W0, W1, W0
003D1E  884000     MOV W0, Flags
398:               			if		(Flags.connect)							// If TCP Connected
003D20  A3B800     BTST.Z W0, #11
003D22  320006     BRA Z, 0x3D30
399:               			{
400:               				GsmState	= GsmState_Ato;
003D24  200040     MOV #0x4, W0
003D26  8840F0     MOV W0, GsmState
401:               				TimeOut		= SMS_WAIT_TIMEOUT_10mS;		// Defined in GsmDefines.h (0.5 sec)
003D28  200320     MOV #0x32, W0
003D2A  884010     MOV W0, TimeOut
402:               				Flags.connect = 0;
003D2C  A96801     BCLR 0x801, #3
003D2E  37000D     BRA 0x3D4A
403:               			}
404:               			else if	((!Flags.home) && (Flags.csq))			// if not already at home network
003D30  230001     MOV #0x3000, W1
003D32  600001     AND W0, W1, W0
003D34  220001     MOV #0x2000, W1
003D36  500F81     SUB W0, W1, [W15]
003D38  3A0007     BRA NZ, 0x3D48
405:               			{
406:               				GsmUart_SendText("AT+CREG?\r\n");			// check network registration
003D3A  2A0C10     MOV #0xA0C1, W0
003D3C  071AAC     RCALL Uart2_SendText
407:               				TimeOut		= 100;							// Timeout 1.0 sec
003D3E  200640     MOV #0x64, W0
003D40  884010     MOV W0, TimeOut
408:               				Flags.Ack = 0;
003D42  2FFE00     MOV #0xFFE0, W0
003D44  B62800     AND Flags
003D46  370001     BRA 0x3D4A
409:               			}
410:               			else
411:               				GsmState	= GsmState_Idle;
003D48  EF281E     CLR GsmState
412:               //			GsmState	= GsmState_sms_check;
413:               			if (LastCsq != Csq)
003D4A  BFC820     MOV.B Csq, WREG
003D4C  E34821     CP.B LastCsq
003D4E  320249     BRA Z, 0x41E2
414:               			{
415:               				LastCsq = Csq;
003D50  B7E821     MOV.B WREG, LastCsq
416:               				OkPacket[6] = Csq;	// packet nr as Csq value
003D52  2278E1     MOV #0x278E, W1
003D54  784880     MOV.B W0, [W1]
417:               //				OkPacket[7] = 0;	// packet nr as Csq value
418:               				Tcp_PreparePacket((TCP_PACKET*)OkPacket, TYPE_OK_GPRS);
003D56  B3CF01     MOV.B #0xF0, W1
003D58  227880     MOV #0x2788, W0
003D5A  070FB1     RCALL Tcp_PreparePacket
419:               				DebugSprintf(gsmBuff, "CSQ = %u, Flags: 0x%04X", Csq, Flags.word);
003D5C  F80800     PUSH Flags
003D5E  BFC820     MOV.B Csq, WREG
003D60  FB8000     ZE W0, W0
003D62  781F80     MOV W0, [W15++]
003D64  2A0CC0     MOV #0xA0CC, W0
003D66  781F80     MOV W0, [W15++]
003D68  222100     MOV #0x2210, W0
003D6A  07EB20     RCALL __sprintf_cdnopuxX, __sprintf_s, __sprintf_0, __sprintf_cdnopsuxX
420:               				DebugPrint(gsmBuff);
003D6C  222100     MOV #0x2210, W0
003D6E  070AA7     RCALL Usb_SendText
003D70  5787E6     SUB W15, #0x6, W15
003D72  370237     BRA 0x41E2
421:               			}
422:               		}
423:               		else if (Flags.ackErr)
003D74  A31800     BTST.Z W0, #1
003D76  320235     BRA Z, 0x41E2
424:               		{
425:               			Csq				= 0;
003D78  EF6820     CLR.B Csq
426:               			Flags.csq		= 0;
003D7A  A9A801     BCLR 0x801, #5
427:               			stateTimeout	= 0;
003D7C  EF6827     CLR.B stateTimeout
428:               			GsmState = GsmState_Idle;
003D7E  EF281E     CLR GsmState
429:               			Flags.Ack = 0;
003D80  2FFE00     MOV #0xFFE0, W0
003D82  B62800     AND Flags
003D84  37022E     BRA 0x41E2
430:               		}
431:               		break;					}
432:               	case GsmState_Creg:			{
433:               		if (recGsmData[2] == ',')
003D86  804020     MOV recGsmData, W0
003D88  904120     MOV.B [W0+2], W2
003D8A  B3C2C1     MOV.B #0x2C, W1
003D8C  514F81     SUB.B W2, W1, [W15]
003D8E  3A000B     BRA NZ, 0x3DA6
434:               			Flags.home = (recGsmData[3] == '1')?	1 : 0;	// +CREG: 1,1	(after command AT+CREG?)
003D90  904030     MOV.B [W0+3], W0
003D92  B2C310     XOR.B #0x31, W0
003D94  FB8000     ZE W0, W0
003D96  E90000     DEC W0, W0
003D98  DE004F     LSR W0, #15, W0
003D9A  DD004C     SL W0, #12, W0
003D9C  804001     MOV Flags, W1
003D9E  A1C001     BCLR W1, #12
003DA0  700081     IOR W0, W1, W1
003DA2  884001     MOV W1, Flags
003DA4  37000A     BRA 0x3DBA
435:               		else
436:               			Flags.home = (recGsmData[1] == '1')?	1 : 0;	// +CREG: 1		(Unsolicited result code)
003DA6  904010     MOV.B [W0+1], W0
003DA8  B2C310     XOR.B #0x31, W0
003DAA  FB8000     ZE W0, W0
003DAC  E90000     DEC W0, W0
003DAE  DE004F     LSR W0, #15, W0
003DB0  DD004C     SL W0, #12, W0
003DB2  804001     MOV Flags, W1
003DB4  A1C001     BCLR W1, #12
003DB6  700081     IOR W0, W1, W1
003DB8  884001     MOV W1, Flags
437:               
438:               		GsmState = GsmState_Idle;
003DBA  EF281E     CLR GsmState
439:               		break;					}
003DBC  370212     BRA 0x41E2
440:               	case GsmState_Ato:			{
441:               		if (!stateTimeout)
003DBE  E24827     CP0.B stateTimeout
003DC0  3A0210     BRA NZ, 0x41E2
442:               		{
443:               			Flags.Ack = 0;
003DC2  2FFE00     MOV #0xFFE0, W0
003DC4  B62800     AND Flags
444:               			GsmUart_SendText("ATO\r\n");					// return to Data Mode (transparent)
003DC6  2A0E40     MOV #0xA0E4, W0
003DC8  071A66     RCALL Uart2_SendText
445:               			DebugPrint("ATO command\r\n");
003DCA  2A0EA0     MOV #0xA0EA, W0
003DCC  070A78     RCALL Usb_SendText
446:               			TimeOut		= 200;								// Timeout 2.0 sec
003DCE  200C80     MOV #0xC8, W0
003DD0  884010     MOV W0, TimeOut
003DD2  370207     BRA 0x41E2
447:               		}
448:               		break;					}
449:               	case GsmState_DataSend:		{		// NOT used currently
450:               		if (!stateTimeout)
003DD4  E24827     CP0.B stateTimeout
003DD6  3A000D     BRA NZ, 0x3DF2
451:               		{
452:               			Flags.Ack = 0;
003DD8  2FFE00     MOV #0xFFE0, W0
003DDA  B62800     AND Flags
453:               			sprintf(gsmBuff,"AT+CIPSEND=%u\r\n", SendDataLen);
003DDC  F80808     PUSH SendDataLen
003DDE  2A0F80     MOV #0xA0F8, W0
003DE0  781F80     MOV W0, [W15++]
003DE2  222100     MOV #0x2210, W0
003DE4  07EAE3     RCALL __sprintf_cdnopuxX, __sprintf_s, __sprintf_0, __sprintf_cdnopsuxX
454:               			GsmUart_SendText(gsmBuff);
003DE6  222100     MOV #0x2210, W0
003DE8  071A56     RCALL Uart2_SendText
455:               			DebugPrint(gsmBuff);
003DEA  222100     MOV #0x2210, W0
003DEC  070A68     RCALL Usb_SendText
003DEE  5787E4     SUB W15, #0x4, W15
003DF0  3701F8     BRA 0x41E2
456:               		}
457:               		else if ((Flags.ackOk) || (Flags.ackErr))
003DF2  804000     MOV Flags, W0
003DF4  600063     AND W0, #0x3, W0
003DF6  320004     BRA Z, 0x3E00
458:               		{
459:               			GsmState = GsmState_Idle;
003DF8  EF281E     CLR GsmState
460:               			DebugPrint("Gsm Data send Failure!!!");
003DFA  2A1080     MOV #0xA108, W0
003DFC  070A60     RCALL Usb_SendText
003DFE  3701F1     BRA 0x41E2
461:               		}
462:               		else if ((GsmByteReceived()) && (GsmUart_GetByte() == '>'))
003E00  071A18     RCALL Uart2_ByteReceived
003E02  E00400     CP0.B W0
003E04  32000C     BRA Z, 0x3E1E
003E06  071A1D     RCALL Uart2_GetByte
003E08  B3C3E1     MOV.B #0x3E, W1
003E0A  504F81     SUB.B W0, W1, [W15]
003E0C  3A0008     BRA NZ, 0x3E1E
463:               		{
464:               			GsmUart_SendData(DataToSend, SendDataLen);
003E0E  804041     MOV SendDataLen, W1
003E10  804050     MOV DataToSend, W0
003E12  071A4C     RCALL Uart2_SendData
465:               			GsmState = GsmState_Idle;
003E14  EF281E     CLR GsmState
466:               			SendDataLen = 0;
003E16  EF2808     CLR SendDataLen
467:               			TimeOut = 1000;
003E18  203E80     MOV #0x3E8, W0
003E1A  884010     MOV W0, TimeOut
003E1C  3701E2     BRA 0x41E2
468:               		}
469:               		else if (stateTimeout > 250)
003E1E  BFC827     MOV.B stateTimeout, WREG
003E20  404FE6     ADD.B W0, #0x6, [W15]
003E22  3601DF     BRA LEU, 0x41E2
470:               		{
471:               			GsmState = GsmState_ChipStatus;
003E24  200070     MOV #0x7, W0
003E26  8840F0     MOV W0, GsmState
472:               			DebugPrint("Gsm '>' not received!!!");
003E28  2A1210     MOV #0xA121, W0
003E2A  070A49     RCALL Usb_SendText
003E2C  3701DA     BRA 0x41E2
473:               		}
474:               		break;					}
475:               	case GsmState_OKsend:		{		// NOT used currently
476:               //		if (!stateTimeout)
477:               		{
478:               			Flags.Ack = 0;
003E2E  2FFE00     MOV #0xFFE0, W0
003E30  B62800     AND Flags
479:               			GsmUart_SendText("OK\r\n");
003E32  2A1390     MOV #0xA139, W0
003E34  071A30     RCALL Uart2_SendText
480:               			DebugPrint("Gsm -> TCP OK send");
003E36  2A0A00     MOV #0xA0A0, W0
003E38  070A42     RCALL Usb_SendText
481:               			GsmState = GsmState_Idle;
003E3A  EF281E     CLR GsmState
482:               		}
483:               /*		else if ((Flags.ackOk) || (Flags.ackErr))
484:               		{
485:               			GsmState = GsmState_Idle;
486:               			DebugPrint("Gsm Ok send Failure!!!");
487:               		}
488:               		else if ((GsmByteReceived()) && (GsmUart_GetByte() == '>'))
489:               		{
490:               			GsmUart_SendText("Ok\r\n");
491:               			GsmUart_SendByte(CTRL_Z);
492:               			GsmState = GsmState_Idle;
493:               			TimeOut = 1000;
494:               		}
495:               		else if (stateTimeout > 250)
496:               		{
497:               			GsmState = GsmState_ChipStatus;
498:               			DebugPrint("Gsm '>' not received!!!");
499:               		}
500:               */
501:               		break;					}
003E3C  3701D2     BRA 0x41E2
502:               	case GsmState_ChipStatus:	{
503:               		if (!stateTimeout)
003E3E  BFC827     MOV.B stateTimeout, WREG
003E40  3A0007     BRA NZ, 0x3E50
504:               		{
505:               			Flags.Ack = 0;
003E42  2FFE00     MOV #0xFFE0, W0
003E44  B62800     AND Flags
506:               			GsmUart_SendText("AT+CIPSTATUS\r\n");
003E46  2A13E0     MOV #0xA13E, W0
003E48  071A26     RCALL Uart2_SendText
507:               			DebugPrint("Gsm -> AT+CIPSTATUS");
003E4A  2A14D0     MOV #0xA14D, W0
003E4C  070A38     RCALL Usb_SendText
003E4E  3701C9     BRA 0x41E2
508:               		}
509:               		else if (stateTimeout > 250)
003E50  404FE6     ADD.B W0, #0x6, [W15]
003E52  3601C7     BRA LEU, 0x41E2
510:               		{
511:               			DebugPrint("Gsm +CIPSTATUS Timeout -> restart module");
003E54  2A1610     MOV #0xA161, W0
003E56  070A33     RCALL Usb_SendText
512:               			GsmState = GsmState_PowerOn;				// TODO: normal restart in future
003E58  2000D0     MOV #0xD, W0
003E5A  8840F0     MOV W0, GsmState
003E5C  3701C2     BRA 0x41E2
513:               		}
514:               		break;					}
515:               	case GsmState_Connect:		{
516:               		if (!stateTimeout)
003E5E  BFC827     MOV.B stateTimeout, WREG
003E60  3A000D     BRA NZ, 0x3E7C
517:               		{
518:               			Flags.Ack = 0;
003E62  2FFE00     MOV #0xFFE0, W0
003E64  B62800     AND Flags
519:               			GsmUart_SendText("AT+CIPSTART=\"tcp\",\"");
003E66  2A18A0     MOV #0xA18A, W0
003E68  071A16     RCALL Uart2_SendText
520:               			GsmUart_SendText(SERVER);
003E6A  2A19E0     MOV #0xA19E, W0
003E6C  071A14     RCALL Uart2_SendText
521:               			GsmUart_SendText("\",\"");
003E6E  2A1AF0     MOV #0xA1AF, W0
003E70  071A12     RCALL Uart2_SendText
522:               			GsmUart_SendText(PORT);
003E72  2A1B30     MOV #0xA1B3, W0
003E74  071A10     RCALL Uart2_SendText
523:               			GsmUart_SendText("\"\r\n");
003E76  2A1B90     MOV #0xA1B9, W0
003E78  071A0E     RCALL Uart2_SendText
003E7A  3701B3     BRA 0x41E2
524:               //			DebugPrint("Gsm Connect Command");
525:               		}
526:               		else if (Flags.ackOk)
003E7C  AB0800     BTST Flags, #0
003E7E  320008     BRA Z, 0x3E90
527:               		{
528:               			Flags.ackOk = 0;
003E80  A90800     BCLR Flags, #0
529:               //			GsmState = GsmState_Idle;
530:               //			OkSeconds = 0;
531:               			OkSeconds = GPRS_OK_TIMEOUT_S;				// Temporary
003E82  201680     MOV #0x168, W0
003E84  8840E0     MOV W0, OkSeconds
532:               			DebugPrint("Connect command Ok -> wait connection 90sec");
003E86  2A1BD0     MOV #0xA1BD, W0
003E88  070A1A     RCALL Usb_SendText
533:               			TimeOut = 9000;				// Timeout 90.0sec
003E8A  223280     MOV #0x2328, W0
003E8C  884010     MOV W0, TimeOut
003E8E  3701A9     BRA 0x41E2
534:               		}
535:               		else if (stateTimeout > 200)
003E90  B3CC81     MOV.B #0xC8, W1
003E92  504F81     SUB.B W0, W1, [W15]
003E94  3601A6     BRA LEU, 0x41E2
536:               		{
537:               			GsmUart_SendText("AT+CIPCLOSE\r\n");
003E96  2A1E90     MOV #0xA1E9, W0
003E98  0719FE     RCALL Uart2_SendText
538:               			GsmState = GsmState_DisConnected;
003E9A  2000A0     MOV #0xA, W0
003E9C  8840F0     MOV W0, GsmState
539:               			DebugPrint("Connection Timeout !!!");
003E9E  2A1F70     MOV #0xA1F7, W0
003EA0  070A0E     RCALL Usb_SendText
540:               			TimeOut = 1000;				// Timeout 10.0sec
003EA2  203E80     MOV #0x3E8, W0
003EA4  884010     MOV W0, TimeOut
003EA6  37019D     BRA 0x41E2
541:               		}
542:               		break;					}
543:               	case GsmState_Connected:	{
544:               		DebugPrint("Gsm GsmState_Connected...");
003EA8  2A20E0     MOV #0xA20E, W0
003EAA  070A09     RCALL Usb_SendText
545:               		GsmState		= GsmState_Idle;
003EAC  EF281E     CLR GsmState
546:               		break;					}
003EAE  370199     BRA 0x41E2
547:               	case GsmState_DisConnected:	{
548:               		GSM_DTR_ON();
003EB0  A822E4     BSET LATE, #1
549:               		DebugPrint("GPRS Connection Error -> tray to reconnect");
003EB2  2A2280     MOV #0xA228, W0
003EB4  070A04     RCALL Usb_SendText
550:               		Flags.csq		= 0;			// wait csq ok
003EB6  A9A801     BCLR 0x801, #5
551:               		Flags.connect	= 0;			// Clear connect flag
003EB8  A96801     BCLR 0x801, #3
552:               		Flags.transp	= 0;
003EBA  A94801     BCLR 0x801, #2
553:               //		OkSeconds		= 0;
554:               		GsmState		= GsmState_Idle;
003EBC  EF281E     CLR GsmState
555:               		GSM_DTR_OFF();
003EBE  A922E4     BCLR LATE, #1
556:               		break;					}
003EC0  370190     BRA 0x41E2
557:               	case GsmState_SendOk:		{		// NOT used currently
558:               		OkSeconds		= 0;
003EC2  EF281C     CLR OkSeconds
559:               		GsmState		= GsmState_Idle;
003EC4  EF281E     CLR GsmState
560:               		break;					}
003EC6  37018D     BRA 0x41E2
561:               
562:               	case GsmState_PowerOn:		{
563:               		GSM_POWER	= !GSM_POWER;			// 0 - On; 1 - Off
003EC8  801740     MOV TRISF, W0
003ECA  600062     AND W0, #0x2, W0
003ECC  E90000     DEC W0, W0
003ECE  DE004F     LSR W0, #15, W0
003ED0  400000     ADD W0, W0, W0
003ED2  801741     MOV TRISF, W1
003ED4  A11001     BCLR W1, #1
003ED6  700081     IOR W0, W1, W1
003ED8  881741     MOV W1, TRISF
564:               		ledStatus	= LED_STATUS_OFF;
003EDA  EF2824     CLR ledStatus
565:               		GSM_DTR_OFF();
003EDC  A922E4     BCLR LATE, #1
566:               		if (GSM_POWER)					// if already powered, restart
003EDE  AB22E8     BTST TRISF, #1
003EE0  320005     BRA Z, 0x3EEC
567:               		{
568:               			TimeOut = 2000;				// Timeout 20.0sec
003EE2  207D00     MOV #0x7D0, W0
003EE4  884010     MOV W0, TimeOut
569:               			DebugPrint("Gsm Power Restart 2.0 sec");
003EE6  2A2530     MOV #0xA253, W0
003EE8  0709EA     RCALL Usb_SendText
570:               			return;
003EEA  37017F     BRA 0x41EA
571:               		}
572:               		DebugPrint("Gsm Power On 1.0 sec");
003EEC  2A26D0     MOV #0xA26D, W0
003EEE  0709E7     RCALL Usb_SendText
573:               		GsmState++;
003EF0  EC281E     INC GsmState
574:               		TimeOut = 100;					// Timeout 1 sec
003EF2  200640     MOV #0x64, W0
003EF4  884010     MOV W0, TimeOut
575:               		break;					}
003EF6  370175     BRA 0x41E2
576:               	case GsmState_PowerKeyOn:	{
577:               		GSM_RTS_OFF();
003EF8  A842E0     BSET TRISE, #2
578:               		GSM_PK_ON();
003EFA  A982D8     BCLR TRISD, #4
579:               		GsmUart_Init(BaudRate_38400);
003EFC  200020     MOV #0x2, W0
003EFE  071912     RCALL Uart2_Init
580:               		GsmFlags		= 0;
003F00  EF2800     CLR Flags
581:               		FL_GPRS_REC		= 0;
003F02  A9492C     BCLR SysFlags, #2
582:               		PackRecTimeout	= 0;
003F04  EF280C     CLR PackRecTimeout
583:               		ledStatus		= LED_STATUS_1;
003F06  280000     MOV #0x8000, W0
003F08  884120     MOV W0, ledStatus
584:               		DebugPrint("Gsm Power Key On 1.0 sec");
003F0A  2A2820     MOV #0xA282, W0
003F0C  0709D8     RCALL Usb_SendText
585:               		GsmState++;
003F0E  EC281E     INC GsmState
586:               		TimeOut = 150;					// Timeout 1.5 sec
003F10  200960     MOV #0x96, W0
003F12  884010     MOV W0, TimeOut
587:               		break;					}
003F14  370166     BRA 0x41E2
588:               	case GsmState_PowerKeyOff:	{
589:               		if (GSM_STATUS)
003F16  AB42E2     BTST PORTE, #2
003F18  320008     BRA Z, 0x3F2A
590:               		{
591:               			GSM_PK_OFF();
003F1A  A882D8     BSET TRISD, #4
592:               			GSM_RTS_ON();
003F1C  A942E0     BCLR TRISE, #2
593:               //			GSM_DTR_OFF();
594:               			DebugPrint("Gsm Status Ok");
003F1E  2A29B0     MOV #0xA29B, W0
003F20  0709CE     RCALL Usb_SendText
595:               			GsmState++;
003F22  EC281E     INC GsmState
596:               			TimeOut = 50;					// Timeout 0.1 sec
003F24  200320     MOV #0x32, W0
003F26  884010     MOV W0, TimeOut
003F28  37015C     BRA 0x41E2
597:               		}
598:               		else if ((!GSM_P_KEY) && (stateTimeout > 200))		// Turn off Power key after 2 sec
003F2A  AB82D8     BTST TRISD, #4
003F2C  3A0008     BRA NZ, 0x3F3E
003F2E  B3CC80     MOV.B #0xC8, W0
003F30  E34827     CP.B stateTimeout
003F32  360005     BRA LEU, 0x3F3E
599:               		{
600:               			GSM_PK_OFF();
003F34  A882D8     BSET TRISD, #4
601:               			GSM_RTS_ON();
003F36  A942E0     BCLR TRISE, #2
602:               			DebugPrint("Gsm Power Key Off (2 sec timeout)");
003F38  2A2A90     MOV #0xA2A9, W0
003F3A  0709C1     RCALL Usb_SendText
003F3C  370152     BRA 0x41E2
603:               		}
604:               		else if (stateTimeout > 250)
003F3E  BFC827     MOV.B stateTimeout, WREG
003F40  404FE6     ADD.B W0, #0x6, [W15]
003F42  36014F     BRA LEU, 0x41E2
605:               			GsmState = GsmState_PowerOn;
003F44  2000D0     MOV #0xD, W0
003F46  8840F0     MOV W0, GsmState
003F48  37014C     BRA 0x41E2
606:               		break;					}
607:               	case GsmState_waitRDY:		{
608:               		if (stateTimeout > 200)				// RDY not received
003F4A  B3CC80     MOV.B #0xC8, W0
003F4C  E34827     CP.B stateTimeout
003F4E  360149     BRA LEU, 0x41E2
609:               		{
610:               			GsmState = GsmState_newModule;
003F50  200150     MOV #0x15, W0
003F52  8840F0     MOV W0, GsmState
611:               			DebugPrint("Gsm RDY not received");
003F54  2A2CB0     MOV #0xA2CB, W0
003F56  0709B3     RCALL Usb_SendText
003F58  370144     BRA 0x41E2
612:               		}
613:               		break;					}
614:               	case GsmState_CPIN:			{
615:               		if (stateTimeout > 200)					// +CPIN: READY not received
003F5A  B3CC80     MOV.B #0xC8, W0
003F5C  E34827     CP.B stateTimeout
003F5E  360141     BRA LEU, 0x41E2
616:               		{
617:               //			GsmState = GsmState_Idle;			// temporary
618:               			DebugPrint("Gsm CPIN Error");
003F60  2A2E00     MOV #0xA2E0, W0
003F62  0709AD     RCALL Usb_SendText
619:               			GSM_LED		= LED_STATUS_ERROR;		// Indicate ERROR
003F64  2AAAA0     MOV #0xAAAA, W0
003F66  8844A0     MOV W0, LedStatus1
620:               			GSM_POWER	= 1;					// Module Power Off
003F68  A822E8     BSET TRISF, #1
621:               			GSM_IE		= 0;					// Gsm Irq Off
003F6A  A90096     BCLR IEC1, #0
622:               			GsmFlags	= 0;					// Gsm flags = 0
003F6C  EF2800     CLR Flags
623:               			return;
003F6E  37013D     BRA 0x41EA
624:               		}
625:               		break;					}
626:               	case GsmState_StartSetup:	{
627:               		if (!stateTimeout)
003F70  BFC827     MOV.B stateTimeout, WREG
003F72  3A000F     BRA NZ, 0x3F92
628:               		{
629:               			Flags.Ack = 0;
003F74  2FFE00     MOV #0xFFE0, W0
003F76  B62800     AND Flags
630:               			GsmUart_SendText("AT+CDNSCFG=\"");
003F78  2A2EF0     MOV #0xA2EF, W0
003F7A  07198D     RCALL Uart2_SendText
631:               			GsmUart_SendText(DNS_1);
003F7C  2A2FC0     MOV #0xA2FC, W0
003F7E  07198B     RCALL Uart2_SendText
632:               			GsmUart_SendText("\",\"");
003F80  2A1AF0     MOV #0xA1AF, W0
003F82  071989     RCALL Uart2_SendText
633:               			GsmUart_SendText(DNS_2);
003F84  2A30A0     MOV #0xA30A, W0
003F86  071987     RCALL Uart2_SendText
634:               			GsmUart_SendText("\";+CDNSORIP=1;+CIPMODE=1;+CREG=1\r\n");	// Domain On; Transparent On; Network registration On
003F88  2A3150     MOV #0xA315, W0
003F8A  071985     RCALL Uart2_SendText
635:               			DebugPrint("Gsm set DNS");
003F8C  2A3380     MOV #0xA338, W0
003F8E  070997     RCALL Usb_SendText
003F90  370128     BRA 0x41E2
636:               		}
637:               		else if (Flags.ackOk)
003F92  AB0800     BTST Flags, #0
003F94  32000B     BRA Z, 0x3FAC
638:               		{
639:               			DebugPrint("Gsm DNS Ok");
003F96  2A3440     MOV #0xA344, W0
003F98  070992     RCALL Usb_SendText
640:               			if (Flags.active)
003F9A  ABC801     BTST 0x801, #6
003F9C  320002     BRA Z, 0x3FA2
641:               				GsmState = GsmState_Idle;
003F9E  EF281E     CLR GsmState
003FA0  370120     BRA 0x41E2
642:               			else
643:               			{
644:               				GsmState = GsmState_callReady;
003FA2  200130     MOV #0x13, W0
003FA4  8840F0     MOV W0, GsmState
645:               				TimeOut = 3000;
003FA6  20BB80     MOV #0xBB8, W0
003FA8  884010     MOV W0, TimeOut
003FAA  37011B     BRA 0x41E2
646:               			}
647:               		}
648:               		else if (stateTimeout > 250)
003FAC  404FE6     ADD.B W0, #0x6, [W15]
003FAE  360119     BRA LEU, 0x41E2
649:               		{
650:               			DebugPrint("Gsm DNS setup Error -> restart module");
003FB0  2A34F0     MOV #0xA34F, W0
003FB2  070985     RCALL Usb_SendText
651:               			GsmState = GsmState_PowerOn;				// TODO: normal restart in future
003FB4  2000D0     MOV #0xD, W0
003FB6  8840F0     MOV W0, GsmState
003FB8  370114     BRA 0x41E2
652:               		}
653:               		break;					}
654:               	case GsmState_callReady:	{
655:               		if (Flags.active)
003FBA  ABC801     BTST 0x801, #6
003FBC  320002     BRA Z, 0x3FC2
656:               			GsmState = GsmState_Idle;
003FBE  EF281E     CLR GsmState
003FC0  370110     BRA 0x41E2
657:               		else if (stateTimeout > 200)					// Call Ready not received
003FC2  B3CC80     MOV.B #0xC8, W0
003FC4  E34827     CP.B stateTimeout
003FC6  36010D     BRA LEU, 0x41E2
658:               		{
659:               			GsmState = GsmState_Idle;			// temporary
003FC8  EF281E     CLR GsmState
660:               			DebugPrint("Gsm Call_Ready Error !!!");
003FCA  2A3750     MOV #0xA375, W0
003FCC  070978     RCALL Usb_SendText
003FCE  370109     BRA 0x41E2
661:               		}
662:               		break;					}
663:               	case GsmState_newModule:	{
664:               		if		(Flags.ackOk)
003FD0  AB0800     BTST Flags, #0
003FD2  320003     BRA Z, 0x3FDA
665:               			GsmState++;
003FD4  200160     MOV #0x16, W0
003FD6  8840F0     MOV W0, GsmState
003FD8  370104     BRA 0x41E2
666:               		else if	(!(stateTimeout & 0x3F))
003FDA  BFC827     MOV.B stateTimeout, WREG
003FDC  780080     MOV W0, W1
003FDE  B203F1     AND #0x3F, W1
003FE0  3A0007     BRA NZ, 0x3FF0
667:               		{
668:               			Flags.Ack = 0;
003FE2  2FFE00     MOV #0xFFE0, W0
003FE4  B62800     AND Flags
669:               			GsmUart_SendText("AT\r\n");
003FE6  2A0B30     MOV #0xA0B3, W0
003FE8  071956     RCALL Uart2_SendText
670:               			DebugPrint("Gsm - send AT");
003FEA  2A38E0     MOV #0xA38E, W0
003FEC  070968     RCALL Usb_SendText
003FEE  3700F9     BRA 0x41E2
671:               		}
672:               		else if (stateTimeout > 240)
003FF0  404FF0     ADD.B W0, #0x10, [W15]
003FF2  3600F7     BRA LEU, 0x41E2
673:               		{
674:               			static	BAUDRATE	InitBaudRate	= BaudRate_9600;
675:               			#if	(TEST == GSM_TEST)
676:               				switch (InitBaudRate)
003FF4  804110     MOV InitBaudRate, W0
003FF6  500FE2     SUB W0, #0x2, [W15]
003FF8  320012     BRA Z, 0x401E
003FFA  3E0005     BRA GTU, 0x4006
003FFC  E00000     CP0 W0
003FFE  320009     BRA Z, 0x4012
004000  500FE1     SUB W0, #0x1, [W15]
004002  3A0018     BRA NZ, 0x4034
004004  370009     BRA 0x4018
004006  500FE4     SUB W0, #0x4, [W15]
004008  320010     BRA Z, 0x402A
00400A  39000C     BRA NC, 0x4024
00400C  500FE5     SUB W0, #0x5, [W15]
00400E  3A0012     BRA NZ, 0x4034
004010  37000F     BRA 0x4030
677:               				{
678:               				case BaudRate_9600:		DebugPrint("Gsm BaudRate changed to 9600");		break;
004012  2A39C0     MOV #0xA39C, W0
004014  070954     RCALL Usb_SendText
004016  37000E     BRA 0x4034
679:               				case BaudRate_19200:	DebugPrint("Gsm BaudRate changed to 19200");	break;
004018  2A3B90     MOV #0xA3B9, W0
00401A  070951     RCALL Usb_SendText
00401C  37000B     BRA 0x4034
680:               				case BaudRate_38400:	DebugPrint("Gsm BaudRate changed to 38400");	break;
00401E  2A3D70     MOV #0xA3D7, W0
004020  07094E     RCALL Usb_SendText
004022  370008     BRA 0x4034
681:               				case BaudRate_57600:	DebugPrint("Gsm BaudRate changed to 57600");	break;
004024  2A3F50     MOV #0xA3F5, W0
004026  07094B     RCALL Usb_SendText
004028  370005     BRA 0x4034
682:               				case BaudRate_115200:	DebugPrint("Gsm BaudRate changed to 115200");	break;
00402A  2A4130     MOV #0xA413, W0
00402C  070948     RCALL Usb_SendText
00402E  370002     BRA 0x4034
683:               				case BaudRate_none:		DebugPrint("Gsm no response from module !!!");  break;
004030  2A4320     MOV #0xA432, W0
004032  070945     RCALL Usb_SendText
684:               				}
685:               			#endif
686:               			if (InitBaudRate == BaudRate_none)
004034  804110     MOV InitBaudRate, W0
004036  500FE5     SUB W0, #0x5, [W15]
004038  3A000A     BRA NZ, 0x404E
687:               			{										// All baudrates already tested
688:               				GSM_LED		= LED_STATUS_ERROR;		// Indicate ERROR
00403A  2AAAA0     MOV #0xAAAA, W0
00403C  8844A0     MOV W0, LedStatus1
689:               				GSM_POWER	= 1;					// Module Power Off
00403E  A822E8     BSET TRISF, #1
690:               //				GSM_IE		= 0;					// Gsm Irq Off
691:               				GsmFlags	= 0;					// Gsm flags = 0
004040  EF2800     CLR Flags
692:               				InitBaudRate	= BaudRate_9600;
004042  EF2822     CLR InitBaudRate
693:               				GsmState	= GsmState_PowerOn;
004044  2000D0     MOV #0xD, W0
004046  8840F0     MOV W0, GsmState
694:               				TimeOut		= 12000;					// Timeout 120.0sec
004048  22EE00     MOV #0x2EE0, W0
00404A  884010     MOV W0, TimeOut
695:               				return;
00404C  3700CE     BRA 0x41EA
696:               			}
697:               			GsmUart_SetBaudrate(InitBaudRate++);
00404E  E80080     INC W0, W1
004050  884111     MOV W1, InitBaudRate
004052  071888     RCALL Uart2_SetBaudrate
698:               			stateTimeout = 0;
004054  EF6827     CLR.B stateTimeout
699:               			Flags.Ack = 0;
004056  2FFE00     MOV #0xFFE0, W0
004058  B62800     AND Flags
700:               			GsmUart_SendText("AT\r\n");
00405A  2A0B30     MOV #0xA0B3, W0
00405C  07191C     RCALL Uart2_SendText
00405E  3700C1     BRA 0x41E2
701:               		}
702:               		break;					}
703:               	case GsmState_ModuleSetup:	{	// Set & STORE CURRENT PARAMETER TO USER DEFINED PROFILE
704:               		if (!(stateTimeout & 0x3F))
004060  BFC827     MOV.B stateTimeout, WREG
004062  B203F0     AND #0x3F, W0
004064  3A0007     BRA NZ, 0x4074
705:               		{
706:               			Flags.Ack = 0;
004066  2FFE00     MOV #0xFFE0, W0
004068  B62800     AND Flags
707:               			GsmUart_SendText("ATE0;+CMEE=0;+IFC=2,2;+IPR=38400;&D1;&W\r\n");
00406A  2A4520     MOV #0xA452, W0
00406C  071914     RCALL Uart2_SendText
708:               			DebugPrint("Gsm send module setup parameters");
00406E  2A47C0     MOV #0xA47C, W0
004070  070926     RCALL Usb_SendText
004072  3700B7     BRA 0x41E2
709:               		}
710:               		else if (Flags.ackOk)
004074  AB0800     BTST Flags, #0
004076  3200B5     BRA Z, 0x41E2
711:               		{
712:               			GsmState = GsmState_SmsSetup;
004078  200170     MOV #0x17, W0
00407A  8840F0     MOV W0, GsmState
713:               			DebugPrint("Gsm setup ok");
00407C  2A49D0     MOV #0xA49D, W0
00407E  07091F     RCALL Usb_SendText
004080  3700B0     BRA 0x41E2
714:               		}
715:               		break;					}
716:               	case GsmState_SmsSetup:	{	// Set & STORE CURRENT PARAMETER TO USER DEFINED PROFILE
717:               		if (!(stateTimeout & 0x3F))
004082  BFC827     MOV.B stateTimeout, WREG
004084  B203F0     AND #0x3F, W0
004086  3A0007     BRA NZ, 0x4096
718:               		{
719:               			Flags.Ack = 0;
004088  2FFE00     MOV #0xFFE0, W0
00408A  B62800     AND Flags
720:               			GsmUart_SendText("AT+CLIP=1;&W;+COLP=1;&W;+COPS=0;&W;+CMGF=1;&W;+CNMI=2,1,0,0,0;&W;+CSAS=0;&W\r\n");
00408C  2A4AA0     MOV #0xA4AA, W0
00408E  071903     RCALL Uart2_SendText
721:               			DebugPrint("Gsm send SMS setup parameters");
004090  2A4F80     MOV #0xA4F8, W0
004092  070915     RCALL Usb_SendText
004094  3700A6     BRA 0x41E2
722:               		}
723:               		else if (Flags.ackOk)
004096  AB0800     BTST Flags, #0
004098  3200A4     BRA Z, 0x41E2
724:               		{
725:               			GsmState = GsmState_setAPN;
00409A  200180     MOV #0x18, W0
00409C  8840F0     MOV W0, GsmState
726:               			DebugPrint("Gsm SMS setup ok");
00409E  2A5160     MOV #0xA516, W0
0040A0  07090E     RCALL Usb_SendText
0040A2  37009F     BRA 0x41E2
727:               		}
728:               		break;					}
729:               	case GsmState_setAPN:		{	// Set TCPIP APPLICATION CONTEXT & SAVE in module non volatile memory
730:               		if (!stateTimeout)
0040A4  BFC827     MOV.B stateTimeout, WREG
0040A6  3A000B     BRA NZ, 0x40BE
731:               		{
732:               			Flags.Ack = 0;
0040A8  2FFE00     MOV #0xFFE0, W0
0040AA  B62800     AND Flags
733:               			GsmUart_SendText("AT+CDNSORIP=1;+CIPSPRT=1;+CIPHEAD=0;+CIPFLP=0;+CIPSRIP=0;+CIPCSGP=1,\"");
0040AC  2A5270     MOV #0xA527, W0
0040AE  0718F3     RCALL Uart2_SendText
734:               			GsmUart_SendText(APN);
0040B0  2A56D0     MOV #0xA56D, W0
0040B2  0718F1     RCALL Uart2_SendText
735:               			GsmUart_SendText("\";+CIPCCFG=3,2,256,1;+CIPSCONT\r\n");
0040B4  2A57D0     MOV #0xA57D, W0
0040B6  0718EF     RCALL Uart2_SendText
736:               			DebugPrint("Gsm GPRS parameters setup");
0040B8  2A59E0     MOV #0xA59E, W0
0040BA  070901     RCALL Usb_SendText
0040BC  370092     BRA 0x41E2
737:               		}
738:               		else if (Flags.ackOk)
0040BE  AB0800     BTST Flags, #0
0040C0  320005     BRA Z, 0x40CC
739:               		{
740:               			GsmState = GsmState_PowerOn;				// TODO: normal restart in future
0040C2  2000D0     MOV #0xD, W0
0040C4  8840F0     MOV W0, GsmState
741:               			DebugPrint("Gsm gprs setup ok -> restart module");
0040C6  2A5B80     MOV #0xA5B8, W0
0040C8  0708FA     RCALL Usb_SendText
0040CA  37008B     BRA 0x41E2
742:               		}
743:               		else if (stateTimeout > 200)
0040CC  B3CC81     MOV.B #0xC8, W1
0040CE  504F81     SUB.B W0, W1, [W15]
0040D0  360088     BRA LEU, 0x41E2
744:               		{
745:               			DebugPrint("Gsm gprs setup Error -> restart module");
0040D2  2A5DC0     MOV #0xA5DC, W0
0040D4  0708F4     RCALL Usb_SendText
746:               			GsmState = GsmState_PowerOn;				// TODO: normal restart in future
0040D6  2000D0     MOV #0xD, W0
0040D8  8840F0     MOV W0, GsmState
0040DA  370083     BRA 0x41E2
0040DC  804020     MOV recGsmData, W0
0040E0  780100     MOV W0, W2
747:               		}
748:               		break;					}
749:               	case GsmState_sms_received:	{
750:               		U8 i = 0;
751:               //		Tcp_SendText(irqBuf);
752:               		while((*recGsmData) && (*recGsmData++ != ','));								// +CMTI:SM,12
0040DE  B3C2C3     MOV.B #0x2C, W3
0040E2  7840B0     MOV.B [W0++], W1
0040E4  E00401     CP0.B W1
0040E6  3A0006     BRA NZ, 0x40F4
0040E8  884022     MOV W2, recGsmData
0040EA  804020     MOV recGsmData, W0
0040EC  2278F2     MOV #0x278F, W2
0040F4  50CF83     SUB.B W1, W3, [W15]
0040F6  3AFFF4     BRA NZ, 0x40E0
0040F8  884020     MOV W0, recGsmData
0040FA  37FFF7     BRA 0x40EA
753:               		while((IS_DIGIT(*recGsmData)) && (i < (sizeof(recSmsNr) - 1)))
0040F0  B3CD04     MOV.B #0xD0, W4
0040F2  370007     BRA 0x4102
004102  784190     MOV.B [W0], W3
004104  41C284     ADD.B W3, W4, W5
004106  52CFE9     SUB.B W5, #0x9, [W15]
004108  360002     BRA LEU, 0x410E
00410A  884020     MOV W0, recGsmData
00410C  370003     BRA 0x4114
00410E  50CFE3     SUB.B W1, #0x3, [W15]
004110  3AFFF5     BRA NZ, 0x40FC
004112  884020     MOV W0, recGsmData
754:               			recSmsNr[i++] = *recGsmData++;
0040FC  786903     MOV.B W3, [++W2]
0040FE  E84081     INC.B W1, W1
755:               		recSmsNr[i] = '\0';
004114  FB8081     ZE W1, W1
004116  227900     MOV #0x2790, W0
004118  EB4100     CLR.B W2
00411A  78F002     MOV.B W2, [W0+W1]
756:               		sprintf(gsmBuff, "Sms Nr: %s received", recSmsNr);
00411C  781F80     MOV W0, [W15++]
00411E  2A6030     MOV #0xA603, W0
004120  781F80     MOV W0, [W15++]
004122  222100     MOV #0x2210, W0
004124  07E943     RCALL __sprintf_cdnopuxX, __sprintf_s, __sprintf_0, __sprintf_cdnopsuxX
757:               		Tcp_SendText(gsmBuff);
004126  222100     MOV #0x2210, W0
004128  070E90     RCALL Tcp_SendText
758:               //		DebugSprintf(gsmBuff, "Sms Nr: %s received", recSmsNr);
759:               		DebugPrint(gsmBuff);
00412A  222100     MOV #0x2210, W0
00412C  0708C8     RCALL Usb_SendText
760:               		GsmState = GsmState_Idle;
00412E  EF281E     CLR GsmState
761:               		break;					}
004130  5787E4     SUB W15, #0x4, W15
004132  370057     BRA 0x41E2
762:               	case GsmState_sms_check:	{
763:               		if (!stateTimeout)
004134  E24827     CP0.B stateTimeout
004136  3A0005     BRA NZ, 0x4142
764:               		{
765:               			GsmUart_SendText("AT+CMGL\r\n");
004138  2A6170     MOV #0xA617, W0
00413A  0718AD     RCALL Uart2_SendText
766:               			Flags.Ack = 0;
00413C  2FFE00     MOV #0xFFE0, W0
00413E  B62800     AND Flags
004140  370050     BRA 0x41E2
767:               		}
768:               		else if (Flags.ackOk)
004142  804000     MOV Flags, W0
004144  A30800     BTST.Z W0, #0
004146  32004D     BRA Z, 0x41E2
769:               		{
770:               			if		(Flags.connect)							// If TCP Connected
004148  A3B800     BTST.Z W0, #11
00414A  320005     BRA Z, 0x4156
771:               			{
772:               				GsmUart_SendText("ATO\r\n");				// return to Data Mode (transparent)
00414C  2A0E40     MOV #0xA0E4, W0
00414E  0718A3     RCALL Uart2_SendText
773:               				TimeOut		= 10;							// Timeout 0.1 sec
004150  2000A0     MOV #0xA, W0
004152  884010     MOV W0, TimeOut
004154  370009     BRA 0x4168
774:               			}
775:               			else if	((!Flags.home) && (Flags.csq))			// if not already at home network
004156  230001     MOV #0x3000, W1
004158  600001     AND W0, W1, W0
00415A  220001     MOV #0x2000, W1
00415C  500F81     SUB W0, W1, [W15]
00415E  3A0004     BRA NZ, 0x4168
776:               			{
777:               				GsmUart_SendText("AT+CREG?\r\n");			// check network registration
004160  2A0C10     MOV #0xA0C1, W0
004162  071899     RCALL Uart2_SendText
778:               				TimeOut		= 50;							// Timeout 0.5 sec
004164  200320     MOV #0x32, W0
004166  884010     MOV W0, TimeOut
779:               			}
780:               			GsmState	= GsmState_Idle;
004168  EF281E     CLR GsmState
00416A  37003B     BRA 0x41E2
781:               		}
782:               		break;					}
783:               	case GsmState_sms_read:		{
784:               		if (!stateTimeout)
00416C  BFC827     MOV.B stateTimeout, WREG
00416E  3A0021     BRA NZ, 0x41B2
785:               		{
786:               //			Tcp_SendText(irqBuf);
787:               			Flags.Ack = 0b10000;		// sms=1, rec=0, ackData=0, ackErr=0, ackOk=0
004170  2FFE00     MOV #0xFFE0, W0
004172  B60800     AND Flags, WREG
004174  A04000     BSET W0, #4
004176  884000     MOV W0, Flags
788:               			if((QuotationPhoneNr(QUOTE_SMS_R_NUMBER) >= QUOTE_SMS_R_TIME) &&			// sms have 3 Quotations (number, Sender NAME, time)
004178  B3C030     MOV.B #0x3, W0
00417A  07FBA3     RCALL QuotationPhoneNr
00417C  504FE6     SUB.B W0, #0x6, [W15]
00417E  36000A     BRA LEU, 0x4194
004184  E00400     CP0.B W0
004186  320006     BRA Z, 0x4194
789:               			   (QuotationText(QUOTE_SMS_R_CONTACT))						)
004180  B3C050     MOV.B #0x5, W0
004182  07FBBD     RCALL QuotationText
790:               			{
791:               				Flags.knownCaller = 1;
004188  A8A800     BSET Flags, #5
792:               				DebugPrint(callTxt);
00418A  225100     MOV #0x2510, W0
00418C  070898     RCALL Usb_SendText
793:               				DebugPrint(", (SIM number): ");										// 
00418E  2A6210     MOV #0xA621, W0
004190  070896     RCALL Usb_SendText
004192  370008     BRA 0x41A4
794:               			}
795:               			else if (callNr[0])
004194  225240     MOV #0x2524, W0
004196  E00410     CP0.B [W0]
004198  320003     BRA Z, 0x41A0
796:               				DebugPrint("unknown number: ");										// 
00419A  2A6320     MOV #0xA632, W0
00419C  070890     RCALL Usb_SendText
00419E  370002     BRA 0x41A4
797:               			else
798:               				DebugPrint("unknown sms error ");
0041A0  2A6430     MOV #0xA643, W0
0041A2  07088D     RCALL Usb_SendText
799:               			DebugPrint(callNr);
0041A4  225240     MOV #0x2524, W0
0041A6  07088B     RCALL Usb_SendText
800:               			Tcp_SendText(callNr);
0041A8  225240     MOV #0x2524, W0
0041AA  070E4F     RCALL Tcp_SendText
801:               			TimeOut		= 100;								// Timeout 1.0 sec
0041AC  200640     MOV #0x64, W0
0041AE  884010     MOV W0, TimeOut
0041B0  370018     BRA 0x41E2
802:               		}
803:               		else if (Flags.ackData)
0041B2  804001     MOV Flags, W1
0041B4  A32801     BTST.Z W1, #2
0041B6  320002     BRA Z, 0x41BC
804:               			SmsAnalize();
0041B8  07FC45     RCALL SmsAnalize
0041BA  370013     BRA 0x41E2
805:               		else if (Flags.ackOk || Flags.ackErr ||
0041BC  6080E3     AND W1, #0x3, W1
0041BE  3A0003     BRA NZ, 0x41C6
0041C0  B3CC81     MOV.B #0xC8, W1
0041C2  504F81     SUB.B W0, W1, [W15]
0041C4  36000E     BRA LEU, 0x41E2
806:               				 (stateTimeout > 200))
807:               			GsmState = GsmState_Idle;
0041C6  EF281E     CLR GsmState
0041C8  37000C     BRA 0x41E2
808:               		break;					}
809:               	case GsmState_Reset:		{
810:               		__asm__ ("RESET");
0041CA  FE0000     RESET
0041CC  37FFFF     BRA 0x41CC
811:               		while(1);		break;	}
812:               
813:               	default:					{
814:               		DebugSprintf(gsmBuff, "State nr: %d, Flags: 0x%04X - State Error !!!", GsmState, Flags.word);
0041CE  F80800     PUSH Flags
0041D0  781F82     MOV W2, [W15++]
0041D2  2A6560     MOV #0xA656, W0
0041D4  781F80     MOV W0, [W15++]
0041D6  222100     MOV #0x2210, W0
0041D8  07E8E9     RCALL __sprintf_cdnopuxX, __sprintf_s, __sprintf_0, __sprintf_cdnopsuxX
815:               		DebugPrint(gsmBuff);
0041DA  222100     MOV #0x2210, W0
0041DC  070870     RCALL Usb_SendText
816:               		GsmState = GsmState_Idle;
0041DE  EF281E     CLR GsmState
817:               		break;					}
0041E0  5787E6     SUB W15, #0x6, W15
818:               	}
819:               	if(GsmStringReceived())
0041E2  07182D     RCALL Uart2_StringReceived
0041E4  E00400     CP0.B W0
0041E6  320001     BRA Z, 0x41EA
820:               		GSM_IF = 1;
0041E8  A80086     BSET IFS1, #0
821:               }
0041EA  BE044F     MOV.D [--W15], W8
0041EC  BE034F     MOV.D [--W15], W6
0041EE  BE024F     MOV.D [--W15], W4
0041F0  BE014F     MOV.D [--W15], W2
0041F2  BE004F     MOV.D [--W15], W0
0041F4  F90036     POP RCOUNT
0041F6  064000     RETFIE
822:               
823:               inline	void	GprsPacketReceive	(U8 data)
824:               {
825:               	static TCP_PACKET*	inPacket;
826:               	static U8			currentPacket = 0, crc;
827:               	static U16			idx = 0;
828:               	static UNI16		recLen;
829:               
830:               	if (!FL_GPRS_REC)
0037B8  AB492C     BTST SysFlags, #2
0037BA  3A0010     BRA NZ, 0x37DC
831:               	{
832:               		FL_GPRS_REC	= 1;				// Set flag to receive GPRS packet
0037BC  A8492C     BSET SysFlags, #2
833:               		PackRecTimeout = TCP_PACKET_TIMEOUT;
0037BE  200281     MOV #0x28, W1
0037C0  884061     MOV W1, PackRecTimeout
834:               		currentPacket ^= 1;				// change to ather packet buffer
0037C2  208151     MOV #0x815, W1
0037C4  784091     MOV.B [W1], W1
0037C6  A20401     BTG.B W1, #0
0037C8  208152     MOV #0x815, W2
0037CA  784901     MOV.B W1, [W2]
835:               		inPacket	= &PacketIn[currentPacket];	// Recive pointer to free buffer
0037CC  DD08C8     SL W1, #8, W1
0037CE  225882     MOV #0x2588, W2
0037D0  408082     ADD W1, W2, W1
0037D2  8840B1     MOV W1, inPacket
836:               		idx			= 0;				// buffer index = 0
0037D4  EF2812     CLR idx
837:               		crc			= 0;				// clear crc
0037D6  EF6814     CLR.B crc
838:               		recLen.u16  = 0;
0037D8  EF2810     CLR recLen
839:               		PacketRec	= NULL;
0037DA  EF280E     CLR PacketRec
840:               	}
841:               	inPacket->bytes[idx++] = data;		// save current byte
0037DC  8040B2     MOV inPacket, W2
0037DE  804091     MOV idx, W1
0037E0  78F100     MOV.B W0, [W2+W1]
0037E2  E80081     INC W1, W1
0037E4  884091     MOV W1, idx
842:               	if (idx > 3)						// if Start, Lenght, CRC bytes already received
0037E6  508FE3     SUB W1, #0x3, [W15]
0037E8  360021     BRA LEU, 0x382C
843:               	{
844:               		crc ^= data;					// calculate crc
0037EA  B6C814     XOR.B crc, WREG
0037EC  B7E814     MOV.B WREG, crc
845:               		if (idx >= recLen.u16)			// if packet len bytes received	LEN_CHANGES
0037EE  804083     MOV recLen, W3
0037F0  518F81     SUB W3, W1, [W15]
0037F2  3E0023     BRA GTU, 0x383A
846:               		{
847:               			FL_GPRS_REC		= 0;		// turn off gprs packet receive
0037F4  A9492C     BCLR SysFlags, #2
848:               			PackRecTimeout	= 0;
0037F6  EF280C     CLR PackRecTimeout
849:               			if (crc == inPacket->crc)	// if crc ok
0037F8  9040A2     MOV.B [W2+2], W1
0037FA  504F81     SUB.B W0, W1, [W15]
0037FC  3A0003     BRA NZ, 0x3804
850:               			{
851:               				PacketRec	= inPacket;
0037FE  884072     MOV W2, PacketRec
852:               				GSM_IF			= 1;	// enable GSM IRQ
003800  A80086     BSET IFS1, #0
003802  37001B     BRA 0x383A
853:               			}
854:               			else						// for debug
855:               			{
856:               				sprintf(gsmBuff,"Broken Tcp: type_%02Xh, len_%u, crc_%02Xh, rc_crc_%02Xh", inPacket->type, inPacket->len, inPacket->crc, crc);
003804  FB8000     ZE W0, W0
003806  781F80     MOV W0, [W15++]
003808  FB8081     ZE W1, W1
00380A  781F81     MOV W1, [W15++]
00380C  904012     MOV.B [W2+1], W0
00380E  FB8000     ZE W0, W0
003810  781F80     MOV W0, [W15++]
003812  904032     MOV.B [W2+3], W0
003814  FB8000     ZE W0, W0
003816  781F80     MOV W0, [W15++]
003818  29F2A0     MOV #0x9F2A, W0
00381A  781F80     MOV W0, [W15++]
00381C  222100     MOV #0x2210, W0
00381E  07EDC6     RCALL __sprintf_cdnopuxX, __sprintf_s, __sprintf_0, __sprintf_cdnopsuxX
857:               				Tcp_SendText(gsmBuff);
003820  222100     MOV #0x2210, W0
003822  071313     RCALL Tcp_SendText
858:               				DebugPrint(gsmBuff);
003824  222100     MOV #0x2210, W0
003826  070D4B     RCALL Usb_SendText
003828  5787EA     SUB W15, #0xA, W15
00382A  370007     BRA 0x383A
859:               			}
860:               /*			U8* ptr = inPacket->bytes;
861:               			DebugSprintf(gsmBuff,"%02X %02X %02X(%02X) %02X %02X %02X %02X %02X",
862:               						ptr[0], ptr[1], ptr[2], crc, ptr[3], ptr[4], ptr[5], ptr[6], ptr[7]);
863:               			DebugPrint(gsmBuff);
864:               */
865:               		}
866:               	}
867:               	else if (idx == 2)											//		LEN_CHANGES
00382C  508FE2     SUB W1, #0x2, [W15]
00382E  3A0005     BRA NZ, 0x383A
868:               	{
869:               		recLen.u8l  = inPacket->len;
003830  904092     MOV.B [W2+1], W1
003832  208100     MOV #0x810, W0
003834  784801     MOV.B W1, [W0]
870:               		recLen.u16 += TCP_PACKET_HEDER;
003836  200080     MOV #0x8, W0
003838  B42810     ADD recLen
871:               	}
872:               }
00383A  060000     RETURN
873:               
874:               S8 SendTcpPacket	(char* ptr, U16 len)
875:               {
00383C  BE9F88     MOV.D W8, [W15++]
00383E  BE0400     MOV.D W0, W8
876:               	if (SendDataLen)
003842  E20808     CP0 SendDataLen
003844  3A0013     BRA NZ, 0x386C
877:               		return	-1;
003840  EBC000     SETM.B W0
878:               	DebugSprintf(tmp,"Send Tcp - Type: %02X, ID: %04X, Len: %u", ptr[3], *(U16*)&ptr[4], *(U8*)&ptr[1]);
003846  904018     MOV.B [W8+1], W0
003848  FB8000     ZE W0, W0
00384A  781F80     MOV W0, [W15++]
00384C  900028     MOV [W8+4], W0
00384E  781F80     MOV W0, [W15++]
003850  904038     MOV.B [W8+3], W0
003852  FB0000     SE W0, W0
003854  781F80     MOV W0, [W15++]
003856  29F620     MOV #0x9F62, W0
003858  781F80     MOV W0, [W15++]
00385A  225380     MOV #0x2538, W0
00385C  07EDA7     RCALL __sprintf_cdnopuxX, __sprintf_s, __sprintf_0, __sprintf_cdnopsuxX
879:               	DebugPrint(tmp);
00385E  225380     MOV #0x2538, W0
003860  070D2E     RCALL Usb_SendText
880:               	DataToSend	= ptr;
003862  884058     MOV W8, DataToSend
881:               	SendDataLen	= len + TCP_PACKET_HEDER;						//		LEN_CHANGES
003864  4484E8     ADD W9, #0x8, W9
003866  884049     MOV W9, SendDataLen
882:               	return 0;
003868  5787E8     SUB W15, #0x8, W15
00386A  EB4000     CLR.B W0
883:               }
00386C  BE044F     MOV.D [--W15], W8
00386E  060000     RETURN
884:               
885:               U8 GprsConnected	(void)
886:               {
887:               	return Flags.connect;
003870  804000     MOV Flags, W0
003872  DE004B     LSR W0, #11, W0
003874  604061     AND.B W0, #0x1, W0
888:               }
003876  060000     RETURN
889:               
890:               void Gsm_Setup		(void)
891:               {
892:               	GsmUart_SendText("AT+IPR=9600;&W\r\n");
003878  29F8B0     MOV #0x9F8B, W0
00387A  071D0D     RCALL Uart2_SendText
893:               	__asm__ ("RESET");
00387C  FE0000     RESET
00387E  37FFFF     BRA 0x387E
894:               	while(1);
895:               //	Flags.setup = 1;
896:               }
897:               
898:               void TcpPacket	(U8 type)
0038A6  4000EA     ADD W0, #0xA, W1
899:               {
003880  781F88     MOV W8, [W15++]
900:               	static U16 packetNr	= 0;
901:               	U8	i;
902:               	PacketOut.start		= STX;
003882  B3C022     MOV.B #0x2, W2
003884  223101     MOV #0x2310, W1
003886  784882     MOV.B W2, [W1]
903:               	PacketOut.crc		= 0;
003888  E88401     INC2 W1, W8
00388A  EB4C00     CLR.B [W8]
904:               	PacketOut.type		= type;
00388C  4080E3     ADD W1, #0x3, W1
00388E  784880     MOV.B W0, [W1]
905:               	PacketOut.id		= 0x333;
003890  203330     MOV #0x333, W0
003892  8918A0     MOV W0, 0x2314
906:               	PacketOut.nr		= packetNr++;
003894  804030     MOV packetNr, W0
003896  8918B0     MOV W0, 0x2316
003898  E80000     INC W0, W0
00389A  884030     MOV W0, packetNr
907:               	GetTcpTime((U32*)&PacketOut.data[0]);
00389C  408065     ADD W1, #0x5, W0
00389E  071A78     RCALL GetTcpTime
908:               //	PacketOut.time		= 0;
909:               
910:               	PacketOut.len		= 12;
0038A0  B3C0C1     MOV.B #0xC, W1
0038A2  E90008     DEC W8, W0
0038A4  784801     MOV.B W1, [W0]
911:               	for (i = 3; i < PacketOut.len; i++)
0038AE  540F81     SUB W8, W1, [W15]
0038B0  3AFFFC     BRA NZ, 0x38AA
912:               		PacketOut.crc ^= PacketOut.bytes[i];
0038A8  780008     MOV W8, W0
0038AA  784158     MOV.B [++W8], W2
0038AC  694810     XOR.B W2, [W0], [W0]
913:               	PacketOut.len		= 4;									//		LEN_CHANGES
0038B2  B3C041     MOV.B #0x4, W1
0038B4  223110     MOV #0x2311, W0
0038B6  784801     MOV.B W1, [W0]
914:               
915:               	SendTcpPacket((char*)&PacketOut, PacketOut.len);
0038B8  200041     MOV #0x4, W1
0038BA  E90000     DEC W0, W0
0038BC  07FFBF     RCALL SendTcpPacket
916:               //	DataToSend	= (char*)PacketOut.bytes;
917:               //	SendDataLen	= PacketOut.len;
918:               }
0038BE  78044F     MOV [--W15], W8
0038C0  060000     RETURN
919:               
920:               // extract Phone number from string by quotationNr
921:               // return number of Quotations
922:               inline U8 QuotationPhoneNr (U8 quotationNr)
923:               {
0038C2  784200     MOV.B W0, W4
924:               	U8		i = 0, j = 0;
0038C8  EB4280     CLR.B W5
0038CA  784005     MOV.B W5, W0
0038D0  784285     MOV.B W5, W5
0038D2  784005     MOV.B W5, W0
925:               	char*	ptr	= recGsmData;
0038C4  804022     MOV recGsmData, W2
926:               	while(*ptr)
0038C6  784092     MOV.B [W2], W1
0038CC  E00401     CP0.B W1
0038CE  320012     BRA Z, 0x38F4
0038EE  7840D2     MOV.B [++W2], W1
0038F0  E00401     CP0.B W1
0038F2  3AFFF3     BRA NZ, 0x38DA
927:               	{
928:               		if		(*ptr == '"')		i++;
0038D4  B3C223     MOV.B #0x22, W3
0038DA  50CF83     SUB.B W1, W3, [W15]
0038DC  3A0002     BRA NZ, 0x38E2
0038DE  E84000     INC.B W0, W0
0038E0  370006     BRA 0x38EE
929:               		else if	(i == quotationNr)	callNr[j++] = *ptr;
0038D6  225247     MOV #0x2524, W7
0038D8  784304     MOV.B W4, W6
0038E2  504F84     SUB.B W0, W4, [W15]
0038E4  3A0004     BRA NZ, 0x38EE
0038E6  FB8005     ZE W5, W0
0038E8  787381     MOV.B W1, [W7+W0]
0038EA  E84285     INC.B W5, W5
0038EC  784006     MOV.B W6, W0
930:               		ptr++;
931:               	}
932:               	callNr[j] = 0;
0038F4  FB8285     ZE W5, W5
0038F6  EB4100     CLR.B W2
0038F8  225241     MOV #0x2524, W1
0038FA  7AF082     MOV.B W2, [W1+W5]
933:               	return i;
934:               }
0038FC  060000     RETURN
935:               
936:               // extract "text" from string by quotationNr
937:               // return number chars within Quotations
938:               inline U8 QuotationText (U8 quotationNr)
939:               {
940:               	U8		i = 0, j = 0;
003906  EB4280     CLR.B W5
003908  784185     MOV.B W5, W3
941:               	char*	ptr	= recGsmData;
0038FE  804022     MOV recGsmData, W2
942:               	while(*ptr)
003900  784092     MOV.B [W2], W1
003902  E00401     CP0.B W1
003904  32001D     BRA Z, 0x3940
003922  7840D2     MOV.B [++W2], W1
003924  E00401     CP0.B W1
003926  3AFFF3     BRA NZ, 0x390E
943:               	{
944:               		if (*ptr == '"')
00390A  B3C224     MOV.B #0x22, W4
00390E  50CF84     SUB.B W1, W4, [W15]
003910  3A0003     BRA NZ, 0x3918
945:               			if (++i > quotationNr)	break;
003912  E84183     INC.B W3, W3
003914  51CF80     SUB.B W3, W0, [W15]
003916  3E0008     BRA GTU, 0x3928
946:               		if	(i == quotationNr)		callTxt[j++] = *ptr;
00390C  225107     MOV #0x2510, W7
003918  51CF80     SUB.B W3, W0, [W15]
00391A  3A0003     BRA NZ, 0x3922
00391C  FB8305     ZE W5, W6
00391E  7B7381     MOV.B W1, [W7+W6]
003920  E84285     INC.B W5, W5
947:               		ptr++;
948:               	}
949:               
950:               	if (j > 1)
003928  52CFE1     SUB.B W5, #0x1, [W15]
00392A  36000A     BRA LEU, 0x3940
951:               	{
952:               		callTxt[j++] = '"';
00392C  FB8085     ZE W5, W1
00392E  225100     MOV #0x2510, W0
003930  B3C222     MOV.B #0x22, W2
003932  78F002     MOV.B W2, [W0+W1]
003934  E84085     INC.B W5, W1
953:               		callTxt[j] = 0;
003936  FB8081     ZE W1, W1
003938  EB4100     CLR.B W2
00393A  78F002     MOV.B W2, [W0+W1]
954:               		return (j - 2);
00393C  E94005     DEC.B W5, W0
00393E  370003     BRA 0x3946
955:               	}
956:               	callTxt[0] = 0;
003940  225100     MOV #0x2510, W0
003942  EB4800     CLR.B [W0]
957:               	return NULL;
003944  EB4000     CLR.B W0
958:               }
003946  060000     RETURN
959:               
960:               inline void	GetSmsText (char* ptr)
961:               {
003948  BE9F88     MOV.D W8, [W15++]
00394A  781F8A     MOV W10, [W15++]
00394C  780400     MOV W0, W8
003952  E80408     INC W8, W8
962:               	while (true)
963:               	{
964:               		U8 data = GsmUart_GetByte();
003954  071C76     RCALL Uart2_GetByte
965:               		if		(data == CR)		break;
003956  504FED     SUB.B W0, #0xD, [W15]
003958  320006     BRA Z, 0x3966
966:               		else if	(data == LF)		*ptr++ = '>';
00394E  B3C3EA     MOV.B #0x3E, W10
003950  370001     BRA 0x3954
00395A  504FEA     SUB.B W0, #0xA, [W15]
00395C  3A0002     BRA NZ, 0x3962
00395E  784C0A     MOV.B W10, [W8]
003960  37FFF8     BRA 0x3952
967:               		else						*ptr++ = data;
003962  784C00     MOV.B W0, [W8]
003964  37FFF6     BRA 0x3952
968:               	}
969:               	*ptr = '\0';
003966  EB4C00     CLR.B [W8]
970:               	Flags.Ack = 0b01100;		// sms=0, rec=1, ackData=1, ackErr=0, ackOk=0
003968  2FFE00     MOV #0xFFE0, W0
00396A  B60800     AND Flags, WREG
00396C  B300C0     IOR #0xC, W0
00396E  884000     MOV W0, Flags
971:               	TimeOut	= 0;
003970  EF2802     CLR TimeOut
972:               }
003972  78054F     MOV [--W15], W10
003974  BE044F     MOV.D [--W15], W8
003976  060000     RETURN
973:               
974:               inline void	SmsAnalize (void)
975:               {
003A44  BE9F88     MOV.D W8, [W15++]
976:               	char* ptr = irqBuf;
003A46  224108     MOV #0x2410, W8
977:               //	Tcp_SendText(irqBuf);
978:               
979:               	while(*ptr)
003A4A  37001A     BRA 0x3A80
003A80  784018     MOV.B [W8], W0
003A82  E00400     CP0.B W0
003A84  3AFFE3     BRA NZ, 0x3A4C
980:               	{
981:               		if (*ptr == '>')
003A48  B3C3E9     MOV.B #0x3E, W9
003A4C  504F89     SUB.B W0, W9, [W15]
003A4E  3A0017     BRA NZ, 0x3A7E
982:               		{
983:               			register U8 i = 0;
003A5C  EB4080     CLR.B W1
003A72  EB4080     CLR.B W1
003A74  370002     BRA 0x3A7A
003A78  EB4080     CLR.B W1
984:               			ptr++;
003A50  780008     MOV W8, W0
985:               			while (ptr[i] && (ptr[i] != '>'))	i++;
003A52  7840D0     MOV.B [++W0], W1
003A54  E00401     CP0.B W1
003A56  32000C     BRA Z, 0x3A70
003A58  50CF89     SUB.B W1, W9, [W15]
003A5A  32000D     BRA Z, 0x3A76
003A5E  E84081     INC.B W1, W1
003A60  FB8401     ZE W1, W8
003A62  400408     ADD W0, W8, W8
003A64  784118     MOV.B [W8], W2
003A66  E00402     CP0.B W2
003A68  320008     BRA Z, 0x3A7A
003A6A  514F89     SUB.B W2, W9, [W15]
003A6C  3AFFF8     BRA NZ, 0x3A5E
003A6E  370005     BRA 0x3A7A
003A70  780400     MOV W0, W8
003A76  780400     MOV W0, W8
986:               			SmsCommand(ptr, i);
003A7A  07FFC6     RCALL SmsCommand
003A7C  370001     BRA 0x3A80
987:                			ptr	= &ptr[i];
988:               		}
989:               		else
990:               			ptr++;
003A7E  E80408     INC W8, W8
991:               	}
992:               	Flags.ackData = 0;
003A86  A94800     BCLR Flags, #2
993:               }
003A88  BE044F     MOV.D [--W15], W8
003A8A  060000     RETURN
994:               //___________________________SMS__SMS__SMS__SMS__SMS__SMS__SMS___________________________
995:               inline void	SmsCommand (char* command, U8 len)
996:               {
003A08  BE9F88     MOV.D W8, [W15++]
003A0A  BE9F8A     MOV.D W10, [W15++]
003A0C  BE9F8C     MOV.D W12, [W15++]
003A0E  780580     MOV W0, W11
997:               	if(*command)
003A10  E0041B     CP0.B [W11]
003A12  320014     BRA Z, 0x3A3C
003A14  2A8348     MOV #0xA834, W8
003A16  EB0480     CLR W9
998:               	{
999:               		U8 i;
1000:              		for(i = 0; i < (sizeof(SmsCommands) / sizeof(SMS_COMAND)); i++)
003A38  548FE4     SUB W9, #0x4, [W15]
003A3A  3AFFEE     BRA NZ, 0x3A18
1001:              		{
1002:              			if(!(memcmp(command, SmsCommands[i].text, SmsCommands[i].size)))
003A18  FB8518     ZE [W8], W10
003A1A  97B8F8     MOV [W8-2], W1
003A1C  78010A     MOV W10, W2
003A1E  78000B     MOV W11, W0
003A20  07EBEA     RCALL _memcmp
003A22  E00000     CP0 W0
003A24  3A0007     BRA NZ, 0x3A34
1003:              				return SmsCommands[i].funct(&command[SmsCommands[i].size]);
003A26  B94E66     MUL.SU W9, #6, W12
003A28  460664     ADD W12, #0x4, W12
003A2A  45800A     ADD W11, W10, W0
003A2C  2A8321     MOV #0xA832, W1
003A2E  7E00E1     MOV [W1+W12], W1
003A30  010001     CALL W1
003A32  370004     BRA 0x3A3C
003A34  E80489     INC W9, W9
003A36  440466     ADD W8, #0x6, W8
1004:              		}
1005:              	}
1006:              }
003A3C  BE064F     MOV.D [--W15], W12
003A3E  BE054F     MOV.D [--W15], W10
003A40  BE044F     MOV.D [--W15], W8
003A42  060000     RETURN
1007:              
1008:              inline void SmsFunction_Reset	(char* ptr)
1009:              {
1010:              	if (!Flags.knownCaller)
003652  ABA800     BTST Flags, #5
003654  3A0002     BRA NZ, 0x365A
1011:              	{
1012:              		__asm__ ("RESET");
003656  FE0000     RESET
003658  37FFFF     BRA 0x3658
1013:              		while(1);
1014:              	}
1015:              }
00365A  060000     RETURN
1016:              
1017:              inline void	SmsFunction_Tcp		(char* ptr)
1018:              {
003664  781F88     MOV W8, [W15++]
1019:              	register U16 data = atoi(ptr);
003666  2000A2     MOV #0xA, W2
003668  EB0080     CLR W1
00366A  07EDEA     RCALL __Stoul
00366C  780400     MOV W0, W8
1020:              	sprintf(gsmBuff,"Sms: TCP nr %u", data);
00366E  781F80     MOV W0, [W15++]
003670  29DF80     MOV #0x9DF8, W0
003672  781F80     MOV W0, [W15++]
003674  222100     MOV #0x2210, W0
003676  07EE9A     RCALL __sprintf_cdnopuxX, __sprintf_s, __sprintf_0, __sprintf_cdnopsuxX
1021:              	Tcp_SendText(gsmBuff);
003678  222100     MOV #0x2210, W0
00367A  0713E7     RCALL Tcp_SendText
1022:              
1023:              //	memset(PacketOut.bytes,0, sizeof(PacketOut.bytes));
1024:              //	PacketOut.start		= STX;
1025:              //	PacketOut.crc		= 0;
1026:              	PacketOut.type		= data;
00367C  223130     MOV #0x2313, W0
00367E  784808     MOV.B W8, [W0]
1027:              //	PacketOut.id		= 0x333;
1028:              //	PacketOut.nr		= packetNr++;
1029:              //	GetTcpTime((U32*)&PacketOut.data[0]);
1030:              	switch (data)
003680  5787E4     SUB W15, #0x4, W15
003682  200210     MOV #0x21, W0
003684  540F80     SUB W8, W0, [W15]
003686  3A0004     BRA NZ, 0x3690
1031:              	{
1032:              	case TYPE_ONLINE:
1033:              		PacketOut.dat_16[0]	= 60;		// OnlineTimer
003688  40007B     ADD W0, #0x1B, W0
00368A  8918C0     MOV W0, 0x2318
1034:              		PacketOut.dat_16[1]	= 3;		// OnlineTimeoutSec
00368C  200030     MOV #0x3, W0
00368E  8918D0     MOV W0, 0x231A
1035:              //		*(U16*)&PacketRec->data[0] = 60;
1036:              //		*(U16*)&PacketRec->data[2] = 3;
1037:              		break;
1038:              	}
1039:              
1040:              	Tcp_PacketReceived(&PacketOut);
003690  223100     MOV #0x2310, W0
003692  071355     RCALL Tcp_PacketReceived
1041:              }
003694  78044F     MOV [--W15], W8
003696  060000     RETURN
1042:              
1043:              inline void SmsFunction_Test	(char* ptr)
1044:              {
1045:              	Tcp_SendText(ptr);
003660  0713F4     RCALL Tcp_SendText
1046:              }
003662  060000     RETURN
1047:              
1048:              inline void SmsFunction_Help	(char* ptr)
1049:              {
1050:              	Tcp_SendText(ptr);
00365C  0713F6     RCALL Tcp_SendText
1051:              }
00365E  060000     RETURN
1052:              
---  /home/pele/src/Auto_02/src/Gps.c  ------------------------------------------------------------------
1:                 #include	"Gps.h"
2:                 #include	"GpsDefines.h"
3:                 #include	"Ports.h"
4:                 #include	"Tcp.h"
5:                 #include	"Uart1.h"
6:                 #include	<string.h>
7:                 #include	<stdlib.h>
8:                 //	8PG4-B7EM-CKUS
9:                 #define		SHORT_PACKETS		0
10:                #if		(SHORT_PACKETS == 1)
11:                	#define	PACKET_MIN_REMAIN	230
12:                #else
13:                //	#define	PACKET_MIN_REMAIN	4
14:                	#define	PACKET_MIN_REMAIN	6
15:                #endif
16:                
17:                #if	(TEST == GPS_TEST)
18:                  #include	"Debug.h"
19:                  static char	tmp[80];
20:                #else
21:                  #define	DebugPrint(X)
22:                  #define	DebugSprintf(stream,fmt,a...)
23:                #endif
24:                
25:                #define	UART1_TX		U1STAbits.UTXEN
26:                #define	UART1_RX		U1MODEbits.UARTEN
27:                						// ITAIS JAPRBAUDA!!!!!!!
28:                /*
29:                Lat		56.9975209 * 10000000 = 569975209
30:                1 degree	= ~111.32km	= 11'132'000cm
31:                (1 min		= 1855.33m	= 185'533cm)
32:                0.0000001	= 1.1132cm
33:                
34:                Lon		24.2734487 * 10000000 = 242734487
35:                1 degree	= ~63.75km	= 6'375'000cm
36:                (1 min		= 1062.5m	= 106'250cm)
37:                0.0000001	= 0.6375cm
38:                
39:                1.1132 * 32 * 256	= 9119.3344		83162259.89902336
40:                0.6375 * 64 * 256	= 10444.8		109093847.04
41:                									192256106.9390234	13865.64484396681
42:                
43:                56.9298437	24.1790102
44:                56.9220801	24.1672319
45:                77636		117783
46:                2426.125	1840.359375
47:                
48:                131040		262080			12 bit
49:                1458.7373m	1670.76m		2,217.96
50:                
51:                1.1132*32	0.6375*64
52:                35.6224cm	40.8cm			54.16cm 2D
53:                
54:                
55:                lekis
56:                trums (nobrauktais attlums sekund)
57:                laiks
58:                */
59:                
60:                #define	MAX_DIFF_LAT	269	// 134	//(150 / 1.1132)	// 150cm / 1.1132 = 134.7 
61:                #define	MAX_DIFF_LON	470	// 235	//(150 / 0.6375)	// 150cm / 0.6375 = 235
62:                
63:                //#define	MIN_LAT_CM_DIFF	300
64:                //#define	MIN_LON_CM_DIFF	300
65:                #define	MAX_DIFF_SEC	60
66:                #define	MIN_DISTANCE	100		// cm/s (3.6km/h)
67:                #define	MIN_SPEED		100		// cm/s (3.6km/h)
68:                #define	MIN_ACCEL		100		// cm/s (3.6km/h)
69:                
70:                #define	DEGREE_H360		0x0226	// 360.00000 = 0x0225 5100	(0x2250000 = 359.79264; 0x2260000 = 360.44800)
71:                #define	DEGREE_H180		0x0113	// 180.00000 = 0x0112 A880	(0x1120000 = 179.56864; 0x1130000 = 180.22400)
72:                #define	MIN_DEGREES		0x000C	// 7.86432'	 = 0x000C 0000
73:                
74:                //#define	MAX_DIFF_LAT	((U32)(MIN_LAT_CM_DIFF * 10000) / 11132)
75:                //#define	MAX_DIFF_LON	((U32)(MIN_LON_CM_DIFF * 10000) / 6375)
76:                
77:                U16						MaxDiff_Lat = MAX_DIFF_LAT;
78:                U16						MaxDiff_Lon = MAX_DIFF_LON;
79:                U16						MaxDiff_Sec = MAX_DIFF_SEC;
80:                static volatile GPS_FLAGS	GpsFlags;
81:                static GPS_UBX_DATA		UbxDataReceived, UbxDataStart, UbxDataDiff;
82:                static GPS_OFFSET_2		Offset;
83:                //static GPS_UBX_DATA		UbxDataReceived, UbxDataSaved;
84:                static			U8		GpsFix = 0xFF, GpsDataType = 0;
85:                static			UNI32	latDiff, lonDiff, SpeedDiff;
86:                static			U16		GpsSec = 0, DegDiff; //, DistanceCm = 0;
87:                //static GPS_MSG*			pMsg;
88:                #ifdef	UART1_GPS
89:                  static U8				RxBuff[RX_BUFF_COUNT][RX_BUFF_SIZE];
90:                #endif
91:                static enum
92:                {
93:                	diff_null = 0,
94:                	diff_8bit,
95:                	diff_12bit,
96:                	diff_16bit,
97:                	diff_17bit,
98:                	diff_32bit
99:                } GpsDiff = diff_null;
100:               
101:               
102:               //static volatile	U8			Section;
103:               void Gps_On(void)
104:               {
105:               	GpsFlags.word	= 0;
0065F6  EF2876     CLR GpsFlags
106:               	memset((char*)&UbxDataReceived,	0, sizeof(UbxDataReceived));
0065F8  236E40     MOV #0x36E4, W0
0065FA  09000B     REPEAT #0xB
0065FC  EB1800     CLR [W0++]
107:               	memset((char*)&UbxDataStart,	0, sizeof(UbxDataStart));
0065FE  236FC2     MOV #0x36FC, W2
006600  09000B     REPEAT #0xB
006602  EB1900     CLR [W2++]
108:               	memset((char*)&UbxDataDiff,		0, sizeof(UbxDataDiff));
006604  237140     MOV #0x3714, W0
006606  09000B     REPEAT #0xB
006608  EB1800     CLR [W0++]
109:               //	memset((char*)&UbxDataSaved, 0, sizeof(UbxDataSaved));
110:               
111:               	Uart1_Init(BaudRate_9600);
00660A  EB0000     CLR W0
00660C  07065F     RCALL Uart1_Init
112:               	GPS_IF = 0;		// clear interrupt flag and
00660E  A9A089     BCLR 0x89, #5
113:               	GPS_IE = 1;		// enable GPS extend IRQ
006610  A8A099     BSET 0x99, #5
114:               	#if	(TEST == GPS_TEST)
115:               		GPS_POWER = !GPS_POWER;
006612  204000     MOV #0x400, W0
006614  801662     MOV LATB, W2
006616  600082     AND W0, W2, W1
006618  E90081     DEC W1, W1
00661A  DE08CF     LSR W1, #15, W1
00661C  DD08CA     SL W1, #10, W1
00661E  801662     MOV LATB, W2
006620  A1A002     BCLR W2, #10
006622  708102     IOR W1, W2, W2
006624  881662     MOV W2, LATB
116:               		if (GPS_POWER)
006626  B602CC     AND LATB, WREG
006628  320005     BRA Z, 0x6634
117:               		{
118:               			DebugPrint("Enable GPS Power, Uart1, GpsIrq");
00662A  2B1E80     MOV #0xB1E8, W0
00662C  07F648     RCALL Usb_SendText
119:               			GPS_LED = LED_STATUS_1;
00662E  280000     MOV #0x8000, W0
006630  8844B0     MOV W0, LedStatus2
006632  370004     BRA 0x663C
120:               		}
121:               		else
122:               		{
123:               			GPS_IE = 0;		// disable GPS extend IRQ
006634  A9A099     BCLR 0x99, #5
124:               			DebugPrint("Disable GPS Power");
006636  2B2080     MOV #0xB208, W0
006638  07F642     RCALL Usb_SendText
125:               			GPS_LED = LED_STATUS_OFF;
00663A  EF2896     CLR LedStatus2
126:               		}
127:               	#else
128:               		GPS_POW_ON();
129:               		GPS_LED	= LED_STATUS_1;
130:               	#endif
131:               }
00663C  060000     RETURN
132:               
133:               // {Ubx_Class, UbxId,... 
134:               // len = sizeof(payload) - 2 (len size)
135:               void Gps_SendUbx(const U8* data, U16 len)
136:               {
00663E  BE9F88     MOV.D W8, [W15++]
006640  BE9F8A     MOV.D W10, [W15++]
006642  BE9F8C     MOV.D W12, [W15++]
006644  780600     MOV W0, W12
006646  780481     MOV W1, W9
137:               	register U8	ck_A, ck_B = 0;
138:               	register UNI16	l;
139:               	l.u16 = len;
140:               	Uart1_SendByte(UBX_SYNC_CHAR_1);// 0xB5
006648  B3CB50     MOV.B #0xB5, W0
00664A  0706C8     RCALL Uart1_SendByte
141:               	Uart1_SendByte(UBX_SYNC_CHAR_2);// 0x62
00664C  B3C620     MOV.B #0x62, W0
00664E  0706C6     RCALL Uart1_SendByte
142:               	ck_B  = *data++;
006650  78441C     MOV.B [W12], W8
143:               	ck_A  = *data++;
006652  78455C     MOV.B [++W12], W10
006676  E8060C     INC W12, W12
144:               	Uart1_SendByte(ck_B);			// Ubx_Class
006654  784008     MOV.B W8, W0
006656  0706C2     RCALL Uart1_SendByte
145:               	Uart1_SendByte(ck_A);			// UbxId
006658  78400A     MOV.B W10, W0
00665A  0706C0     RCALL Uart1_SendByte
146:               	Uart1_SendByte(l.u8l);			// len low	byte
00665C  784009     MOV.B W9, W0
00665E  0706BE     RCALL Uart1_SendByte
147:               	Uart1_SendByte(l.u8h);			// len high	byte
006660  DE4848     LSR W9, #8, W0
006662  784680     MOV.B W0, W13
006664  0706BB     RCALL Uart1_SendByte
148:               
149:               	ck_A += ck_B;	ck_B += ck_A;	// checkSum of Ubx_Class & UbxId
006666  454508     ADD.B W10, W8, W10
006668  454408     ADD.B W10, W8, W8
150:               	ck_A += l.u8l;	ck_B += ck_A;	// checkSum += len low	byte
00666A  454509     ADD.B W10, W9, W10
00666C  44458A     ADD.B W8, W10, W11
151:               	ck_A += l.u8h;	ck_B += ck_A;	// checkSum += len high	byte
00666E  45450D     ADD.B W10, W13, W10
006670  45C58A     ADD.B W11, W10, W11
152:               
153:               	while(len)
006672  E00009     CP0 W9
006674  320008     BRA Z, 0x6686
006684  3AFFF9     BRA NZ, 0x6678
154:               	{
155:               		register U8	a = *data++;
006678  78443C     MOV.B [W12++], W8
156:               		Uart1_SendByte(a);
00667A  784008     MOV.B W8, W0
00667C  0706AF     RCALL Uart1_SendByte
157:               		ck_A += a;	ck_B += ck_A;	// checkSum += data	bytes
00667E  454508     ADD.B W10, W8, W10
006680  45C58A     ADD.B W11, W10, W11
158:               		len--;
006682  E90489     DEC W9, W9
159:               	}
160:               	Uart1_SendByte(ck_A);			// send checkSum A
006686  78400A     MOV.B W10, W0
006688  0706A9     RCALL Uart1_SendByte
161:               	Uart1_SendByte(ck_B);			// send checkSum B
00668A  78400B     MOV.B W11, W0
00668C  0706A7     RCALL Uart1_SendByte
162:               }
00668E  BE064F     MOV.D [--W15], W12
006690  BE054F     MOV.D [--W15], W10
006692  BE044F     MOV.D [--W15], W8
006694  060000     RETURN
163:               
164:               // **********************************************************************
165:               //	Rx1 INTERRUPT
166:               // ......................................................................
167:               inline void	GpsSectionWaitIrq(U8 rxData);
168:               inline void	GpsSectionUbxIdIrq(U8 rxData);
169:               inline void	GpsSectionCrcIrq(U8 rxData);
170:               inline void	GpsDataSaveIrq(U8 rxData);
171:               inline U8	GpsHederSortIrq(void);
172:               
173:               inline void	Ubx_Ack			(GPS_MSG*		rxData);
174:               inline void	Ubx_NavStatus	(NAV_STATUS*	rxData);
175:               inline void	Ubx_NavTimeout	(NAV_TIMEUTC*	rxData);
176:               inline void	Ubx_NavPosllh	(NAV_POSLLH*	rxData);
177:               inline void	Ubx_NavVelned	(NAV_VELNED*	rxData);
178:               inline void	Ubx_NavPvt		(NAV_PVT*		rxData);
179:               inline void	Ubx_Uncnown		(GPS_MSG*		rxData);
180:               inline void Ubx_DataAnalize	(void);
181:               // **********************************************************************
182:               #ifdef	UART1_GPS
183:               void __attribute__((interrupt, no_auto_psv)) _U1RXInterrupt( void )
184:               {
185:               	do										// at least one Receive Buffer Data Available
186:               	{
187:               		static U8*	pRx = RxBuff[0];
188:               		static U16	ubxLen = 0, ubxIdx = 0;
189:               		static U8	buffIdx = 0, ck_a = 0, ck_b = 0;
190:               
191:               		register U8	rxData	= U1RXREG;		// read from uart1 Rx buffer
192:               		_U1RXIF		= 0;					// Clear the Recieve Interrupt Flag
193:               
194:               		if (GpsFlags.ubx_rec)				// UBX MSG Started
195:               		{
196:               			*pRx++ = rxData;
197:               			if (++ubxIdx == 1)
198:               			{
199:               				if (rxData != UBX_SYNC_CHAR_2)
200:               					GpsFlags.ubx_rec = 0;
201:               			}
202:               			else if (ubxIdx < ubxLen)
203:               			{
204:               				ck_a += rxData;				// Checksum
205:               				ck_b += ck_a;
206:               				if (ubxIdx == 6)			// Payload lenght received
207:               					ubxLen = (*(U16*)&RxBuff[buffIdx][4] + ubxIdx);
208:               			}
209:               			else if (ubxIdx > ubxLen)		// Checksum test
210:               			{
211:               				if ((RxBuff[buffIdx][ubxLen]== ck_a) &&
212:               					(rxData					== ck_b)	)
213:               				{
214:               					GPS_IF = 1;
215:               					pMsg = (GPS_MSG*)RxBuff[buffIdx];
216:               				}
217:               			#if	(TEST == GPS_TEST)
218:               				else if (GPS_IE)
219:               				{
220:               					DebugSprintf(tmp,"Cl:%02X, Id:%02X, Len:%2u, Idx:%2d, ck_a:%02X_%02X, ck_b:%02X_%02X",
221:               								RxBuff[buffIdx][2], RxBuff[buffIdx][3], ubxLen, ubxIdx, RxBuff[buffIdx][ubxLen], ck_a, rxData, ck_b);
222:               					DebugPrint(tmp);
223:               				}
224:               			#endif
225:               				if (++buffIdx >= RX_BUFF_COUNT)
226:               					buffIdx = 0;
227:               				pRx = RxBuff[buffIdx];
228:               				GpsFlags.ubx_rec = 0;
229:               			}
230:               		}
231:               		else if (rxData == UBX_SYNC_CHAR_1)	// UBX MSG Start
232:               		{
233:               			GpsFlags.ubx_rec	= 1;
234:               			pRx = RxBuff[buffIdx];
235:               			*pRx++		= rxData;
236:               			ubxIdx		= 0;
237:               			ck_a = ck_b	= 0;
238:               			ubxLen		= 0xFFFF;
239:               		}
240:               		else if (rxData == CR)				// End of text msg (NMEA, TXT etc)
241:               		{
242:               			*pRx = '\0';
243:               			pMsg = (GPS_MSG*)RxBuff[buffIdx];
244:               			if (++buffIdx >= RX_BUFF_COUNT)
245:               				buffIdx = 0;
246:               			pRx = RxBuff[buffIdx];
247:               			GPS_IF = 1;
248:               		}
249:               		else if (rxData != LF)
250:               			*pRx++	= rxData;
251:               	} while (U1STAbits.URXDA);
252:               	U1STAbits.OERR = 0;
253:               }
254:               #endif
255:               // **********************************************************************
256:               //	GPS_EXT Interrupt (PMP Interrupt used)
257:               // **********************************************************************
258:               void GPS_INTERRUPT	( void )
259:               {
006696  F80036     PUSH RCOUNT
006698  BE9F80     MOV.D W0, [W15++]
00669A  BE9F82     MOV.D W2, [W15++]
00669C  BE9F84     MOV.D W4, [W15++]
00669E  BE9F86     MOV.D W6, [W15++]
0066A0  FA0100     LNK #0x100
260:               #ifndef	UART1_GPS
261:               	GPS_IF	= 0;			// Clear Interrupt Flag
0066A2  A9A089     BCLR 0x89, #5
262:               	char buff[256];
263:               
264:               	Uart1_GetString((P_U8)buff);
0066A4  2FF000     MOV #0xFF00, W0
0066A6  40000F     ADD W0, W15, W0
0066A8  0706AA     RCALL Uart1_GetString
265:               	DebugPrint(buff);
0066AA  2FF000     MOV #0xFF00, W0
0066AC  40000F     ADD W0, W15, W0
0066AE  07F607     RCALL Usb_SendText
266:               #else
267:               	GPS_IF	= 0;			// Clear Interrupt Flag
268:               	if (pMsg->ubxSync16 == UBX_SYNC_INT)
269:               	{
270:               		if		(pMsg->ubxClass	  == UBX_CLASS_ACK)			Ubx_Ack			(				pMsg			);
271:               		else if	(pMsg->ubxClassId == UBX_ID_NAV_STATUS)		Ubx_NavStatus	((NAV_STATUS*)	pMsg->ubxData	);
272:               		else if	(pMsg->ubxClassId == UBX_ID_NAV_TIMEUTC)	Ubx_NavTimeout	((NAV_TIMEUTC*)	pMsg->ubxData	);
273:               		else if	(pMsg->ubxClassId == UBX_ID_NAV_POSLLH)		Ubx_NavPosllh	((NAV_POSLLH*)	pMsg->ubxData	);
274:               		else if (pMsg->ubxClassId == UBX_ID_NAV_VELNED)		Ubx_NavVelned	((NAV_VELNED*)	pMsg->ubxData	);
275:               		else if	(pMsg->ubxClassId == UBX_ID_NAV_PVT)		Ubx_NavPvt		((NAV_PVT*)		pMsg->ubxData	);	// Not implemented in u-blox5
276:               		else												Ubx_Uncnown		(				pMsg			);
277:               		return;
278:               	}
279:               	else if	(pMsg->NMEA_MSG[0]			== 'G')
280:               	{
281:               		if		(pMsg->NMEA_MSG[1]		== 'S')
282:               		{
283:               			if		(pMsg->NMEA_MSG[2]	== 'A')
284:               			{
285:               //				Uart1_SendText("$PUBX,40,GSA,0,0,0,0,0,0*4E\r\n");	// switch GSA protocol OFF
286:               				SEND_UBX_STRING(CfgMsgRate_GSA);		// Set GSA		(nmea string - off)
287:               				SEND_UBX_STRING(CfgMsgRate_TIMEUTC);	// Set TIMEUTC	(ubx         - 1Hz)
288:               			}
289:               			else if (pMsg->NMEA_MSG[2]	== 'V')
290:               			{
291:               //				Uart1_SendText("$PUBX,40,GSV,0,0,0,0,0,0*59\r\n");	// switch GSV protocol OFF
292:               				SEND_UBX_STRING(CfgMsgRate_GSV);		// Set GSA		(nmea string - off)
293:               				SEND_UBX_STRING(CfgMsgRate_POSLLH);		// Set POSLLH	(ubx         - 1Hz)
294:               			}
295:               		}
296:               		else if	((pMsg->NMEA_MSG[1]		== 'G') &&
297:               				 (pMsg->NMEA_MSG[2]		== 'A')	)
298:               		{
299:               //			Uart1_SendText("$PUBX,40,GGA,0,0,0,0,0,0*5A\r\n");	// switch GGA protocol OFF
300:               			SEND_UBX_STRING(CfgMsgRate_GGA);		// Set GGA		(nmea string - off)
301:               			SEND_UBX_STRING(CfgMsgRate_STATUS);		// Set STATUS	(ubx         - 1Hz)
302:               //			SEND_UBX_STRING(CfgMsgRate_PVT);		// Set PVT		(ubx         - 1Hz) NOT supported on u-blox5 :(
303:               		}
304:               		else if	((pMsg->NMEA_MSG[1]		== 'L') &&
305:               				 (pMsg->NMEA_MSG[2]		== 'L')	)
306:               		{
307:               //			Uart1_SendText("$$PUBX,40,GLL,0,0,0,0,0,0*5C\r\n");	// switch GLL protocol OFF
308:               			SEND_UBX_STRING(CfgMsgRate_GLL);		// Set GLL		(nmea string - off)
309:               			SEND_UBX_STRING(CfgMsgRate_VELNED);		// Set VELNED	(ubx         - 1Hz)
310:               		}
311:               	}
312:               	else if	((pMsg->NMEA_MSG[0] == 'Z') &&
313:               			 (pMsg->NMEA_MSG[1] == 'D') &&
314:               			 (pMsg->NMEA_MSG[2] == 'A')	)
315:               				Uart1_SendText("$PUBX,40,ZDA,0,0,0,0,0,0*44\r\n");	// switch ZDA protocol OFF
316:               	else if	((pMsg->NMEA_MSG[0] == 'V') &&
317:               			 (pMsg->NMEA_MSG[1] == 'T') &&
318:               			 (pMsg->NMEA_MSG[2] == 'G')	)
319:               			 {
320:               //				Uart1_SendText("$PUBX,40,VTG,0,0,0,0,0,0*5E\r\n");	// switch VTG protocol OFF
321:               				SEND_UBX_STRING(CfgMsgRate_VTG);	// Set VTG		(nmea string - off)
322:               			 }
323:               	else if	((pMsg->NMEA_MSG[0] == 'R') &&
324:               			 (pMsg->NMEA_MSG[1] == 'M') &&
325:               			 (pMsg->NMEA_MSG[2] == 'C')	)
326:               			 {
327:               //				Uart1_SendText("$PUBX,40,RMC,0,0,0,0,0,0*47\r\n");	// switch RMC protocol OFF
328:               				SEND_UBX_STRING(CfgMsgRate_RMC);	// Set RMC		(nmea string - off)
329:               			 }
330:               
331:               	DebugPrint((char*)pMsg);
332:               #endif
333:               }
0066B0  FA8000     ULNK
0066B2  BE034F     MOV.D [--W15], W6
0066B4  BE024F     MOV.D [--W15], W4
0066B6  BE014F     MOV.D [--W15], W2
0066B8  BE004F     MOV.D [--W15], W0
0066BA  F90036     POP RCOUNT
0066BC  064000     RETFIE
334:               
335:               inline void	Ubx_Uncnown		(GPS_MSG*		rxData)
336:               {
337:               	DebugSprintf(tmp, "Class:%02X,ID:%02X,Len:%u ", rxData->ubxClass, rxData->ubxID, rxData->ubxLen);
0066BE  9000A0     MOV [W0+4], W1
0066C0  781F81     MOV W1, [W15++]
0066C2  9040B0     MOV.B [W0+3], W1
0066C4  FB8081     ZE W1, W1
0066C6  781F81     MOV W1, [W15++]
0066C8  904020     MOV.B [W0+2], W0
0066CA  FB8000     ZE W0, W0
0066CC  781F80     MOV W0, [W15++]
0066CE  2B21A0     MOV #0xB21A, W0
0066D0  781F80     MOV W0, [W15++]
0066D2  236940     MOV #0x3694, W0
0066D4  07D66B     RCALL __sprintf_cdnopuxX, __sprintf_s, __sprintf_0, __sprintf_cdnopsuxX
338:               	DebugPrint(tmp);
0066D6  236940     MOV #0x3694, W0
0066D8  07F5F2     RCALL Usb_SendText
0066DA  5787E8     SUB W15, #0x8, W15
339:               }
0066DC  060000     RETURN
340:               
341:               inline void	Ubx_Ack			(GPS_MSG*		rxData)
342:               {
343:               //	if (rxData->ubxID)		// 0x01- ACK; 0x00- NAK
344:               //		DebugSprintf(tmp, "ACK of %02X %02X : Ok", rxData->ubxData[0], rxData->ubxData[1]);
345:               //	else
346:               //		DebugSprintf(tmp, "ACK of %02X %02X : Error", rxData->ubxData[0], rxData->ubxData[1]);
347:               	DebugSprintf(tmp, "ACK of %02X %02X : %s", rxData->ubxData[0], rxData->ubxData[1], (rxData->ubxID)?	"Ok":"Error");
0066DE  904130     MOV.B [W0+3], W2
0066E0  2B2381     MOV #0xB238, W1
0066E2  E00402     CP0.B W2
0066E4  320001     BRA Z, 0x66E8
0066E6  2B2351     MOV #0xB235, W1
0066E8  781F81     MOV W1, [W15++]
0066EA  9040F0     MOV.B [W0+7], W1
0066EC  FB8081     ZE W1, W1
0066EE  781F81     MOV W1, [W15++]
0066F0  904060     MOV.B [W0+6], W0
0066F2  FB8000     ZE W0, W0
0066F4  781F80     MOV W0, [W15++]
0066F6  2B23E0     MOV #0xB23E, W0
0066F8  781F80     MOV W0, [W15++]
0066FA  236940     MOV #0x3694, W0
0066FC  07D657     RCALL __sprintf_cdnopuxX, __sprintf_s, __sprintf_0, __sprintf_cdnopsuxX
348:               	DebugPrint(tmp);
0066FE  236940     MOV #0x3694, W0
006700  07F5DE     RCALL Usb_SendText
006702  5787E8     SUB W15, #0x8, W15
349:               }
006704  060000     RETURN
350:               
351:               inline void	Ubx_NavStatus	(NAV_STATUS*	rxData)
352:               {
353:               	if (GpsFix != rxData->gpsFix)
006706  904040     MOV.B [W0+4], W0
006708  E348FE     CP.B 0x8FE
00670A  320023     BRA Z, 0x6752
354:               	{
355:               		GpsFix = rxData->gpsFix;
00670C  B7E8FE     MOV.B WREG, 0x8FE
356:               		GpsFlags.changes_gps = 1;
00670E  A82876     BSET GpsFlags, #1
357:               		switch (GpsFix)
006710  504FE2     SUB.B W0, #0x2, [W15]
006712  320012     BRA Z, 0x6738
006714  3E0005     BRA GTU, 0x6720
006716  E00400     CP0.B W0
006718  320009     BRA Z, 0x672C
00671A  504FE1     SUB.B W0, #0x1, [W15]
00671C  3A0018     BRA NZ, 0x674E
00671E  370009     BRA 0x6732
006720  504FE4     SUB.B W0, #0x4, [W15]
006722  32000F     BRA Z, 0x6742
006724  39000C     BRA NC, 0x673E
006726  504FE5     SUB.B W0, #0x5, [W15]
006728  3A0012     BRA NZ, 0x674E
00672A  37000E     BRA 0x6748
358:               		{
359:               			case 0:		GPS_LED	= LED_STATUS_1;		break;	// 0x00 = no fix	GPSfix Type
00672C  280000     MOV #0x8000, W0
00672E  8844B0     MOV W0, LedStatus2
006730  370010     BRA 0x6752
360:               			case 1:		GPS_LED	= LED_STATUS_2;		break;	// 0x01 = dead reckoning only
006732  290000     MOV #0x9000, W0
006734  8844B0     MOV W0, LedStatus2
006736  37000D     BRA 0x6752
361:               			case 2:		GPS_LED	= LED_STATUS_3;		break;	// 0x02 = 2D-fix
006738  292000     MOV #0x9200, W0
00673A  8844B0     MOV W0, LedStatus2
00673C  37000A     BRA 0x6752
362:               			case 3:		GPS_LED	= LED_STATUS_ON;	break;	// 0x03 = 3D-fix
00673E  EFA896     SETM LedStatus2
006740  370008     BRA 0x6752
363:               			case 4:		GPS_LED	= LED_STATUS_2;		break;	// 0x04 = GPS + dead reckoning combined
006742  290000     MOV #0x9000, W0
006744  8844B0     MOV W0, LedStatus2
006746  370005     BRA 0x6752
364:               			case 5:		GPS_LED	= LED_STATUS_2;		break;	// 0x05 = Time only fix
006748  290000     MOV #0x9000, W0
00674A  8844B0     MOV W0, LedStatus2
00674C  370002     BRA 0x6752
365:               			default:	GPS_LED	= LED_STATUS_ERROR;	break;	// 0x06..0xff = reserved
00674E  2AAAA0     MOV #0xAAAA, W0
006750  8844B0     MOV W0, LedStatus2
366:               		}
367:               	}
368:               //	DebugSprintf(tmp, "Fix:%d, FistFix: %ld sec, Reset: %ld", rxData->gpsFix, rxData->ttff, rxData->msss);
369:               //	DebugPrint(tmp);
370:               }
006752  060000     RETURN
371:               
372:               inline void	Ubx_NavTimeout	(NAV_TIMEUTC*	rxData)
373:               {
374:               	static	 S8	secLast = 0;
375:               	if (GpsFix >= GPS_TIME_FIX)
006A90  208FE1     MOV #0x8FE, W1
006A92  784091     MOV.B [W1], W1
006A94  50CFE1     SUB.B W1, #0x1, [W15]
006A96  36000D     BRA LEU, 0x6AB2
376:               	{
377:               		memcpy((char*)&SysTime, (char*)&rxData->year, (sizeof(TIME_ST) - 1));
006A98  900160     MOV [W0+12], W2
006A9A  9001F0     MOV [W0+14], W3
006A9C  884502     MOV W2, SysTime
006A9E  884513     MOV W3, 0x8A2
006AA0  900980     MOV [W0+16], W3
006AA2  884523     MOV W3, 0x8A4
006AA4  9051A0     MOV.B [W0+18], W3
006AA6  208A62     MOV #0x8A6, W2
006AA8  784903     MOV.B W3, [W2]
378:               		SysTime.gpsFix = GpsFix;
006AAA  784101     MOV.B W1, W2
006AAC  208A70     MOV #0x8A7, W0
006AAE  784802     MOV.B W2, [W0]
006AB0  370001     BRA 0x6AB4
379:               	}
380:               	else 
381:               		SysTime.gpsFix = 0;
006AB2  EF68A7     CLR.B 0x8A7
382:               	memcpy((char*)&UbxDataReceived.year, (char*)&SysTime, sizeof(TIME_ST));
006AB4  236E40     MOV #0x36E4, W0
006AB6  804502     MOV SysTime, W2
006AB8  804513     MOV 0x8A2, W3
006ABA  BE8802     MOV.D W2, [W0]
006ABC  804522     MOV 0x8A4, W2
006ABE  804533     MOV 0x8A6, W3
006AC0  980022     MOV W2, [W0+4]
006AC2  980033     MOV W3, [W0+6]
383:               
384:               	register S8 diff = (SysTime.sec - secLast);
006AC4  208922     MOV #0x892, W2
006AC6  784112     MOV.B [W2], W2
006AC8  208A63     MOV #0x8A6, W3
006ACA  114113     SUBR.B W2, [W3], W2
006ACC  784002     MOV.B W2, W0
385:               	secLast = SysTime.sec;
006ACE  208A61     MOV #0x8A6, W1
006AD0  784091     MOV.B [W1], W1
006AD2  208923     MOV #0x892, W3
006AD4  784981     MOV.B W1, [W3]
386:               	register U16 max = (FL_WEB_ONLINE)? OnlineTimeoutSec : 60;
006AD6  2003C1     MOV #0x3C, W1
006AD8  ABA92C     BTST SysFlags, #5
006ADA  320001     BRA Z, 0x6ADE
006ADC  804971     MOV 0x92E, W1
387:               	if (diff < 0)		diff += 60;
006ADE  E00400     CP0.B W0
006AE0  3D0002     BRA GE, 0x6AE6
006AE2  B3C3C3     MOV.B #0x3C, W3
006AE4  414003     ADD.B W2, W3, W0
388:               	if ((GpsSec += diff) >= max)	GpsFlags.changes_gps = 1;
006AE6  FB0000     SE W0, W0
006AE8  804432     MOV GpsSec, W2
006AEA  400002     ADD W0, W2, W0
006AEC  884430     MOV W0, GpsSec
006AEE  508F80     SUB W1, W0, [W15]
006AF0  3E0001     BRA GTU, 0x6AF4
006AF2  A82876     BSET GpsFlags, #1
389:               //	DebugSprintf(tmp, "UTC Time: %2u:%02u:%02u; date: %2u:%02u:%04u",
390:               //				rxData->hour, rxData->min, rxData->sec, rxData->day, rxData->month, rxData->year);
391:               //	DebugPrint(tmp);
392:               	Ubx_DataAnalize();
006AF4  07FEDB     RCALL Ubx_DataAnalize
393:               }
006AF6  060000     RETURN
394:               
395:               inline void	Ubx_NavPosllh	(NAV_POSLLH*	rxData)
396:               {
397:               	memset(Offset.bytes, 0, sizeof(Offset));
006754  EF2880     CLR Offset
006756  EF2882     CLR 0x882
398:               	if (GpsFix == GPS_3D_FIX)
006758  208FE1     MOV #0x8FE, W1
00675A  784091     MOV.B [W1], W1
00675C  50CFE3     SUB.B W1, #0x3, [W15]
00675E  3A005B     BRA NZ, 0x6816
399:               	{
400:               		memcpy((char*)&UbxDataReceived.lon, (char*)&rxData->lon, 8);
006760  236EC1     MOV #0x36EC, W1
006762  BE0150     MOV.D [++W0], W2
006764  BE8882     MOV.D W2, [W1]
006766  900220     MOV [W0+4], W4
006768  9002B0     MOV [W0+6], W5
00676A  9800A4     MOV W4, [W1+4]
00676C  9800B5     MOV W5, [W1+6]
401:               		latDiff.s32 = UbxDataReceived.lat.s32 - UbxDataStart.lat.s32;
00676E  237080     MOV #0x3708, W0
006770  408164     ADD W1, #0x4, W2
006772  BE0212     MOV.D [W2], W4
006774  520330     SUB W4, [W0++], W6
006776  5A83A0     SUBB W5, [W0--], W7
006778  BE0106     MOV.D W6, W2
00677A  8843C6     MOV W6, latDiff
00677C  8843D7     MOV W7, 0x87A
402:               		lonDiff.s32 = UbxDataReceived.lon.s32 - UbxDataStart.lon.s32;
00677E  500064     SUB W0, #0x4, W0
006780  BE0211     MOV.D [W1], W4
006782  520330     SUB W4, [W0++], W6
006784  5A83A0     SUBB W5, [W0--], W7
006786  BE0006     MOV.D W6, W0
006788  8843E6     MOV W6, lonDiff
00678A  8843F7     MOV W7, 0x87E
403:               		if (latDiff.u8hh & 0x80){	latDiff.s32 = 0 - latDiff.s32;	Offset.latSign = 1;	}
00678C  E2487B     CP0.B 0x87B
00678E  3D0005     BRA GE, 0x679A
006790  110160     SUBR W2, #0x0, W2
006792  1981E0     SUBBR W3, #0x0, W3
006794  8843C2     MOV W2, latDiff
006796  8843D3     MOV W3, 0x87A
006798  A8E880     BSET Offset, #7
404:               //		if (latDiff.u8hh & 0x80){	latDiff.s32 *= -1;	Offset.latSign = 1;	}
405:               //		if (latDiff.s32 < 0)	{	latDiff.u32 = abs(latDiff.s32);	Offset.latSign = 1;	}
406:               		if (lonDiff.u8hh & 0x80){	lonDiff.s32 = 0 - lonDiff.s32;	Offset.lonSign = 1;	}
00679A  E2487F     CP0.B 0x87F
00679C  3D0005     BRA GE, 0x67A8
00679E  100060     SUBR W0, #0x0, W0
0067A0  1880E0     SUBBR W1, #0x0, W1
0067A2  8843E0     MOV W0, lonDiff
0067A4  8843F1     MOV W1, 0x87E
0067A6  A8C880     BSET Offset, #6
407:               //		if (lonDiff.u8hh & 0x80){	lonDiff.s32 *= -1;	Offset.lonSign = 1;	}
408:               //		if (lonDiff.s32 < 0)	{	lonDiff.u32 = abs(lonDiff.s32);	Offset.lonSign = 1;	}
409:               
410:               //		0000 00FF	diff_8bit	TYPE_GPS_DATA
411:               //		0000 0FFF	diff_12bit	TYPE_GPS_DATA_3
412:               //		0000 FFFF	diff_16bit
413:               //		0001 FFFF	diff_17bit
414:               //		FFFF FFFF	diff_32bit
415:               		if ((latDiff.u16h) || (lonDiff.u16h))
0067A8  E2087A     CP0 0x87A
0067AA  3A0002     BRA NZ, 0x67B0
0067AC  E2087E     CP0 0x87E
0067AE  320019     BRA Z, 0x67E2
416:               		{
417:               			if ((latDiff.u32 > 0x1FFFF) || (lonDiff.u32 > 0x3FFFF))			// FFFF FFFF
0067B0  2FFFF0     MOV #0xFFFF, W0
0067B2  200011     MOV #0x1, W1
0067B4  8043C2     MOV latDiff, W2
0067B6  8043D3     MOV 0x87A, W3
0067B8  510F80     SUB W2, W0, [W15]
0067BA  598F81     SUBB W3, W1, [W15]
0067BC  3E0007     BRA GTU, 0x67CC
0067BE  2FFFF0     MOV #0xFFFF, W0
0067C0  200031     MOV #0x3, W1
0067C2  8043E2     MOV lonDiff, W2
0067C4  8043F3     MOV 0x87E, W3
0067C6  510F80     SUB W2, W0, [W15]
0067C8  598F81     SUBB W3, W1, [W15]
0067CA  360004     BRA LEU, 0x67D4
418:               			{
419:               				GpsDiff = diff_32bit;
0067CC  200050     MOV #0x5, W0
0067CE  884440     MOV W0, GpsDiff
420:               				GpsFlags.changes_32	= 1;
0067D0  A80876     BSET GpsFlags, #0
0067D2  37002D     BRA 0x682E
421:               			}
422:               			else															// 0001 FFFF
423:               			{
424:               				GpsDiff = diff_17bit;
0067D4  200040     MOV #0x4, W0
0067D6  884440     MOV W0, GpsDiff
425:               				if (GpsDataType <= TYPE_GPS_DATA_3)		// TODO
0067D8  BFC884     MOV.B GpsDataType, WREG
0067DA  504FE3     SUB.B W0, #0x3, [W15]
0067DC  3E0028     BRA GTU, 0x682E
426:               					GpsFlags.changes_32	= 1;
0067DE  A80876     BSET GpsFlags, #0
0067E0  370026     BRA 0x682E
427:               			}
428:               		}
429:               		else if ((!latDiff.u8lh) && (!lonDiff.u8lh))						// 0000 00FF
0067E2  E24879     CP0.B 0x879
0067E4  3A0005     BRA NZ, 0x67F0
0067E6  E2487D     CP0.B 0x87D
0067E8  3A0003     BRA NZ, 0x67F0
430:               			GpsDiff = diff_8bit;
0067EA  200010     MOV #0x1, W0
0067EC  884440     MOV W0, GpsDiff
0067EE  37001F     BRA 0x682E
431:               		else
432:               		{
433:               			if ((latDiff.u16l > 0xFFF) || (lonDiff.u16l > 0xFFF))			// 0000 FFFF
0067F0  20FFF0     MOV #0xFFF, W0
0067F2  E30878     CP latDiff
0067F4  3E0002     BRA GTU, 0x67FA
0067F6  E3087C     CP lonDiff
0067F8  360007     BRA LEU, 0x6808
434:               			{
435:               				GpsDiff = diff_16bit;
0067FA  200030     MOV #0x3, W0
0067FC  884440     MOV W0, GpsDiff
436:               				if (GpsDataType <= TYPE_GPS_DATA_3)
0067FE  BFC884     MOV.B GpsDataType, WREG
006800  504FE3     SUB.B W0, #0x3, [W15]
006802  3E0015     BRA GTU, 0x682E
437:               					GpsFlags.changes_32	= 1;
006804  A80876     BSET GpsFlags, #0
006806  370013     BRA 0x682E
438:               			}
439:               			else															// 0000 0FFF
440:               			{
441:               				GpsDiff = diff_12bit;
006808  200020     MOV #0x2, W0
00680A  884440     MOV W0, GpsDiff
442:               				if (GpsDataType <= TYPE_GPS_DATA_2)		// TODO
00680C  BFC884     MOV.B GpsDataType, WREG
00680E  504FE2     SUB.B W0, #0x2, [W15]
006810  3E000E     BRA GTU, 0x682E
443:               					GpsFlags.changes_32	= 1;
006812  A80876     BSET GpsFlags, #0
006814  37000C     BRA 0x682E
444:               			}
445:               		}
446:               	}
447:               	else if (latDiff.s32 != 0)
006816  8043C0     MOV latDiff, W0
006818  8043D1     MOV 0x87A, W1
00681A  500FE0     SUB W0, #0x0, [W15]
00681C  588FE0     SUBB W1, #0x0, [W15]
00681E  320007     BRA Z, 0x682E
448:               	{
449:               		memset((char*)&UbxDataReceived.lon, 0, 8);
006820  236EC5     MOV #0x36EC, W5
006822  090003     REPEAT #0x3
006824  EB1A80     CLR [W5++]
450:               		latDiff.s32 = 0;
006826  EF2878     CLR latDiff
006828  EF287A     CLR 0x87A
451:               		lonDiff.s32 = 0;
00682A  EF287C     CLR lonDiff
00682C  EF287E     CLR 0x87E
452:               	}
453:               }
00682E  060000     RETURN
454:               
455:               inline void	Ubx_NavVelned	(NAV_VELNED*	rxData)
456:               {
457:               	if (GpsFix == GPS_3D_FIX)
006830  BFC8FE     MOV.B 0x8FE, WREG
006832  504FE3     SUB.B W0, #0x3, [W15]
006834  3A0037     BRA NZ, 0x68A4
458:               	{
459:               /*		UbxDataReceived.gSpeed.u32 += &rxData->gSpeed.u32;
460:               		UbxDataReceived.heading.s32 += &rxData->heading.s32;
461:               
462:               		memcpy((char*)&UbxDataReceived.gSpeed, (char*)&rxData->gSpeed, 8);	// copy NAV_VELNED gSpeed, heading
463:               		
464:               		MIN_DISTANCE
465:               		
466:               		
467:               		if (UbxDataReceived.gSpeed.u16l >= MIN_SPEED)
468:               			GpsFlags.changes_mot	= 1;
469:               
470:               
471:               		DegDiff = DIFFERENCE(UbxDataReceived.heading.u16h, UbxDataStart.heading.u16h);
472:               		if (DegDiff > DEGREE_H180)
473:               			DegDiff = DEGREE_H360 - DegDiff;
474:               		if (DegDiff > MIN_DEGREES)
475:               			GpsFlags.changes_dir	= 1;
476:               
477:               		SpeedDiff.u32	= abs(UbxDataReceived.gSpeed - UbxDataStart.gSpeed);
478:               		if (SpeedDiff.s16h)
479:               			GpsFlags.changes_32	= 1;
480:               		else if (SpeedDiff.u16l > MIN_ACCEL)
481:               			GpsFlags.changes_acc	= 1;
482:               
483:               		DistanceCm = UbxDataReceived.gSpeed.
484:               */		
485:               		if (UbxDataReceived.gSpeed.u32 >= MIN_SPEED)
006836  81B7A0     MOV 0x36F4, W0
006838  81B7B1     MOV 0x36F6, W1
00683A  200632     MOV #0x63, W2
00683C  500F82     SUB W0, W2, [W15]
00683E  588FE0     SUBB W1, #0x0, [W15]
006840  360025     BRA LEU, 0x688C
486:               		{
487:               			GpsFlags.changes_mot	= 1;
006842  A86876     BSET GpsFlags, #3
488:               			SpeedDiff.u32	= abs(UbxDataReceived.gSpeed.u32 - UbxDataStart.gSpeed.u32);
006844  2370C2     MOV #0x370C, W2
006846  500012     SUB W0, [W2], W0
006848  A7F000     BTSC W0, #15
00684A  EA0000     NEG W0, W0
00684C  DE80CF     ASR W0, #15, W1
00684E  884460     MOV W0, SpeedDiff
006850  884471     MOV W1, 0x88E
489:               			if (SpeedDiff.s16h)
006852  E2088E     CP0 0x88E
006854  320003     BRA Z, 0x685C
490:               			{
491:               				GpsFlags.changes_gps	= 1;
006856  A82876     BSET GpsFlags, #1
492:               				GpsFlags.changes_32	= 1;
006858  A80876     BSET GpsFlags, #0
00685A  37001C     BRA 0x6894
493:               			}
494:               			else if (SpeedDiff.u16l > MIN_ACCEL)
00685C  200640     MOV #0x64, W0
00685E  E3088C     CP SpeedDiff
006860  360002     BRA LEU, 0x6866
495:               				GpsFlags.changes_gps	= 1;
006862  A82876     BSET GpsFlags, #1
006864  370017     BRA 0x6894
496:               			else
497:               			{
498:               				DegDiff = DIFFERENCE(UbxDataReceived.heading.u16h, UbxDataStart.heading.u16h);
006866  81B7D0     MOV 0x36FA, W0
006868  81B891     MOV 0x3712, W1
00686A  500F81     SUB W0, W1, [W15]
00686C  360002     BRA LEU, 0x6872
00686E  500001     SUB W0, W1, W0
006870  370001     BRA 0x6874
006872  508000     SUB W1, W0, W0
006874  884480     MOV W0, DegDiff
499:               				if (DegDiff > DEGREE_H180)
006876  201131     MOV #0x113, W1
006878  500F81     SUB W0, W1, [W15]
00687A  360003     BRA LEU, 0x6882
500:               					DegDiff = DEGREE_H360 - DegDiff;
00687C  202261     MOV #0x226, W1
00687E  508000     SUB W1, W0, W0
006880  884480     MOV W0, DegDiff
501:               				if (DegDiff > MIN_DEGREES)
006882  804480     MOV DegDiff, W0
006884  500FEC     SUB W0, #0xC, [W15]
006886  360006     BRA LEU, 0x6894
502:               					GpsFlags.changes_gps	= 1;
006888  A82876     BSET GpsFlags, #1
00688A  370004     BRA 0x6894
503:               			}
504:               		}
505:               		else
506:               		{
507:               			GpsFlags.changes_mot	= 0;
00688C  A96876     BCLR GpsFlags, #3
508:               			SpeedDiff.u32	= 0;
00688E  EF288C     CLR SpeedDiff
006890  EF288E     CLR 0x88E
509:               			DegDiff			= 0;
006892  EF2890     CLR DegDiff
510:               		}
511:               		memcpy((char*)&UbxDataStart.gSpeed, (char*)&UbxDataReceived.gSpeed, 8);
006894  2370C0     MOV #0x370C, W0
006896  236F41     MOV #0x36F4, W1
006898  781831     MOV [W1++], [W0++]
00689A  781021     MOV [W1--], [W0--]
00689C  900121     MOV [W1+4], W2
00689E  9001B1     MOV [W1+6], W3
0068A0  980022     MOV W2, [W0+4]
0068A2  980033     MOV W3, [W0+6]
512:               	}
513:               
514:               //	DebugSprintf(tmp, "Speed: %ld cm/s; speedAcc: %ld; Heading: %ld, acc: %ld ",
515:               //				rxData->gSpeed, rxData->sAcc, rxData->heading, rxData->cAcc);
516:               //	DebugPrint(tmp);
517:               }
0068A4  060000     RETURN
518:               
519:               inline void	Ubx_NavPvt		(NAV_PVT*		rxData)		// Not implemented in u-blox5
520:               {
521:               	DebugPrint("NavPvt");
0068A6  2B2540     MOV #0xB254, W0
0068A8  07F50A     RCALL Usb_SendText
522:               }
0068AA  060000     RETURN
523:               
524:               inline void Ubx_DataAnalize	(void)
525:               {
0068AC  FA0004     LNK #0x4
0068AE  781F88     MOV W8, [W15++]
0068B0  BE9F8A     MOV.D W10, [W15++]
526:               	static U8	tcpIdx = 0;
527:               //	DebugSprintf(tmp, "\t\tFix:%d, Time: %2u:%02u:%02u; date: %2u:%02u:%04u",
528:               //				 GpsFix, UbxDataReceived.hour, UbxDataReceived.min, UbxDataReceived.sec, UbxDataReceived.day, UbxDataReceived.month, UbxDataReceived.year);
529:               //	DebugPrint(tmp);
530:               
531:               	if ((GpsFlags.changes_gps) || (GpsFlags.changes_32)											||
0068B2  AB2876     BTST GpsFlags, #1
0068B4  3A000A     BRA NZ, 0x68CA
0068B6  AB0876     BTST GpsFlags, #0
0068B8  3A0008     BRA NZ, 0x68CA
0068BA  AB6876     BTST GpsFlags, #3
0068BC  3A00E5     BRA NZ, 0x6A88
532:               //	if ((GpsFlags.changes)																		||	// changed motion direction, speed, etc
533:               		((!GpsFlags.changes_mot) && ((latDiff.u16l > MaxDiff_Lat) || (lonDiff.u16l > MaxDiff_Lon)))	)	// changed location (no motion)
0068BE  8047C0     MOV 0x8F8, W0
0068C0  E30878     CP latDiff
0068C2  3E0003     BRA GTU, 0x68CA
0068C4  8047D0     MOV 0x8FA, W0
0068C6  E3087C     CP lonDiff
0068C8  3600DF     BRA LEU, 0x6A88
534:               	{
535:               		register U8 packetRemain;
536:               		if ((GpsFlags.tcp_1) && (GpsFlags.changes_32))
0068CA  AB2877     BTST 0x877, #1
0068CC  32001E     BRA Z, 0x690A
0068CE  AB0876     BTST GpsFlags, #0
0068D0  32001C     BRA Z, 0x690A
537:               		{
538:               			Tcp_SendPacket(tcpIdx);
0068D2  BFC88A     MOV.B tcpIdx, WREG
0068D4  07F9B9     RCALL Tcp_SendPacket
539:               			GpsFlags.tcp_1 = 0;
0068D6  A92877     BCLR 0x877, #1
540:               			GpsFlags.changes_32 = 0;
0068D8  A90876     BCLR GpsFlags, #0
541:               //			DebugPrint("Send Previous Packet (%c%ld, %c%ld)");
542:               			DebugSprintf(tmp, "Send Previous Packet (%c%ld, %c%ld)",
0068DA  8043E6     MOV lonDiff, W6
0068DC  8043F7     MOV 0x87E, W7
0068E0  2002B2     MOV #0x2B, W2
0068E2  A36800     BTST.Z W0, #6
0068E4  320001     BRA Z, 0x68E8
0068E6  E88102     INC2 W2, W2
0068E8  8043C4     MOV latDiff, W4
0068EA  8043D5     MOV 0x87A, W5
0068EC  2002B1     MOV #0x2B, W1
0068EE  A37800     BTST.Z W0, #7
0068F0  320001     BRA Z, 0x68F4
0068F2  E88081     INC2 W1, W1
0068F4  BE9F86     MOV.D W6, [W15++]
0068F6  781F82     MOV W2, [W15++]
0068F8  BE9F84     MOV.D W4, [W15++]
0068FA  781F81     MOV W1, [W15++]
0068FC  2B25B0     MOV #0xB25B, W0
0068FE  781F80     MOV W0, [W15++]
006900  236940     MOV #0x3694, W0
006902  07D554     RCALL __sprintf_cdnopuxX, __sprintf_s, __sprintf_0, __sprintf_cdnopsuxX
543:               						 (Offset.latSign)? '-':'+', latDiff.u32, (Offset.lonSign)? '-':'+', lonDiff.u32);
0068DE  804400     MOV Offset, W0
544:               			DebugPrint(tmp);
006904  236940     MOV #0x3694, W0
006906  07F4DB     RCALL Usb_SendText
006908  5787EE     SUB W15, #0xE, W15
545:               		}
546:               		if (!GpsFlags.tcp_1)
00690A  AB2877     BTST 0x877, #1
00690C  3A003C     BRA NZ, 0x6986
547:               		{
548:               			U32	time;
549:               /*			if		(GpsDiff <= diff_8bit)				GpsDataType = TYPE_GPS_DATA;
550:               			else if	(GpsDiff <= diff_12bit)				GpsDataType = TYPE_GPS_DATA_3;
551:               //			else if	(GpsDiff <= diff_16bit)				GpsDataType = TYPE_GPS_DATA_2;
552:               //			else if	(GpsDiff <= diff_17bit)				GpsDataType = TYPE_GPS_DATA_2;
553:               			else										GpsDataType = TYPE_GPS_DATA_3;
554:               */			GpsDataType = TYPE_GPS_DATA_3;
00690E  B3C030     MOV.B #0x3, W0
006910  B7E884     MOV.B WREG, GpsDataType
555:               //			DebugPrint("Start New Tcp Packet");
556:               			tcpIdx = Tcp_StartMemPacket(GpsDataType);
006912  07F943     RCALL Tcp_StartMemPacket
006914  B7E88A     MOV.B WREG, tcpIdx
557:               			GpsFlags.tcp_1 = 1;
006916  A82877     BSET 0x877, #1
558:               			GetTcpTime(&time);
006918  57806A     SUB W15, #0xA, W0
00691A  07023A     RCALL GetTcpTime
559:               			Tcp_WriteMemPacket(tcpIdx, (U8*)&time, 4);
00691C  B3C042     MOV.B #0x4, W2
00691E  5780EA     SUB W15, #0xA, W1
006920  BFC88A     MOV.B tcpIdx, WREG
006922  07F96A     RCALL Tcp_WriteMemPacket
560:               //			DebugSprintf(tmp, "\tTime    saved, packet remain: %3d bytes", tmpSize);	DebugPrint(tmp);
561:               			packetRemain = Tcp_WriteMemPacket(tcpIdx, (U8*)&UbxDataReceived.lon, 8);
006924  B3C082     MOV.B #0x8, W2
006926  236EC1     MOV #0x36EC, W1
006928  BFC88A     MOV.B tcpIdx, WREG
00692A  07F966     RCALL Tcp_WriteMemPacket
00692C  784400     MOV.B W0, W8
562:               //			DebugSprintf(tmp, "\tLat/Lon saved, packet remain: %3d bytes", tmpSize);	DebugPrint(tmp);
563:               			memcpy((char*)&UbxDataStart, (char*)&UbxDataReceived, sizeof(GPS_UBX_DATA));
00692E  236FC0     MOV #0x36FC, W0
006930  236E41     MOV #0x36E4, W1
006932  09000B     REPEAT #0xB
006934  781831     MOV [W1++], [W0++]
564:               			DebugSprintf(tmp, "S %2d sec, Fix:%d, Time: %2u:%02u:%02u; date: %2u:%02u:%04u",
006936  F836E4     PUSH UbxDataReceived
00693A  FB8010     ZE [W0], W0
00693C  781F80     MOV W0, [W15++]
006940  FB8010     ZE [W0], W0
006942  781F80     MOV W0, [W15++]
006946  FB8010     ZE [W0], W0
006948  781F80     MOV W0, [W15++]
00694C  FB8010     ZE [W0], W0
00694E  781F80     MOV W0, [W15++]
006952  FB8010     ZE [W0], W0
006954  781F80     MOV W0, [W15++]
006956  BFC8FE     MOV.B 0x8FE, WREG
006958  FB8000     ZE W0, W0
00695A  781F80     MOV W0, [W15++]
00695C  F80886     PUSH GpsSec
00695E  2B27F0     MOV #0xB27F, W0
006960  781F80     MOV W0, [W15++]
006962  236940     MOV #0x3694, W0
006964  07D523     RCALL __sprintf_cdnopuxX, __sprintf_s, __sprintf_0, __sprintf_cdnopsuxX
565:               						 GpsSec, GpsFix, UbxDataReceived.hour, UbxDataReceived.min, UbxDataReceived.sec, UbxDataReceived.day, UbxDataReceived.month, UbxDataReceived.year);
006938  236E60     MOV #0x36E6, W0
00693E  236E70     MOV #0x36E7, W0
006944  236EA0     MOV #0x36EA, W0
00694A  236E90     MOV #0x36E9, W0
006950  236E80     MOV #0x36E8, W0
566:               			DebugPrint(tmp);
006966  236940     MOV #0x3694, W0
006968  07F4AA     RCALL Usb_SendText
567:               			DebugSprintf(tmp, "\t Lat: %ld; Lon %ld ", UbxDataReceived.lat.s32, UbxDataReceived.lon.s32);
00696A  81B762     MOV 0x36EC, W2
00696C  81B773     MOV 0x36EE, W3
00696E  BE9F82     MOV.D W2, [W15++]
006970  81B780     MOV 0x36F0, W0
006972  81B791     MOV 0x36F2, W1
006974  BE9F80     MOV.D W0, [W15++]
006976  2B2BB0     MOV #0xB2BB, W0
006978  781F80     MOV W0, [W15++]
00697A  236940     MOV #0x3694, W0
00697C  07D517     RCALL __sprintf_cdnopuxX, __sprintf_s, __sprintf_0, __sprintf_cdnopsuxX
568:               			DebugPrint(tmp);
00697E  236940     MOV #0x3694, W0
006980  07F49E     RCALL Usb_SendText
006982  5787FC     SUB W15, #0x1C, W15
006984  37006E     BRA 0x6A62
569:               		}
570:               		else
571:               		{
572:               //			if (latDiff.u32 < (0x20000 - 0x10)) 	latDiff.u32 += 0x10;	// rounding (+= 16)
573:               //			latDiff.u32 >>= 5;												// /= 32
574:               			Offset.lat	= latDiff.u32;
006986  8043C0     MOV latDiff, W0
006988  DD0148     SL W0, #8, W2
00698A  DE0048     LSR W0, #8, W0
575:               //			latDiff.u32 <<= 5;												// *= 32
576:               
577:               //			latDiff.u32 >>= 1;												// /= 32
578:               //			latDiff.u16l &= 0xFFF0;
579:               //			Offset.lat = latDiff.u8lh;
580:               //			Offset.lon = latDiff.u8ll;
581:               //			latDiff.u32 <<= 1;												// *= 32
582:               
583:               //			if (lonDiff.u32 < (0x40000 - 0x20)) 	latDiff.u32 += 0x20;	// rounding
584:               //			lonDiff.u32 >>= 6;												// /= 64
585:               			Offset.lon	= lonDiff.u32;
00698C  8043E1     MOV lonDiff, W1
00698E  DD08C4     SL W1, #4, W1
006990  60006F     AND W0, #0xF, W0
006992  708000     IOR W1, W0, W0
006994  884410     MOV W0, 0x882
586:               //			Offset.lon |= lonDiff.u8lh;
587:               //			Offset.lon2 = lonDiff.u8ll;
588:               //			lonDiff.u32 <<= 6;												// *= 64 
589:               			Offset.sec = GpsSec;
006996  2003F0     MOV #0x3F, W0
006998  B60886     AND GpsSec, WREG
00699A  804401     MOV Offset, W1
00699C  B20C01     AND #0xC0, W1
00699E  710081     IOR W2, W1, W1
0069A0  700081     IOR W0, W1, W1
0069A2  884401     MOV W1, Offset
590:               			packetRemain = Tcp_WriteMemPacket(tcpIdx, Offset.bytes, sizeof(GPS_OFFSET_2));
0069A4  B3C042     MOV.B #0x4, W2
0069A6  208801     MOV #0x880, W1
0069A8  BFC88A     MOV.B tcpIdx, WREG
0069AA  07F926     RCALL Tcp_WriteMemPacket
0069AC  784400     MOV.B W0, W8
591:               			DebugSprintf(tmp, "  %2d sec,%c%c%02Xx%02Xx%02X, rem: %3db",
0069AE  FB8308     ZE W8, W6
0069B0  208825     MOV #0x882, W5
0069B2  784295     MOV.B [W5], W5
0069B4  FB8285     ZE W5, W5
0069B6  208814     MOV #0x881, W4
0069B8  784214     MOV.B [W4], W4
0069BA  FB8204     ZE W4, W4
0069BC  208803     MOV #0x880, W3
0069BE  784193     MOV.B [W3], W3
0069C0  FB8183     ZE W3, W3
0069C4  2005F2     MOV #0x5F, W2
0069C6  A36800     BTST.Z W0, #6
0069C8  320001     BRA Z, 0x69CC
0069CA  51016C     SUB W2, #0xC, W2
0069CC  2005F1     MOV #0x5F, W1
0069CE  A37800     BTST.Z W0, #7
0069D0  320001     BRA Z, 0x69D4
0069D2  5080EC     SUB W1, #0xC, W1
0069D4  781F86     MOV W6, [W15++]
0069D6  781F85     MOV W5, [W15++]
0069D8  781F84     MOV W4, [W15++]
0069DA  781F83     MOV W3, [W15++]
0069DC  781F82     MOV W2, [W15++]
0069DE  781F81     MOV W1, [W15++]
0069E0  804400     MOV Offset, W0
0069E2  B203F0     AND #0x3F, W0
0069E4  781F80     MOV W0, [W15++]
0069E6  2B2D00     MOV #0xB2D0, W0
0069E8  781F80     MOV W0, [W15++]
0069EA  236940     MOV #0x3694, W0
0069EC  07D4DF     RCALL __sprintf_cdnopuxX, __sprintf_s, __sprintf_0, __sprintf_cdnopsuxX
592:               						 Offset.sec, (Offset.latSign)? 'S':'_', (Offset.lonSign)? 'S':'_',
0069C2  804400     MOV Offset, W0
593:               						 Offset.bytes[0], Offset.bytes[1], Offset.bytes[2], packetRemain);		DebugPrint(tmp);
0069EE  236940     MOV #0x3694, W0
0069F0  07F466     RCALL Usb_SendText
594:               			DebugSprintf(tmp, "\t Dif:%c%u,%c%u; Speed:%ldcm/s;Deg:%ld ",
0069F2  81B7CA     MOV 0x36F8, W10
0069F4  81B7DB     MOV 0x36FA, W11
0069F6  81B7A6     MOV 0x36F4, W6
0069F8  81B7B7     MOV 0x36F6, W7
0069FA  8043E4     MOV lonDiff, W4
0069FE  5787F0     SUB W15, #0x10, W15
006A00  2002B2     MOV #0x2B, W2
006A02  A36800     BTST.Z W0, #6
006A04  320001     BRA Z, 0x6A08
006A06  E88102     INC2 W2, W2
006A08  8043C3     MOV latDiff, W3
006A0A  2002B1     MOV #0x2B, W1
006A0C  A37800     BTST.Z W0, #7
006A0E  320001     BRA Z, 0x6A12
006A10  E88081     INC2 W1, W1
006A12  BE9F8A     MOV.D W10, [W15++]
006A14  BE9F86     MOV.D W6, [W15++]
006A16  781F84     MOV W4, [W15++]
006A18  781F82     MOV W2, [W15++]
006A1A  781F83     MOV W3, [W15++]
006A1C  781F81     MOV W1, [W15++]
006A1E  2B2F80     MOV #0xB2F8, W0
006A20  781F80     MOV W0, [W15++]
006A22  236940     MOV #0x3694, W0
006A24  07D4C3     RCALL __sprintf_cdnopuxX, __sprintf_s, __sprintf_0, __sprintf_cdnopsuxX
595:               						 (Offset.latSign)? '-':'+', latDiff.u16l, (Offset.lonSign)? '-':'+', lonDiff.u16l,
0069FC  804400     MOV Offset, W0
596:               						 UbxDataReceived.gSpeed.s32, UbxDataReceived.heading.u32);				DebugPrint(tmp);
006A26  236940     MOV #0x3694, W0
006A28  07F44A     RCALL Usb_SendText
597:               
598:               			if (!Offset.latSign)	UbxDataStart.lat.s32 += latDiff.s32;
006A2A  804400     MOV Offset, W0
006A2C  5787F2     SUB W15, #0x12, W15
006A2E  A37800     BTST.Z W0, #7
006A30  3A0006     BRA NZ, 0x6A3E
006A32  237081     MOV #0x3708, W1
006A34  8043C2     MOV latDiff, W2
006A36  8043D3     MOV 0x87A, W3
006A38  410891     ADD W2, [W1], [W1]
006A3A  4990D1     ADDC W3, [++W1], [W1--]
006A3C  370005     BRA 0x6A48
599:               			else					UbxDataStart.lat.s32 -= latDiff.s32;
006A3E  237081     MOV #0x3708, W1
006A40  8043C2     MOV latDiff, W2
006A42  8043D3     MOV 0x87A, W3
006A44  111891     SUBR W2, [W1], [W1++]
006A46  199091     SUBBR W3, [W1], [W1--]
600:               			if (!Offset.lonSign)	UbxDataStart.lon.s32 += lonDiff.s32;
006A48  A36800     BTST.Z W0, #6
006A4A  3A0006     BRA NZ, 0x6A58
006A4C  237040     MOV #0x3704, W0
006A4E  8043E2     MOV lonDiff, W2
006A50  8043F3     MOV 0x87E, W3
006A52  410810     ADD W2, [W0], [W0]
006A54  499050     ADDC W3, [++W0], [W0--]
006A56  370005     BRA 0x6A62
601:               			else					UbxDataStart.lon.s32 -= lonDiff.s32;
006A58  237040     MOV #0x3704, W0
006A5A  8043E2     MOV lonDiff, W2
006A5C  8043F3     MOV 0x87E, W3
006A5E  111810     SUBR W2, [W0], [W0++]
006A60  199010     SUBBR W3, [W0], [W0--]
602:               //			memcpy((char*)&UbxDataStart, (char*)&UbxDataReceived, sizeof(GPS_UBX_DATA));
603:               		}
604:               //		if (Tcp_WriteMemPacket(tcpIdx, Offset.bytes, sizeof(Offset)) < sizeof(Offset));
605:               //		if ((GpsSec >= OnlineTimeoutSec)	||
606:               		if (((FL_WEB_ONLINE) && (GpsSec >= OnlineTimeoutSec))	||
006A62  ABA92C     BTST SysFlags, #5
006A64  320003     BRA Z, 0x6A6C
006A66  804970     MOV 0x92E, W0
006A68  E30886     CP GpsSec
006A6A  310002     BRA C, 0x6A70
006A6C  544FE5     SUB.B W8, #0x5, [W15]
006A6E  3E0005     BRA GTU, 0x6A7A
607:               			(packetRemain < PACKET_MIN_REMAIN)						)
608:               		{
609:               			Tcp_SendPacket(tcpIdx);
006A70  BFC88A     MOV.B tcpIdx, WREG
006A72  07F8EA     RCALL Tcp_SendPacket
610:               			GpsFlags.tcp_1 = 0;
006A74  A92877     BCLR 0x877, #1
611:               			DebugPrint("Tcp Packet compleete");
006A76  2B3200     MOV #0xB320, W0
006A78  07F422     RCALL Usb_SendText
612:               		}
613:               		GpsSec			= 0;
006A7A  EF2886     CLR GpsSec
614:               		latDiff.u32		= 0;
006A7C  EF2878     CLR latDiff
006A7E  EF287A     CLR 0x87A
615:               		lonDiff.u32		= 0;
006A80  EF287C     CLR lonDiff
006A82  EF287E     CLR 0x87E
616:               		GpsFlags.changes_gps	= 0;
006A84  A92876     BCLR GpsFlags, #1
617:               		GpsDiff			= diff_null;
006A86  EF2888     CLR GpsDiff
618:               	}
619:               }
006A88  BE054F     MOV.D [--W15], W10
006A8A  78044F     MOV [--W15], W8
006A8C  FA8000     ULNK
006A8E  060000     RETURN
620:               /*
621:               inline void Ubx_DataAnalize	(void)
622:               {
623:               	static U8	tcpIdx = 0;
624:               //	DebugSprintf(tmp, "\t\tFix:%d, Time: %2u:%02u:%02u; date: %2u:%02u:%04u",
625:               //				 GpsFix, UbxDataReceived.hour, UbxDataReceived.min, UbxDataReceived.sec, UbxDataReceived.day, UbxDataReceived.month, UbxDataReceived.year);
626:               //	DebugPrint(tmp);
627:               
628:               	if ((GpsFlags.changes_gps)																		||	// changed motion direction, speed, etc
629:               		((!GpsFlags.changes_mot) && ((latDiff.u16l > MaxDiff_Lat) || (lonDiff.u16l > MaxDiff_Lon)))	)	// changed location (no motion)
630:               	{
631:               		register U8 packetRemain;
632:               		if ((GpsFlags.tcp_1) && (GpsFlags.changes_32))
633:               		{
634:               			Tcp_SendPacket(tcpIdx);
635:               			GpsFlags.tcp_1 = 0;
636:               			GpsFlags.changes_32 = 0;
637:               //			DebugPrint("Send Previous Packet (%c%ld, %c%ld)");
638:               			DebugSprintf(tmp, "Send Previous Packet (%c%ld, %c%ld)",
639:               						 (Offset.latSign)? '-':'+', latDiff.u32, (Offset.lonSign)? '-':'+', lonDiff.u32);
640:               			DebugPrint(tmp);
641:               		}
642:               		if (!GpsFlags.tcp_1)
643:               		{
644:               			U32	time;
645:               //			DebugPrint("Start New Tcp Packet");
646:               			tcpIdx = Tcp_StartMemPacket(TYPE_GPS_DATA);
647:               			GpsFlags.tcp_1 = 1;
648:               			GetTcpTime(&time);
649:               			Tcp_WriteMemPacket(tcpIdx, (U8*)&time, 4);
650:               //			DebugSprintf(tmp, "\tTime    saved, packet remain: %3d bytes", tmpSize);	DebugPrint(tmp);
651:               			packetRemain = Tcp_WriteMemPacket(tcpIdx, (U8*)&UbxDataReceived.lon, 8);
652:               //			DebugSprintf(tmp, "\tLat/Lon saved, packet remain: %3d bytes", tmpSize);	DebugPrint(tmp);
653:               			memcpy((char*)&UbxDataStart, (char*)&UbxDataReceived, sizeof(GPS_UBX_DATA));
654:               			DebugSprintf(tmp, "S %2d sec, Fix:%d, Time: %2u:%02u:%02u; date: %2u:%02u:%04u",
655:               						 GpsSec, GpsFix, UbxDataReceived.hour, UbxDataReceived.min, UbxDataReceived.sec, UbxDataReceived.day, UbxDataReceived.month, UbxDataReceived.year);
656:               			DebugPrint(tmp);
657:               			DebugSprintf(tmp, "\t Lat: %ld; Lon %ld ", UbxDataReceived.lat.s32, UbxDataReceived.lon.s32);
658:               			DebugPrint(tmp);
659:               		}
660:               		else
661:               		{
662:               			if (latDiff.u16l < (0x2000 - 0x10)) 	latDiff.u16l += 0x10;	// rounding
663:               			latDiff.u16l >>= 5;												// /= 32
664:               			Offset.lat = latDiff.u8ll;
665:               			latDiff.u16l <<= 5;												// *= 32
666:               			if (lonDiff.u16l < (0x4000 - 0x20)) 	latDiff.u16l += 0x20;	// rounding
667:               			lonDiff.u16l >>= 6;												// /= 64
668:               			Offset.lon = lonDiff.u8ll;
669:               			lonDiff.u16l <<= 6;												// *= 64 
670:               			Offset.sec = GpsSec;
671:               			packetRemain = Tcp_WriteMemPacket(tcpIdx, Offset.bytes, sizeof(GPS_OFFSET));
672:               			DebugSprintf(tmp, "  %2d sec,%c%c%02Xx%02Xx%02X, rem: %3db",
673:               						 Offset.sec, (Offset.latSign)? 'S':'_', (Offset.lonSign)? 'S':'_',
674:               						 Offset.bytes[0], Offset.bytes[1], Offset.bytes[2], packetRemain);		DebugPrint(tmp);
675:               			DebugSprintf(tmp, "\t Dif:%c%u,%c%u; Speed:%ldcm/s;Deg:%ld ",
676:               						 (Offset.latSign)? '-':'+', latDiff.u16l, (Offset.lonSign)? '-':'+', lonDiff.u16l,
677:               						 UbxDataReceived.gSpeed, UbxDataReceived.heading.u32);					DebugPrint(tmp);
678:               			if (!Offset.latSign)	UbxDataStart.lat.s32 += latDiff.s32;
679:               			else					UbxDataStart.lat.s32 -= latDiff.s32;
680:               			if (!Offset.lonSign)	UbxDataStart.lon.s32 += lonDiff.s32;
681:               			else					UbxDataStart.lon.s32 -= lonDiff.s32;
682:               //			memcpy((char*)&UbxDataStart, (char*)&UbxDataReceived, sizeof(GPS_UBX_DATA));
683:               		}
684:               //		if (Tcp_WriteMemPacket(tcpIdx, Offset.bytes, sizeof(Offset)) < sizeof(Offset));
685:               //		if ((GpsSec >= OnlineTimeoutSec)	||
686:               		if (((FL_WEB_ONLINE) && (GpsSec >= OnlineTimeoutSec))	||
687:               			(packetRemain < PACKET_MIN_REMAIN)						)
688:               		{
689:               			Tcp_SendPacket(tcpIdx);
690:               			GpsFlags.tcp_1 = 0;
691:               			DebugPrint("Tcp Packet compleete");
692:               		}
693:               		GpsSec			= 0;
694:               		latDiff.u32		= 0;
695:               		lonDiff.u32		= 0;
696:               		GpsFlags.changes_gps	= 0;
697:               	}
698:               }
699:               
700:               *		TARGET_DATA		Targets[TARGET_NUMBER];
701:               
702:               static	volatile U8		TxBuff[256];
703:               static	volatile U8		TxWrite, TxSent;
704:               
705:               
706:               const SECTION NmeaSections[] = 
707:               {	// $GPRMC,161241.00,A,5659.84653,N,02416.39666,E,0.028,,200212,,,D*73 ________________
708:               	{START_EMPTY,		0},				// 									0	SECTION_WAIT
709:               	{START_HEDER,		LEN_HEDER},		// 									1	SECTION_HEDER
710:               	{START_TIME,		LEN_TIME},		// 									2	GPRMC_START
711:               	{START_STATUS,		LEN_STATUS},	// 									3
712:               	{START_LATITUDE,	LEN_LATITUDE},	// 									4
713:               	{START_N_S,			LEN_N_S},		// 									5
714:               	{START_LONGITUDE,	LEN_LONGITUDE},	// 									6
715:               	{START_E_W,			LEN_E_W},		// 									7
716:               	{START_KNOTS,		0},				// 									8
717:               	{START_DEGREES,		0},				// 									9
718:               	{START_DATE,		LEN_DATE},		// 									10
719:               	{START_EMPTY,		0},				// 									11
720:               	{START_EMPTY,		0},				// 									12
721:               	{START_EMPTY,		0},				// 									13
722:               	{START_EMPTY,		0},				// 									14
723:               	// $GPVTG, 309.62, T,,M,0.13,N,0.2,K*6E ______________________________________________
724:               	{START_DEGREES,		LEN_DEGREES},	// 									15	GPVTG_START
725:               	{START_EMPTY,		0},				// 									16
726:               	{START_EMPTY,		0},				// 									17
727:               	{START_EMPTY,		0},				// 									18
728:               	{START_KNOTS,		LEN_KNOTS},		// 									19
729:               	{START_EMPTY,		0},				// 									20
730:               	{START_KM,			LEN_KM},		// 									21
731:               	{START_EMPTY,		0},				// 									22
732:               	{START_EMPTY,		0},				// 									23
733:               	// $GPGGA,161241.00,5659.84653,N,02416.39666,E,2,05,2.00,20.9,M,22.7,M,,*6B ___________
734:               	{START_EMPTY,		0},				// Time when Fix taken (UTC)		24	GPGGA_START
735:               	{START_EMPTY,		0},				// Latitude
736:               	{START_EMPTY,		0},				// N/S
737:               	{START_EMPTY,		0},				// Longitude
738:               	{START_EMPTY,		0},				// E/W
739:               	{START_EMPTY,		0},				// Fix quality:	0 = invalid
740:               										//				1 = GPS fix (SPS)
741:               										//				2 = DGPS fix
742:               										//				3 = PPS fix
743:               										//				4 = Real Time Kinematic
744:               										//				5 = Float RTK
745:               										//				6 = estimated (dead reckoning) (2.3 feature)
746:               										//				7 = Manual input mode
747:               										//				8 = Simulation mode
748:               	{START_SAT_TRACK,	LEN_SAT_TRACK},	// Number of satellites being tracked
749:               	{START_EMPTY,		0},				// Horizontal dilution of position
750:               	{START_ALTITUDE,	LEN_ALTITUDE},	// Altitude, Meters, above mean sea level
751:               	{START_EMPTY,		0},				// (M) Meters, above mean sea level
752:               	{START_EMPTY,		0},				// Height of geoid (mean sea level) above WGS84 ellipsoid
753:               	{START_EMPTY,		0},				// (M) Meters, above WGS84 ellipsoid
754:               	{START_EMPTY,		0},				// (empty field) time in seconds since last DGPS update
755:               	{START_EMPTY,		0},				// (empty field) DGPS station ID number
756:               	{START_EMPTY,		0},				// the checksum data, always begins with *
757:               };
758:               
759:               static	volatile U8			Section, sectionLen, NmeaCharNr, controlSum, controlSumReceived;
760:               static	volatile GPS_DATA_RECEIVED	NmeaData;
761:               static	LAT_LON_VALUE		CurrentLatVal;
762:               static	LAT_LON_VALUE		CurrentLonVal;
763:               static	volatile FLAGS		GpsFlags;
764:               static	volatile FLAGS		GpsSigns;
765:               				GPS_DATA	GpsNmeaData;
766:               				U16			GpsDirection;
767:               
768:               #define	GGA_STRING			GpsFlags.flag_0
769:               #define	GSA_STRING			GpsFlags.flag_1
770:               #define	GSV_STRING			GpsFlags.flag_2
771:               #define	GLL_STRING			GpsFlags.flag_3
772:               #define	RMC_STRING			GpsFlags.flag_4
773:               #define	VTG_STRING			GpsFlags.flag_5
774:               
775:               #define	GPS_STATUS			GpsFlags.flag_8
776:               #define	GPS_N_S				GpsFlags.flag_9
777:               #define	GPS_E_W				GpsFlags.flag_10
778:               #define	GPS_DATA_OK			GpsFlags.flag_11
779:               
780:               #define	LAT_LON_SIGNS		GpsSigns.word
781:               #define	LAT_SIGN			GpsSigns.flag_0
782:               #define	LON_SIGN			GpsSigns.flag_1
783:               #define	LAT_HI_SIGN			GpsSigns.flag_2
784:               
785:               #define	GpsLed				LedStatus3
786:               
787:               #define	GPS_STATUS_OFF		0b0000000000000000
788:               #define	GPS_STATUS_ON		0b1111111111111111
789:               #define	GPS_STATUS_1		0b1000000000000000
790:               #define	GPS_STATUS_2		0b1001000000000000
791:               #define	GPS_STATUS_3		0b1001001000000000
792:               #define	GPS_STATUS_4		0b1001001001000000
793:               #define	GPS_STATUS_ERROR	0b1010101010101010
794:               
795:               
796:               // **********************************************************************
797:               //	Tx1 INTERRUPT
798:               // **********************************************************************
799:               void __attribute__((interrupt, no_auto_psv)) _U1TXInterrupt( void )
800:               {
801:               	_U1TXIF		= 0;				// Clear the Transmit Interrupt Flag
802:               	if (TxWrite	!= TxSent)			//	if remain bytes in buffer
803:               		U1TXREG	= TxBuff[TxSent++];	//	Transmit next byte
804:               	else
805:               		_U1TXIE		= 0;			// Disable Transmit Interrupt
806:               }
807:               
808:               // **********************************************************************
809:               //	Rx1 INTERRUPT
810:               // ......................................................................
811:               inline void	GpsSectionWaitIrq(U8 rxData);
812:               inline void	GpsSectionUbxIdIrq(U8 rxData);
813:               inline void	GpsSectionCrcIrq(U8 rxData);
814:               inline void	GpsDataSaveIrq(U8 rxData);
815:               inline U8	GpsHederSortIrq(void);
816:               // **********************************************************************
817:               void __attribute__((interrupt, no_auto_psv)) _U1RXInterrupt( void )
818:               {
819:               	while (U1STAbits.URXDA)			// at least one Receive Buffer Data Available
820:               	{
821:               		U8	rxData	= U1RXREG;		// read from uart1 Rx buffer
822:               		_U1RXIF		= 0;			// Clear the Recieve Interrupt Flag
823:               
824:               		if (SETUP_GPS)
825:               			Uart3SendByte(rxData);
826:               
827:               		if (Section == SECTION_WAIT)
828:               			GpsSectionWaitIrq(rxData);
829:               		else if (Section == SECTION_UBX_ID)
830:               			GpsSectionUbxIdIrq(rxData);
831:               		else if (rxData == '*')		// Start of string ControlSum receive
832:               		{
833:               			NmeaData.bytes[NmeaCharNr] = 0;
834:               			Section = SECTION_CRC;
835:               		}
836:               		else if (Section == SECTION_CRC)
837:               			GpsSectionCrcIrq(rxData);
838:               		else
839:               			GpsDataSaveIrq(rxData);
840:               	}
841:               }
842:               
843:               inline void GpsSectionWaitIrq(U8 rxData)
844:               {
845:               	if (rxData == '$')					// Start of NMEA string
846:               	{
847:               		Section		= SECTION_HEDER;
848:               		NmeaCharNr	= START_HEDER;
849:               		sectionLen	= LEN_HEDER;
850:               		controlSum	= controlSumReceived = 0;
851:               	}
852:               	else if (rxData == UBX_SYNC_CHAR_1)	// UBX Sync Char 1
853:               	{
854:               		Section		= SECTION_UBX_ID;
855:               		NmeaCharNr	= SECTION_UBX_ID;
856:               //			sectionLen	= LEN_HEDER;
857:               		controlSum	= controlSumReceived = 0;
858:               	}
859:               }
860:               
861:               inline void	GpsSectionUbxIdIrq(U8 rxData)
862:               {
863:               	if (NmeaCharNr == SECTION_UBX_ID)
864:               	{
865:               		if (rxData == UBX_SYNC_CHAR_2)		// UBX Sync Char 2
866:               			NmeaCharNr	= START_HEDER;
867:               		else
868:               			Section = SECTION_WAIT;
869:               	}
870:               	else if (NmeaCharNr	< (START_HEDER + UBX_HEDER_SIZE))
871:               	{
872:               		NmeaData.bytes[NmeaCharNr++] = rxData;
873:               		controlSum += rxData;
874:               		controlSumReceived += controlSum;
875:               	}
876:               	else
877:               	{	//TODO
878:               		Section = SECTION_WAIT;
879:               	}
880:               }
881:               
882:               inline void	GpsSectionCrcIrq(U8 rxData)
883:               {
884:               	if (rxData == LF)					// check ControlSum
885:               	{
886:               		Section	= sectionLen = NmeaCharNr = SECTION_WAIT;
887:               
888:               		if (controlSum != controlSumReceived)
889:               		{
890:               			NmeaData.gps.status[0] = '!';	// wrong checksum
891:               			GpsLed = GPS_STATUS_ERROR;
892:               			GpsFlags.word = 0;
893:               		}
894:               		else if (GGA_STRING && VTG_STRING && RMC_STRING)
895:               		{
896:               			GGA_STRING = 0;
897:               			VTG_STRING = 0;
898:               			RMC_STRING = 0;
899:               *			Gsm_SendData((char*)(NmeaData.gps.Time.str));
900:               			LcdString(0, 0, (char*)(NmeaData.gps.Time.str));
901:               			LcdString(1, 0, (char*)(NmeaData.gps.Date.str));
902:               			LcdString(2, 0, (char*)(NmeaData.gps.status));
903:               			LcdString(2, 12, (char*)(NmeaData.gps.e_w));
904:               			LcdString(2, 24, (char*)(NmeaData.gps.n_s));
905:               			LcdString(3, 0, (char*)(NmeaData.gps.satTrack));
906:               //			LcdString(4, 0, (char*)(NmeaData.gps.degrees));
907:               			LcdString(4, 0, (char*)(NmeaData.gps.altitude));
908:               			LcdString(5, 0, (char*)(NmeaData.gps.latitude));
909:               			LcdString(6, 0, (char*)(NmeaData.gps.longitude));
910:               			LcdString(7, 0, (char*)(NmeaData.gps.km));
911:               *
912:               //			LcdData(0, 0, (char*)(NmeaData.gps.Time.str), 6);
913:               //			LcdData(1, 0, (char*)(NmeaData.gps.Date.str), 6);
914:               //			LcdData(2, 0, (char*)(NmeaData.gps.status), 1);
915:               //			LcdData(2, 12, (char*)(NmeaData.gps.e_w), 1);
916:               //			LcdData(2, 24, (char*)(NmeaData.gps.n_s), 1);
917:               //			LcdData(3, 0, (char*)(NmeaData.gps.satTrack), 2);
918:               //			LcdData(4, 0, (char*)(NmeaData.gps.degrees), 7);
919:               //			LcdData(5, 0, (char*)(NmeaData.gps.latitude), 10);
920:               //			LcdData(6, 0, (char*)(NmeaData.gps.longitude), 11);
921:               //			LcdData(7, 0, (char*)(NmeaData.gps.km), 7);
922:               			if (NmeaData.gps.status[0] == 'A')
923:               			{
924:               				GPS_DATA_OK = 1;
925:               				GpsLed = GPS_STATUS_ON;
926:               				memcpy((char*)GpsNmeaData.bytes, (const void*)NmeaData.gps.bytes, LEN_GPS);
927:               				GPS_IF = 1;		// turn On interrupt for new GPS data processing
928:               //				GPS_NEW_DATA = 1;
929:               			}
930:               			else
931:               			{
932:               				GpsLed                  = GPS_STATUS_ERROR;
933:               				GpsNmeaData.status[0]	= NmeaData.gps.status[0];
934:               				GpsDirection			= 0xFFFF;
935:               			}
936:               		}
937:               	}
938:               	else if (rxData != CR)				// receive ControlSum
939:               	{
940:               		controlSumReceived <<= 4;
941:               		controlSumReceived += (rxData <= '9')? (rxData - '0'):(rxData - ('A' - 0x0A));
942:               	}
943:               }
944:               
945:               inline void	GpsDataSaveIrq(U8 rxData)
946:               {
947:               	controlSum ^= rxData;				// calculate ControlSum
948:               	if (rxData == ',')
949:               	{
950:               		NmeaData.bytes[NmeaCharNr] = 0;
951:               		if (Section == SECTION_HEDER)
952:               			Section = GpsHederSortIrq();
953:               		else if (Section)
954:               			Section++;
955:               
956:               
957:               		NmeaCharNr	= NmeaSections[Section].start;
958:               		sectionLen	= NmeaSections[Section].len;
959:               	}
960:               	else if (sectionLen)
961:               	{
962:               		NmeaData.bytes[NmeaCharNr++] = rxData;
963:               		sectionLen--;
964:               //				if ((Section == SECTION_STATUS) &&
965:               //					(NmeaData.gps.Date.moonOnes[0] > '0') )
966:               //					// Copy GPS Clock to System Clock
967:               //					memcpy(DateTime.str, (const void*)NmeaData.gps.Date.str, (LEN_DATE + LEN_TIME - 1));
968:               	}
969:               }
970:               
971:               inline U8 GpsHederSortIrq(void)
972:               {
973:               	if		((NmeaData.heder[2] == 'V') &&
974:               			 (NmeaData.heder[3] == 'T') &&
975:               			 (NmeaData.heder[4] == 'G') )
976:               	{
977:               		VTG_STRING = 1;
978:               		return SECTION_GPVTG;
979:               	}
980:               	else if ((NmeaData.heder[2] == 'G') &&
981:               			 (NmeaData.heder[3] == 'G') &&
982:               			 (NmeaData.heder[4] == 'A') )
983:               	{
984:               		GGA_STRING = 1;
985:               		return SECTION_GPGGA;
986:               //		Uart1SendText("$PUBX,40,GGA,0,0,0,0,0,0*5A\r\n");	// switch GGA protocol OFF
987:               	}
988:               	else if ((NmeaData.heder[2] == 'R') &&
989:               			 (NmeaData.heder[3] == 'M') &&
990:               			 (NmeaData.heder[4] == 'C') )
991:               	{
992:               		RMC_STRING = 1;
993:               		return SECTION_GPRMC;
994:               	}
995:               	else if ((NmeaData.heder[2] == 'G') &&
996:               			 (NmeaData.heder[3] == 'S') &&
997:               			 (NmeaData.heder[4] == 'A') )
998:               		Uart1SendText("$PUBX,40,GSA,0,0,0,0,0,0*4E\r\n");	// switch GSA protocol OFF
999:               	else if ((NmeaData.heder[2] == 'G') &&
1000:              			 (NmeaData.heder[3] == 'S') &&
1001:              			 (NmeaData.heder[4] == 'V') )
1002:              		Uart1SendText("$PUBX,40,GSV,0,0,0,0,0,0*59\r\n");	// switch GSV protocol OFF
1003:              	else if ((NmeaData.heder[2] == 'G') &&
1004:              			 (NmeaData.heder[3] == 'L') &&
1005:              			 (NmeaData.heder[4] == 'L') )
1006:              		Uart1SendText("$$PUBX,40,GLL,0,0,0,0,0,0*5C\r\n");	// switch GLL protocol OFF
1007:              	else if ((NmeaData.heder[2] == 'Z') &&
1008:              			 (NmeaData.heder[3] == 'D') &&
1009:              			 (NmeaData.heder[4] == 'A') )
1010:              		Uart1SendText("$PUBX,40,ZDA,0,0,0,0,0,0*44\r\n");	// switch ZDA protocol OFF
1011:              
1012:              	return SECTION_WAIT;
1013:              }
1014:              
1015:              
1016:              // Lat	 56|59.84787 degrees = 0:90
1017:              // Lon	024|16.39522 degrees = 0:180
1018:              //	   degr|minutes
1019:              LAT_LON_VALUE GpsValue (char* str)
1020:              {
1021:              	LAT_LON_VALUE val;
1022:              	U16 i = 0;
1023:              	memset(val.bytes, 0, sizeof(LAT_LON_VALUE));
1024:              	
1025:              	while (str[i] != '.')
1026:              	{
1027:              		if(!str[i++])
1028:              			return val;
1029:              	}
1030:              	i -= 2;
1031:              	while (i)
1032:              	{
1033:              		val.degrees *= 10;
1034:              		val.degrees += (*str - '0');
1035:              		str++;
1036:              		i--;
1037:              	}
1038:              	i = 5;
1039:              	while (i)
1040:              	{
1041:              		if (*str != '.')
1042:              		{
1043:              			val.minutes *= 10;
1044:              			val.minutes += (*str - '0');
1045:              			i--;
1046:              		}
1047:              		str++;
1048:              	}
1049:              	if (*str > '4')
1050:              		val.minutes++;
1051:              
1052:              	return val;
1053:              }
1054:              
1055:              inline U16 GpsDirectionValue (char* str)
1056:              {	// 0.028
1057:              	if (!*str)
1058:              		return 0xFFFF;
1059:              
1060:              	U16	ret = 0;
1061:              	while(*str)
1062:              	{
1063:              		if (*str == '.')
1064:              		{
1065:              			str++;
1066:              			ret += (*str++ - '0');
1067:              			break;
1068:              		}
1069:              		else
1070:              		{
1071:              			ret += (*str++ - '0');
1072:              			ret *= 10;
1073:              		}
1074:              	}
1075:              	if (*str > '4')
1076:              		ret++;
1077:                  
1078:              	return ret;
1079:              
1080:              }
1081:              
1082:              LAT_LON_VALUE Difference (LAT_LON_VALUE* home, LAT_LON_VALUE* target)
1083:              {
1084:              	LAT_LON_VALUE diff;
1085:              
1086:              	if(target->degrees >= home->degrees)
1087:              	{
1088:              		diff.degrees =	target->degrees	- home->degrees;
1089:              		diff.sign = 0;
1090:              	}
1091:              	else
1092:              	{
1093:              		diff.degrees =	home->degrees - target->degrees;
1094:              		diff.sign = 1;
1095:              	}
1096:              
1097:              	if(!diff.sign)
1098:              	{
1099:              		if(target->minutes >= home->minutes)
1100:              			diff.minutes =	target->minutes	- home->minutes;
1101:              		else
1102:              		{
1103:              			diff.minutes = home->minutes - target->minutes;
1104:              			if (diff.degrees)
1105:              			{
1106:              				diff.degrees--;
1107:              				diff.minutes = GPS_VAL_MINUTES_IN_DEGREE - diff.minutes;
1108:              			}
1109:              			else
1110:              				diff.sign = 1;
1111:              		}
1112:              	}
1113:              	else
1114:              	{
1115:              		if (target->minutes <= home->minutes)
1116:              			diff.minutes = home->minutes - target->minutes;
1117:              		else
1118:              		{
1119:              			diff.degrees--;
1120:              			diff.minutes = GPS_VAL_MINUTES_IN_DEGREE - (target->minutes - home->minutes);
1121:              		}
1122:              	}
1123:              
1124:              
1125:              
1126:              
1127:              *
1128:              	if(target->minutes < home->minutes)
1129:              	{
1130:              		diff.minutes = GPS_VAL_MINUTES_IN_DEGREE - (home->minutes - target->minutes);
1131:              		if (diff.degrees > 0)
1132:              			diff.degrees--;
1133:              		if(!diff.degrees)
1134:              			diff.sign = 1;
1135:              	}
1136:              	else
1137:              		diff.minutes =	target->minutes	- home->minutes;
1138:              *
1139:              *
1140:              10.3 - 12.4 = -2.1
1141:              10.3 - 11.4 = -1.1
1142:              10.3 - 10.4 = -0.1
1143:              10.3 - 9.4  =  0.9
1144:               7 - 8
1145:              17 - 8 = 9
1146:              10 - 7 = 3
1147:              8 - 7 = -1
1148:              
1149:              10 - (8 - 7) = 1
1150:              *
1151:              
1152:              	return diff;
1153:              }
1154:              
1155:              LAT_LON_VALUE Hypotenuse(LAT_LON_VALUE* lat, LAT_LON_VALUE* lon)
1156:              {
1157:              	U8				shift = 0;
1158:              	U32				a, b, c;
1159:              	LAT_LON_VALUE	rc;
1160:              
1161:              	rc.km		= 0;
1162:              	rc.meters	= 0;
1163:              	
1164:              	if (!lat->km && !lon->km && !lat->meters && !lon->meters)
1165:              		return rc;
1166:              
1167:              
1168:              	if((lat->km < 45) && (lon->km < 45))			// 12.345 km
1169:              	{
1170:              		a = (lat->km * 1000) + lat->meters; 
1171:              		b = (lon->km * 1000) + lon->meters;
1172:              	}
1173:              	else if((lat->km < 450) && (lon->km < 450))		// 123.45 km
1174:              	{
1175:              		shift = 1;
1176:              		a = (lat->km * 100) + (lat->meters / 10); 
1177:              		b = (lon->km * 100) + (lon->meters / 10);
1178:              		if ((lat->meters % 10) > 4)		a++;
1179:              		if ((lon->meters % 10) > 4)		b++;
1180:              	}
1181:              	else if((lat->km < 4500) && (lon->km < 4500))	// 1234.5 km
1182:              	{
1183:              		shift = 2;
1184:              		a = (lat->km * 10) + (lat->meters / 100); 
1185:              		b = (lon->km * 10) + (lon->meters / 100);
1186:              		if ((lat->meters % 100) > 44)		a++;
1187:              		if ((lon->meters % 100) > 44)		b++;
1188:              	}
1189:              	else //  lat->km => 4500 || lon->km >= 4500		// 12345 km
1190:              	{
1191:              		shift = 3;
1192:              		a = ((lat->meters % 1000) > 444)?	lat->km : (lat->km + 1); 
1193:              		b = ((lon->meters % 1000) > 444)?	lon->km : (lon->km + 1); 
1194:              	}
1195:              
1196:              	if (LAT_HI_SIGN)	c = a;				// multiplier = biggest of cathetus		(a > b)
1197:              	else				c = b;				//										(a < b)
1198:              		
1199:              
1200:              	a = (a * a) + (b * b);						// sum of cathetus quadratic
1201:              	while ((c * c) < a)		c++;				// square root
1202:              	c--;										// calculation
1203:              
1204:              	if		(shift == 0)
1205:              	{
1206:              		rc.km		= c / 1000;
1207:              		rc.meters	= c % 1000;
1208:              	}
1209:              	else if (shift == 1)
1210:              	{
1211:              		rc.km		=  c / 100;
1212:              		rc.meters	= (c % 100) * 10;
1213:              	}
1214:              	else if (shift == 2)
1215:              	{
1216:              		rc.km		=  c / 10;
1217:              		rc.meters	= (c % 10) * 100;
1218:              	}
1219:              	else // (shift == 3)
1220:              		rc.km		= (U16)c;	// rc.meters = 0;
1221:              
1222:              	return rc;
1223:              }
1224:              
1225:              // **********************************************************************
1226:              //	GPS_EXT Interrupt (I2C1 Slave Event used)
1227:              // **********************************************************************
1228:              void GPS_INTERRUPT	( void )
1229:              {
1230:              	GPS_IF	= 0;			// Clear Interrupt Flag
1231:              
1232:              	CurrentLatVal	= GpsValue(GpsNmeaData.latitude);
1233:              	CurrentLonVal	= GpsValue(GpsNmeaData.longitude);
1234:                  GpsDirection	= GpsDirectionValue(GpsNmeaData.degrees);
1235:              	U8 targetNr;
1236:              	for(targetNr = 0; targetNr < TARGET_NUMBER; targetNr++)
1237:              	{
1238:              		if (!Targets[targetNr].active)	continue;
1239:              
1240:              //		Targets[targetNr].active = 0;														// deactivate current target to avoid incorrect data
1241:              		LAT_LON_VALUE	latDist	= Difference(&CurrentLatVal, &Targets[targetNr].latVal);
1242:              		LAT_LON_VALUE	lonDist	= Difference(&CurrentLonVal, &Targets[targetNr].lonVal);
1243:              		LAT_LON_SIGNS	= 0;
1244:              		LAT_SIGN		= latDist.sign;
1245:              		LON_SIGN		= lonDist.sign;
1246:              
1247:              		U32	a32 = latDist.minutes;
1248:              		U32	b32 = lonDist.minutes;
1249:              		if (latDist.degrees)		a32 += (U32)(latDist.degrees * GPS_VAL_MINUTES_IN_DEGREE);
1250:              		if (lonDist.degrees)		b32 += (U32)(lonDist.degrees * GPS_VAL_MINUTES_IN_DEGREE);
1251:              		U16 c16;
1252:              		if (a32 > b32)
1253:              		{
1254:              			c16 = (U16)((b32 * 450) / a32);						// max degrees variation = 45'
1255:              			LAT_HI_SIGN = 1;
1256:              		}
1257:              		else
1258:              			c16 = (U16)((a32 * 450) / b32);
1259:              
1260:              		switch (LAT_LON_SIGNS)			// Lat < Lon,	LonNeg, LatNeg
1261:              		{
1262:              		case 0:	Targets[targetNr].degrees =	( 900	-	c16);	break;		// Lat < Lon; +Lon; +Lat
1263:              		case 1:	Targets[targetNr].degrees =	( 900	+	c16);	break;		// Lat < Lon; +Lon; -Lat
1264:              		case 2:	Targets[targetNr].degrees =	(2700	+	c16);	break;		// Lat < Lon; -Lon; +Lat
1265:              		case 3:	Targets[targetNr].degrees =	(2700	-	c16);	break;		// Lat < Lon; -Lon; -Lat
1266:              		case 4:	Targets[targetNr].degrees =				c16;	break;		// Lat > Lon; +Lon; +Lat
1267:              		case 5:	Targets[targetNr].degrees =	(1800	-	c16);	break;		// Lat > Lon; +Lon; -Lat
1268:              		case 6:	Targets[targetNr].degrees =	(3600	-	c16);	break;		// Lat > Lon; -Lon; +Lat
1269:              		case 7:	Targets[targetNr].degrees =	(1800	+	c16);	break;		// Lat > Lon; -Lon; -Lat
1270:              		}
1271:              
1272:              	//	{111, 32, 186},		// Lat: 1degree = ~111.32km		1min = 1855.33m
1273:              	//	{63, 75, 106}		// Lon: 1degree = ~63.75km		1min = 1062.5m
1274:              		a32							= ((U32)(latDist.minutes) * 18553) / 10000;		// 1min = 1855.33m (we have 1min x 10000)
1275:              		c16							= latDist.degrees * 320;
1276:              		latDist.km					= ((c16 / 1000) + (latDist.degrees * 111));
1277:              		latDist.meters				=  (c16 % 1000);
1278:              		latDist.km					+= (U16)(a32 / 1000);
1279:              		latDist.meters				+= (U16)(a32 % 1000);
1280:              
1281:              		a32							= ((U32)(lonDist.minutes) * 10625) / 10000;
1282:              		c16							= lonDist.degrees * 750;
1283:              		lonDist.km					= ((c16 / 1000) + (lonDist.degrees * 63));
1284:              		lonDist.meters				=  (c16 % 1000);
1285:              		lonDist.km					+= (U16)(a32 / 1000);
1286:              		lonDist.meters				+= (U16)(a32 % 1000);
1287:              
1288:              		Targets[targetNr].distance	= Hypotenuse(&latDist, &lonDist);
1289:              
1290:              //		Targets[targetNr].active = 1;														// activate current target with correct data
1291:              	}
1292:              }
1293:              */
1294:              
1295:              /*
1296:              GPS_DATA GpsDelta(char* str, U8 lat_lon)
1297:              {
1298:              	U8 i = 0;
1299:              	U16	km, m, a;
1300:              	GPS_DATA	data;
1301:              
1302:              	data.sign = 0;
1303:              	data.degrees = 0;
1304:              	data.minutes = 0;
1305:              
1306:              	while (str[i] != '.')
1307:              		i++;
1308:              	i -= 2;
1309:              
1310:              	while (i)
1311:              	{
1312:              		data.degrees *= 10;
1313:              		data.degrees += (*str - '0');
1314:              		str++;
1315:              		i--;
1316:              	}
1317:              
1318:              	if (data.degrees < Home[lat_lon].degrees)
1319:              	{
1320:              		data.sign = 1;
1321:              		data.degrees = Home[lat_lon].degrees - data.degrees;
1322:              	}
1323:              	else
1324:              		data.degrees = data.degrees - Home[lat_lon].degrees;
1325:              	
1326:              	i = 4;
1327:              	while (i)
1328:              	{
1329:              		if (*str != '.')
1330:              		{
1331:              			data.minutes *= 10;
1332:              			data.minutes += (*str - '0');
1333:              			i--;
1334:              		}
1335:              		str++;
1336:              	}
1337:              	if (*str > '4')
1338:              		data.minutes++;
1339:              	
1340:              	if (!data.sign)
1341:              	{
1342:              		if (data.minutes >= Home[lat_lon].minutes)
1343:              			data.minutes = data.minutes - Home[lat_lon].minutes;
1344:              		else
1345:              		{
1346:              			if (data.degrees)
1347:              			{
1348:              				data.degrees--;
1349:              				data.minutes = (data.minutes + 6000) - Home[lat_lon].minutes;
1350:              			}
1351:              			else
1352:              			{
1353:              				data.sign = 1;
1354:              				data.minutes = Home[lat_lon].minutes - data.minutes;
1355:              			}
1356:              		}
1357:              	}
1358:              	else
1359:              	{
1360:              		if (data.minutes <= Home[lat_lon].minutes)
1361:              			data.minutes = Home[lat_lon].minutes - data.minutes;
1362:              		else
1363:              		{
1364:              			data.degrees--;
1365:              			data.minutes = (Home[lat_lon].minutes + 6000) - data.minutes;
1366:              		}
1367:              	}
1368:              	DegreesToKm(&data, lat_lon);
1369:              
1370:              	return data;
1371:              }
1372:              */
---  /home/pele/src/Auto_02/src/Boot.c  -----------------------------------------------------------------
1:                 #include	"Ports.h"
2:                 
3:                 //	"G:\Prog\16bit\Auto_01\Out\hex2bin.exe" "G:\Prog\16bit\Auto_01\Out\Auto_01.hex"
4:                 #ifdef		BOOT_LOADER
5:                 #define		BOOT_TEST			OFF				// ON/OFF
6:                 
7:                 #define		BOOT_VERSION		"Boot_03R"
8:                 
9:                 #define		FLASH_CLEARED		0b11111111		// 0xFF	- flash write no completed
10:                #define		FLASH_PROGRAMMED	0b11111110		// 0xFE	- flash write complete (main programm must acctept new code)
11:                #define		FLASH_OK			0b11111100		// 0xFC	- flash programm complete & accepted by main programm
12:                #define		FLASH_IN_MEM		0b11111000		// 0xF8	- New programm writed in spi memory
13:                #define		FLASH_ROW_INSTR		64
14:                #define		FLASH_ROW_WORDS		128				// (FLASH_ROW_INSTR * 2)
15:                #define		FLASH_ROW_BYTES		256				// (FLASH_ROW_INSTR * 4)
16:                
17:                #define		RESET_ADDR			0x000100
18:                #define		BOOT_LOADER_ADDR	0x000400
19:                #define		BOOT_LOADER_END		0x000C00
20:                
21:                #ifdef	ROM_DATA_ADDR
22:                	#define	NO_LOAD_END			(ROM_DATA_ADDR + ROM_DATA_SIZE)
23:                #else
24:                	#define	NO_LOAD_END			BOOT_LOADER_END
25:                #endif
26:                //#define		BOOT_FNC_SIZE		0x0014
27:                //#define		BALANCE_ADDR		0x000A8C	// w/o optimisation
28:                #define		BALANCE_ADDR		0x000A86		// optimisation enabled
29:                #define		BALANCE_SIZE		((BOOT_LOADER_END - BALANCE_ADDR) / 2)
30:                // * BootLoader data transfer Protocol *************************
31:                //	 x		len(0)	   1		2,3,4,5		 6...		n
32:                // START	LEN		COMMAND		ADDRESS		DATA	CHECK_SUM
33:                //	0xA5	16bit	8bit_CMD	32bit		8bit[]		8bit
34:                #define	BOOT_DATA_STRUCT_LEN	512						//	len			start		command			address
35:                #define	BOOT_DATA_LEN			(BOOT_DATA_STRUCT_LEN - (sizeof(U16) + sizeof(U8) + sizeof(U8) + sizeof(UNI32)))
36:                
37:                #define		BOOT_SECTOR_FNC		__attribute__ ((section(".bootLoader"),	address(BOOT_LOADER_ADDR)))
38:                #define		BOOT_SECTOR_DAT		__attribute__((space(prog), section(".bootLoader")))
39:                #define		BOOT_SECTOR_BALANCE	__attribute__((space(prog), section(".bootLoader"), fillupper(0xFF)))
40:                #define		PROGRAMM_IN_MEM()	(resCom == FLASH_IN_MEM)
41:                #define		PROGRAMM_UART()		(resCom != FLASH_IN_MEM)
42:                #define		RESET_PROGRAMMED()	((resCom != FLASH_CLEARED) && (resCom >= FLASH_OK))
43:                #define		RESET_OK()			((resAddr != 0xFFFF) && (resAddr != 0))
44:                #define		TxByte(X)			while (UART_TX_FULL); UART_TX_DATA = X
45:                #define		Boot_TxString_p(X)	{	__prog__ char* str = X;	while (*str) {TxByte(*str++);}	}
46:                #define		BootSpiByte(S,R)	BOOT_SPI_BUF = S; while (BOOT_SPI_RX_FIFO_EMPTY); R = BOOT_SPI_BUF
47:                #define		BootSpiByteGet(X)	while (BOOT_SPI_RX_FIFO_EMPTY); X = BOOT_SPI_BUF; BOOT_SPI_BUF = 0
48:                
49:                #define		Boot_CmdErase()		{	NVMCON	= NVMCON_ERASE_PAGE;											\
50:                									TBLPAG	= BootData.address.u16h;										\
51:                									__builtin_tblwtl(BootData.address.u16l, 0x0000);						\
52:                									asm("DISI #5");															\
53:                									__builtin_write_NVM();													}
54:                #define		Boot_CmdProgramm()	{	register unsigned int	i		asm ("w5") = FLASH_ROW_INSTR;			\
55:                									register unsigned int	offset	asm ("w6") = BootData.address.u16l;		\
56:                									register unsigned int*	pData	asm ("w7") = BootData.data16;			\
57:                									NVMCON	= NVMCON_PROG_ROW;												\
58:                									TBLPAG	= BootData.address.u16h;										\
59:                									if ((!BootData.address.u16h) && (BootData.address.u16l == RESET_ADDR))	\
60:                									{	resetL	= BootData.data16[0];	BootData.data16[0] = 0xFFFF;		\
61:                										resetH	= BootData.data16[1];										\
62:                										if (PROGRAMM_UART())			BootData.data16[1] = 0xFFFF;	}	\
63:                									do																		\
64:                									{	__builtin_tblwtl(offset, *pData++);									\
65:                										__builtin_tblwth(offset, *pData++);									\
66:                										offset += 2;														\
67:                									} while (--i);															\
68:                									asm("DISI #5");															\
69:                									__builtin_write_NVM();													}
70:                #define		Boot_CmdReadMem()	{	register unsigned int	i		asm ("w5") = (FLASH_ROW_BYTES);			\
71:                									register unsigned char*	pData	asm ("w7") = BootData.data;				\
72:                									do{	BootSpiByteGet(*pData++);	}	while (--i);						}
73:                
74:                #ifndef		MEM_CMD_READ
75:                	#define	MEM_CMD_READ		0x03					// Read Data bytes (Spi Memory)
76:                	#define	MEM_CMD_RDSR		0x05
77:                #endif
78:                #define		BOOT_START			0xA5
79:                #define		ACK_CS				0x33
80:                #define		NAK_CS				0x34
81:                #define		ACK_ERASE			0x35
82:                #define		ACK_PROG			0x36
83:                #define		ACK_TIMEOUT			0x60
84:                #define		BOOT_CMD_RESET		0xB0
85:                #define		BOOT_CMD_ERASE		0xB1
86:                #define		BOOT_CMD_PROGRAM	0xB2
87:                
88:                #define		NVMCON_PROG_ROW		0x4001
89:                #define		NVMCON_PROG_WORD	0x4003
90:                #define		NVMCON_ERASE_PAGE	0x4042
91:                #define		NVMCON_ERASE_BULK	0x404F
92:                
93:                void	 			BOOT_SECTOR_FNC		BootLoader		(void);
94:                
95:                __prog__ char		BOOT_SECTOR_DAT		Msg_Test[]		= "\r\nBoot TEST";
96:                __prog__ char		BOOT_SECTOR_DAT		Msg_Start[]		= "\r\nBoot Loader Start";
97:                __prog__ char		BOOT_SECTOR_DAT		Msg_B_Vers[]	= "\r\nVersion:      ";
98:                __prog__ char		BOOT_SECTOR_DAT		Msg_B_Date[]	= "\r\nBuild Date:   ";
99:                __prog__ char		BOOT_SECTOR_DAT		Msg_B_Time[]	= "\r\nBuild Time:   ";
100:               __prog__ char		BOOT_SECTOR_DAT		Msg_Vers[]		= BOOT_VERSION;
101:               __prog__ char		BOOT_SECTOR_DAT		Msg_Date[]		= __DATE__;
102:               __prog__ char		BOOT_SECTOR_DAT		Msg_Time[]		= __TIME__;
103:               __prog__ int		BOOT_SECTOR_BALANCE	Balance[BALANCE_SIZE];
104:               
105:               static union
106:               {
107:               	char		ch[BOOT_DATA_STRUCT_LEN];
108:               	U8			bytes[BOOT_DATA_STRUCT_LEN];
109:               	struct
110:               	{
111:               		union
112:               		{
113:               			U8			sizeBytes[4];
114:               			U32			size;
115:               			struct{
116:               				UNI16	len;			// START & LEN swaped to align
117:               				U8		start;			// len to 16bit var
118:               				U8		command;		// COMMAND
119:               			};
120:               		};
121:               		UNI32	address;
122:               		union
123:               		{
124:               			U8		data[BOOT_DATA_LEN];
125:               			U16		data16[(BOOT_DATA_LEN / 2)];
126:               		};
127:               	};
128:               } BootData						__attribute__ ((address(0x2000)));
129:               
130:               static	enum
131:               {
132:               	BootState_Wait = 0,
133:               	BootState_Len,
134:               	BootState_Capture,
135:               	BootState_CheckSum,
136:               	BootState_Command,
137:               
138:               	BootState_Idle
139:               } BootState						__attribute__ ((address(0x2200)));
140:               static	unsigned char	csm		__attribute__ ((address(0x2202)));
141:               static	unsigned int	idx		__attribute__ ((address(0x2204)));
142:               static	unsigned char*	rxData	__attribute__ ((address(0x2206)));
143:               volatile unsigned int	resCom	__attribute__ ((address(0x2208),noload));		// space should be allocated for the variable, but that initial values should not be loaded
144:               volatile unsigned int	resAddr	__attribute__ ((address(0x220A),persistent));	// variable should not be initialized or cleared at startup
145:               static	unsigned int	resetH	__attribute__ ((address(0x220C)));
146:               static	unsigned int	resetL	__attribute__ ((address(0x220E)));
147:               extern	UNI32	testVal;
148:               extern	U8		testBuf[20];
149:               
150:               // ------------------------------------------------------------------------------------------------
151:               void BootLoader	(void)
152:               {
000400  BE9F88     MOV.D W8, [W15++]
000402  BE9F8A     MOV.D W10, [W15++]
000404  BE9F8C     MOV.D W12, [W15++]
000406  781F8E     MOV W14, [W15++]
153:               	{	// Initialize Ports	---------------------------------------------------------
154:               		BOOT_LOADER_PORT_INIT();					// must be defined in Ports.h
000408  220000     MOV #0x2000, W0
00040A  881660     MOV W0, LATB
00040C  25BFF0     MOV #0x5BFF, W0
00040E  881640     MOV W0, TRISB
000410  EF22CE     CLR ODCB
000412  2003F0     MOV #0x3F, W0
000414  882710     MOV W0, ANSB
000416  200100     MOV #0x10, W0
000418  881760     MOV W0, LATF
00041A  2FFEA0     MOV #0xFFEA, W0
00041C  881740     MOV W0, TRISF
00041E  200020     MOV #0x2, W0
000420  881770     MOV W0, ODCF
000422  EF24EA     CLR ANSF
155:               	}
156:               	{	// Initialize OSC	---------------------------------------------------------
157:               		_PLLEN = 1;									// Enable PLL 96 MHz
000424  A8A744     BSET CLKDIV, #5
158:               		__builtin_write_OSCCONH(Osc_32_MHz);
000426  200010     MOV #0x1, W0
000428  2009A2     MOV #0x9A, W2
00042A  200781     MOV #0x78, W1
00042C  207433     MOV #0x743, W3
00042E  784981     MOV.B W1, [W3]
000430  784982     MOV.B W2, [W3]
000432  784980     MOV.B W0, [W3]
159:               		__builtin_write_OSCCONL(0x01);				// Initiate Clock Switch
000434  200572     MOV #0x57, W2
000436  200461     MOV #0x46, W1
000438  207423     MOV #0x742, W3
00043A  784981     MOV.B W1, [W3]
00043C  784982     MOV.B W2, [W3]
00043E  784980     MOV.B W0, [W3]
160:               		while (_OSWEN);								// Wait for Clock switch to occur
000440  AB0742     BTST OSCCON, #0
000442  3AFFFE     BRA NZ, 0x440
161:               		while(_LOCK != 1);							// Wait for PLL to lock
000444  200200     MOV #0x20, W0
000446  803A12     MOV OSCCON, W2
000448  600082     AND W0, W2, W1
00044A  32FFFD     BRA Z, 0x446
162:               	}
163:               	{	// Boot_ReadReset();
164:               		register unsigned int	offset	asm ("w6") = RESET_ADDR;
165:               		TBLPAG	= 0;
00044C  EF2054     CLR TBLPAG
166:               		resCom	= __builtin_tblrdh(offset);
00044E  201000     MOV #0x100, W0
000450  BA8090     TBLRDH [W0], W1
000452  891041     MOV W1, resCom
167:               		resAddr	= __builtin_tblrdl(offset);
000454  BA0010     TBLRDL [W0], W0
000456  891050     MOV W0, resAddr
168:               	}
169:               
170:               	if (PROGRAMM_IN_MEM())							// resCom = 1111 1000; resAddr = ?
000458  811041     MOV resCom, W1
00045A  200F80     MOV #0xF8, W0
00045C  508F80     SUB W1, W0, [W15]
00045E  320082     BRA Z, 0x564
171:               		goto Boot_ProgrammFromMem;
172:               #if	(BOOT_UART != NO_PORT)
173:               	{	// Initialize UART	---------------------------------------------------------
174:               		__builtin_write_OSCCONL(OSCCONL & 0xbf);	// Unlock Registers
000460  207422     MOV #0x742, W2
000462  784112     MOV.B [W2], W2
000464  B20BF2     AND #0xBF, W2
000466  200460     MOV #0x46, W0
000468  200571     MOV #0x57, W1
00046A  207423     MOV #0x742, W3
00046C  784980     MOV.B W0, [W3]
00046E  784981     MOV.B W1, [W3]
000470  784982     MOV.B W2, [W3]
175:               		BOOT_LOADER_PPS_UART();						// RB6 < Rx3;  RB7  < Tx3
000472  2C0FF2     MOV #0xC0FF, W2
000474  803513     MOV RPINR17, W3
000476  610203     AND W2, W3, W4
000478  206003     MOV #0x600, W3
00047A  718184     IOR W3, W4, W3
00047C  883513     MOV W3, RPINR17
00047E  803634     MOV RPOR3, W4
000480  610104     AND W2, W4, W2
000482  21C003     MOV #0x1C00, W3
000484  718182     IOR W3, W2, W3
000486  883633     MOV W3, RPOR3
176:               		__builtin_write_OSCCONL(OSCCONL | 0x40);	// Lock Registers
000488  207422     MOV #0x742, W2
00048A  784112     MOV.B [W2], W2
00048C  A06402     BSET.B W2, #6
00048E  FB8102     ZE W2, W2
000490  207423     MOV #0x742, W3
000492  784980     MOV.B W0, [W3]
000494  784981     MOV.B W1, [W3]
000496  784982     MOV.B W2, [W3]
177:               		BOOT_LOADER_INIT_UART();					// Initialize UART HW Registers
000498  EF2250     CLR U3MODE
00049A  EF2252     CLR U3STA
00049C  A86250     BSET U3MODE, #3
00049E  200220     MOV #0x22, W0
0004A0  8812C0     MOV W0, U3BRG
0004A2  A9608E     BCLR IFS5, #3
0004A4  A9408E     BCLR IFS5, #2
0004A6  A9609E     BCLR IEC5, #3
0004A8  A9409E     BCLR IEC5, #2
0004AA  A8E251     BSET 0x251, #7
0004AC  A84253     BSET 0x253, #2
178:               	}
179:               	{	// Boot_WaitStart();						Catch BOOT\n from Uart
180:               		register U16	repeat = 5;
0004AE  200055     MOV #0x5, W5
0004C8  EB8200     SETM W4
000526  780004     MOV W4, W0
000528  37FFD5     BRA 0x4D4
181:               		while (repeat)
00054A  E00005     CP0 W5
00054C  3AFFB8     BRA NZ, 0x4BE
182:               		{
183:               			register U16 timeOut = 0xFFFF, chNr = 0;
0004C6  EB0080     CLR W1
184:               			TxByte('~');
0004B0  202002     MOV #0x200, W2
0004B2  2007EB     MOV #0x7E, W11
0004BE  801291     MOV U3STA, W1
0004C0  610001     AND W2, W1, W0
0004C2  3AFFFD     BRA NZ, 0x4BE
0004C4  8812AB     MOV W11, U3TXREG
185:               			while (timeOut--)
0004D2  370029     BRA 0x526
00052C  3AFFD3     BRA NZ, 0x4D4
186:               			{
187:               				if (!UART_RX_EMPTY)					// Uart have data
0004D4  AB0252     BTST U3STA, #0
0004D6  320029     BRA Z, 0x52A
188:               				{
189:               					register char a = UART_RX_DATA;	// get byte
0004D8  8012B0     MOV U3RXREG, W0
190:               					switch (chNr)
0004DA  508FE2     SUB W1, #0x2, [W15]
0004DC  320015     BRA Z, 0x508
0004DE  3E0005     BRA GTU, 0x4EA
0004E0  E00001     CP0 W1
0004E2  320008     BRA Z, 0x4F4
0004E4  508FE1     SUB W1, #0x1, [W15]
0004E6  3A001E     BRA NZ, 0x524
0004E8  37000A     BRA 0x4FE
0004EA  508FE3     SUB W1, #0x3, [W15]
0004EC  320012     BRA Z, 0x512
0004EE  508FE4     SUB W1, #0x4, [W15]
0004F0  3A0019     BRA NZ, 0x524
0004F2  370014     BRA 0x51C
191:               					{
192:               					case 0:	if (a != 'B')	chNr = 0;	else	chNr++;		break;
0004B8  B3C429     MOV.B #0x42, W9
0004F4  684089     XOR.B W0, W9, W1
0004F6  FB8081     ZE W1, W1
0004F8  E90081     DEC W1, W1
0004FA  DE08CF     LSR W1, #15, W1
0004FC  370014     BRA 0x526
193:               					case 1:	if (a != 'O')	chNr = 0;	else	chNr++;		break;
0004D0  20002C     MOV #0x2, W12
0004FE  78008C     MOV W12, W1
000500  504F86     SUB.B W0, W6, [W15]
000502  320011     BRA Z, 0x526
000504  780083     MOV W3, W1
000506  37000F     BRA 0x526
194:               					case 2:	if (a != 'O')	chNr = 0;	else	chNr++;		break;
0004B4  B3C4F6     MOV.B #0x4F, W6
0004CA  20003E     MOV #0x3, W14
0004CC  EB0180     CLR W3
000508  78008E     MOV W14, W1
00050A  504F86     SUB.B W0, W6, [W15]
00050C  32000C     BRA Z, 0x526
00050E  780083     MOV W3, W1
000510  37000A     BRA 0x526
195:               					case 3:	if (a != 'T')	chNr = 0;	else	chNr++;		break;
0004B6  B3C54A     MOV.B #0x54, W10
0004CE  20004D     MOV #0x4, W13
000512  78008D     MOV W13, W1
000514  504F8A     SUB.B W0, W10, [W15]
000516  320007     BRA Z, 0x526
000518  780083     MOV W3, W1
00051A  370005     BRA 0x526
196:               					case 4:	if (a != '\n')	chNr = 0;	else	goto Boot_ProgrammFromUart;	break;
00051C  504FEA     SUB.B W0, #0xA, [W15]
00051E  320103     BRA Z, 0x726
000520  780083     MOV W3, W1
000522  370001     BRA 0x526
00052A  E90000     DEC W0, W0
197:               					default:				chNr = 0;						break;
000524  780083     MOV W3, W1
198:               					}
199:               					timeOut = 0xFFFF;
200:               				}
201:               			}
202:               			if (RESET_PROGRAMMED())
0004BA  200FF8     MOV #0xFF, W8
0004BC  200FB7     MOV #0xFB, W7
00052E  811040     MOV resCom, W0
000530  500F88     SUB W0, W8, [W15]
000532  320004     BRA Z, 0x53C
000534  811040     MOV resCom, W0
000536  500F87     SUB W0, W7, [W15]
000538  360001     BRA LEU, 0x53C
203:               				repeat--;
00053A  E90285     DEC W5, W5
204:               			LED_BOOT = !LED_BOOT;
00053C  801760     MOV LATF, W0
00053E  600061     AND W0, #0x1, W0
000540  A20000     BTG W0, #0
000542  801761     MOV LATF, W1
000544  A10001     BCLR W1, #0
000546  700081     IOR W0, W1, W1
000548  881761     MOV W1, LATF
205:               		}
206:               	}
207:               #endif
208:               //Boot_ProgrammStart:
209:               	if (RESET_OK())									// resAddr = Ok -> goto Main Programm start
00054E  811050     MOV resAddr, W0
000550  E90000     DEC W0, W0
000552  400FE3     ADD W0, #0x3, [W15]
000554  3E0003     BRA GTU, 0x55C
210:               	{	// Go to Reset address to start main programm	-----------------------------
211:               		asm("mov	_resAddr,	w6");
000556  811056     MOV resAddr, W6
212:               		asm("goto				w6");
000558  014006     GOTO W6
00055A  370004     BRA 0x564
213:               	}
214:               	else if (resCom == FLASH_CLEARED)
00055C  811041     MOV resCom, W1
00055E  200FF0     MOV #0xFF, W0
000560  508F80     SUB W1, W0, [W15]
000562  320254     BRA Z, 0xA0C
215:               		goto	Boot_ResetDevice;
216:               
217:               Boot_ProgrammFromMem:
218:               	{	// Initialize SPI	---------------------------------------------------------
219:               		__builtin_write_OSCCONL(OSCCONL & 0xbf);	// Unlock Registers
000564  207422     MOV #0x742, W2
000566  784112     MOV.B [W2], W2
000568  B20BF2     AND #0xBF, W2
00056A  200460     MOV #0x46, W0
00056C  200571     MOV #0x57, W1
00056E  207423     MOV #0x742, W3
000570  784980     MOV.B W0, [W3]
000572  784981     MOV.B W1, [W3]
000574  784982     MOV.B W2, [W3]
220:               		BOOT_LOADER_PPS_MEM_SPI();					// RF4 < SCK2; RB14 < SDI2; RB15 < SDO2
000576  2FFC02     MOV #0xFFC0, W2
000578  803544     MOV RPINR20, W4
00057A  610184     AND W2, W4, W3
00057C  B300E3     IOR #0xE, W3
00057E  883543     MOV W3, RPINR20
000580  803655     MOV RPOR5, W5
000582  610105     AND W2, W5, W2
000584  A03002     BSET W2, #3
000586  883652     MOV W2, RPOR5
000588  2C0FF3     MOV #0xC0FF, W3
00058A  8036E6     MOV RPOR14, W6
00058C  618186     AND W3, W6, W3
00058E  207002     MOV #0x700, W2
000590  710103     IOR W2, W3, W2
000592  8836E2     MOV W2, RPOR14
221:               		__builtin_write_OSCCONL(OSCCONL | 0x40);	// Lock Registers
000594  207422     MOV #0x742, W2
000596  784112     MOV.B [W2], W2
000598  A06402     BSET.B W2, #6
00059A  FB8102     ZE W2, W2
00059C  207423     MOV #0x742, W3
00059E  784980     MOV.B W0, [W3]
0005A0  784981     MOV.B W1, [W3]
0005A2  784982     MOV.B W2, [W3]
222:               		BOOT_LOADER_INIT_MEM();						// Initialize SPI HW Registers
0005A4  200140     MOV #0x14, W0
0005A6  881200     MOV W0, SPI1STAT
0005A8  2007F0     MOV #0x7F, W0
0005AA  881210     MOV W0, SPI1CON1
0005AC  200010     MOV #0x1, W0
0005AE  881220     MOV W0, SPI1CON2
0005B0  A94085     BCLR 0x85, #2
0005B2  A94095     BCLR 0x95, #2
0005B4  A8E241     BSET 0x241, #7
223:               	}
224:               	{	// Auto programm	---------------------------------------------------------
225:               		register U8		a;
226:               		BootData.address.u32	= 0;
0005B6  220040     MOV #0x2004, W0
0005B8  EB0800     CLR [W0]
0005BA  781030     MOV [W0++], [W0--]
227:               		//	Clear SPI buffer	-----------------------------------------------------
228:               		MEM_CS = 1;										// BOOT_MEM_CS_OFF();
0005BC  A8A2CD     BSET 0x2CD, #5
229:               		while ((!BOOT_SPI_SHIFT_EMPTY) || (!BOOT_SPI_RX_FIFO_EMPTY))
0005BE  200801     MOV #0x80, W1
0005C0  200200     MOV #0x20, W0
0005C2  370001     BRA 0x5C6
0005C6  801207     MOV SPI1STAT, W7
0005C8  608107     AND W1, W7, W2
0005CA  32FFFC     BRA Z, 0x5C4
0005CC  801208     MOV SPI1STAT, W8
0005CE  600108     AND W0, W8, W2
0005D0  32FFF9     BRA Z, 0x5C4
0005D2  200090     MOV #0x9, W0
230:               				a = BOOT_SPI_BUF;
0005C4  801242     MOV SPI1BUF, W2
231:               		//	Memory Status check	-----------------------------------------------------
232:               		BOOT_MEM_CS_ON();
0005D4  A9A2CD     BCLR 0x2CD, #5
0005D6  E90000     DEC W0, W0
0005D8  3AFFFD     BRA NZ, 0x5D4
233:               		BootSpiByte(MEM_CMD_RDSR, a);					// Status read command
0005DA  200050     MOV #0x5, W0
0005DC  881240     MOV W0, SPI1BUF
0005DE  40007B     ADD W0, #0x1B, W0
0005E0  801209     MOV SPI1STAT, W9
0005E2  600089     AND W0, W9, W1
0005E4  3AFFFD     BRA NZ, 0x5E0
0005E6  801240     MOV SPI1BUF, W0
234:               		do	{	BootSpiByte(0, a);
0005E8  EB0100     CLR W2
0005EA  200201     MOV #0x20, W1
0005EC  881242     MOV W2, SPI1BUF
0005EE  80120B     MOV SPI1STAT, W11
0005F0  60800B     AND W1, W11, W0
0005F2  3AFFFD     BRA NZ, 0x5EE
235:               		} while ( a & 0x01 );
0005F4  AB0248     BTST SPI1BUF, #0
0005F6  3AFFFA     BRA NZ, 0x5EC
236:               		MEM_CS = 1;										// BOOT_MEM_CS_OFF();
0005F8  A8A2CD     BSET 0x2CD, #5
0005FA  200090     MOV #0x9, W0
237:               		//	Memory Address set	-----------------------------------------------------
238:               		BOOT_MEM_CS_ON();
0005FC  A9A2CD     BCLR 0x2CD, #5
0005FE  E90000     DEC W0, W0
000600  3AFFFD     BRA NZ, 0x5FC
239:               		BootSpiByte(MEM_CMD_READ, a);					// Memory Read command
000602  200030     MOV #0x3, W0
000604  881240     MOV W0, SPI1BUF
000606  40007D     ADD W0, #0x1D, W0
000608  801202     MOV SPI1STAT, W2
00060A  600082     AND W0, W2, W1
00060C  3AFFFD     BRA NZ, 0x608
00060E  801240     MOV SPI1BUF, W0
240:               		BootSpiByte(0, a);								// Address 3th byte 0xaAaa
000610  EF2248     CLR SPI1BUF
000612  200200     MOV #0x20, W0
000614  801203     MOV SPI1STAT, W3
000616  600083     AND W0, W3, W1
000618  3AFFFD     BRA NZ, 0x614
00061A  801240     MOV SPI1BUF, W0
241:               		BootSpiByte(0, a);								// Address 2nd byte 0xaaAa
00061C  EF2248     CLR SPI1BUF
00061E  200200     MOV #0x20, W0
000620  801204     MOV SPI1STAT, W4
000622  600084     AND W0, W4, W1
000624  3AFFFD     BRA NZ, 0x620
000626  801240     MOV SPI1BUF, W0
242:               		BootSpiByte(0, a);								// Address 1st byte 0xaaaA
000628  EF2248     CLR SPI1BUF
00062A  200200     MOV #0x20, W0
00062C  801205     MOV SPI1STAT, W5
00062E  600085     AND W0, W5, W1
000630  3AFFFD     BRA NZ, 0x62C
000632  801240     MOV SPI1BUF, W0
243:               		BOOT_SPI_BUF = 0;								// Feel spi buffer to
000634  EF2248     CLR SPI1BUF
244:               		BOOT_SPI_BUF = 0;								// read next bytes
000636  EF2248     CLR SPI1BUF
245:               
246:               		for (a = 0; a < 4; a++)
000638  EB4000     CLR.B W0
00064E  E84000     INC.B W0, W0
000650  504FE3     SUB.B W0, #0x3, [W15]
000652  36FFF6     BRA LEU, 0x640
247:               		{	BootSpiByteGet(BootData.sizeBytes[a]);	}	// Memory Read (File Size)
00063A  200202     MOV #0x20, W2
00063C  220004     MOV #0x2000, W4
00063E  EB0180     CLR W3
000640  801206     MOV SPI1STAT, W6
000642  610086     AND W2, W6, W1
000644  3AFFFD     BRA NZ, 0x640
000646  801245     MOV SPI1BUF, W5
000648  FB8080     ZE W0, W1
00064A  78F205     MOV.B W5, [W4+W1]
00064C  881243     MOV W3, SPI1BUF
248:               //		testVal.u32 = BootData.size;
249:               		BootData.size >>= 1;							// size in bytes -> addreses in words
000654  220000     MOV #0x2000, W0
000656  BE0110     MOV.D [W0], W2
000658  D10183     LSR W3, W3
00065A  D38102     RRC W2, W2
00065C  BE8802     MOV.D W2, [W0]
250:               //		BootData.size >>= 2;							// size in bytes -> addreses in words
251:               		while (BootData.address.u32 < BootData.size)
00065E  4000E4     ADD W0, #0x4, W1
000660  780500     MOV W0, W10
000672  370053     BRA 0x71A
00071A  BE0411     MOV.D [W1], W8
00071C  540FBA     SUB W8, [W10++], [W15]
00071E  5C8FAA     SUBB W9, [W10--], [W15]
000720  39FFA9     BRA NC, 0x674
252:               		{
253:               			Boot_CmdReadMem();
000662  400168     ADD W0, #0x8, W2
000664  200200     MOV #0x20, W0
000674  201006     MOV #0x100, W6
000676  780382     MOV W2, W7
000678  EB0400     CLR W8
00067A  801209     MOV SPI1STAT, W9
00067C  600289     AND W0, W9, W5
00067E  3AFFFD     BRA NZ, 0x67A
000680  801245     MOV SPI1BUF, W5
000682  785B85     MOV.B W5, [W7++]
000684  881248     MOV W8, SPI1BUF
000686  E90306     DEC W6, W6
000688  3AFFF8     BRA NZ, 0x67A
254:               			if ((BootData.address.u32 >= NO_LOAD_END) || (BootData.address.u32 < BOOT_LOADER_ADDR))
000666  2FC00C     MOV #0xFC00, W12
000668  2FFFFD     MOV #0xFFFF, W13
00068A  460331     ADD W12, [W1++], W6
00068C  4E83A1     ADDC W13, [W1--], W7
00068E  20BFF8     MOV #0xBFF, W8
000690  200009     MOV #0x0, W9
000692  530F88     SUB W6, W8, [W15]
000694  5B8F89     SUBB W7, W9, [W15]
000696  36003D     BRA LEU, 0x712
255:               			{
256:               				if (!(BootData.address.u16l & 0x03FF))
000698  780291     MOV [W1], W5
00069A  780305     MOV W5, W6
00069C  B23FF6     AND #0x3FF, W6
00069E  3A0013     BRA NZ, 0x6C6
257:               				{
258:               					Boot_CmdErase();
000670  24042E     MOV #0x4042, W14
0006A0  883B0E     MOV W14, NVMCON
0006A2  780494     MOV [W4], W9
0006A4  8802A9     MOV W9, TBLPAG
0006A6  BB0A86     TBLWTL W6, [W5]
0006A8  FC0005     DISI #0x5
0006AA  200555     MOV #0x55, W5
0006AC  883B35     MOV W5, NVMKEY
0006AE  200AA5     MOV #0xAA, W5
0006B0  883B35     MOV W5, NVMKEY
0006B2  A8E761     BSET 0x761, #7
0006B4  000000     NOP
0006B6  000000     NOP
259:               					LED_BOOT = !LED_BOOT;
0006B8  801765     MOV LATF, W5
0006BA  6282E1     AND W5, #0x1, W5
0006BC  A20005     BTG W5, #0
0006BE  801766     MOV LATF, W6
0006C0  A10006     BCLR W6, #0
0006C2  728306     IOR W5, W6, W6
0006C4  881766     MOV W6, LATF
260:               				}
261:               				Boot_CmdProgramm();
00066A  24001B     MOV #0x4001, W11
00066C  E88201     INC2 W1, W4
00066E  4081E6     ADD W1, #0x6, W3
0006C6  200405     MOV #0x40, W5
0006C8  780491     MOV [W1], W9
0006CA  780309     MOV W9, W6
0006CC  780382     MOV W2, W7
0006CE  883B0B     MOV W11, NVMCON
0006D0  780414     MOV [W4], W8
0006D2  8802A8     MOV W8, TBLPAG
0006D4  E00008     CP0 W8
0006D6  3A000D     BRA NZ, 0x6F2
0006D8  201008     MOV #0x100, W8
0006DA  548F88     SUB W9, W8, [W15]
0006DC  3A000A     BRA NZ, 0x6F2
0006DE  780412     MOV [W2], W8
0006E0  891078     MOV W8, resetL
0006E2  EB8900     SETM [W2]
0006E4  780493     MOV [W3], W9
0006E6  891069     MOV W9, resetH
0006E8  811049     MOV resCom, W9
0006EA  200F88     MOV #0xF8, W8
0006EC  548F88     SUB W9, W8, [W15]
0006EE  320001     BRA Z, 0x6F2
0006F0  EB8980     SETM [W3]
0006F2  E88407     INC2 W7, W8
0006F4  BB0B17     TBLWTL [W7], [W6]
0006F6  780388     MOV W8, W7
0006F8  BB8B37     TBLWTH [W7++], [W6]
0006FA  E88306     INC2 W6, W6
0006FC  E90405     DEC W5, W8
0006FE  780288     MOV W8, W5
000700  3AFFF8     BRA NZ, 0x6F2
000702  FC0005     DISI #0x5
000704  200555     MOV #0x55, W5
000706  883B35     MOV W5, NVMKEY
000708  200AA5     MOV #0xAA, W5
00070A  883B35     MOV W5, NVMKEY
00070C  A8E761     BSET 0x761, #7
00070E  000000     NOP
000710  000000     NOP
262:               			}
263:               			BootData.address.u32 += (FLASH_ROW_WORDS);
000712  200806     MOV #0x80, W6
000714  200007     MOV #0x0, W7
000716  430891     ADD W6, [W1], [W1]
000718  4B90D1     ADDC W7, [++W1], [W1--]
264:               		}
265:               
266:               //		for (a = 0; a < 20; a++)
267:               //			testBuf[a] = BootData.data[a];
268:               		MEM_CS = 1;										// BOOT_MEM_CS_OFF();
000722  A8A2CD     BSET 0x2CD, #5
269:               		
270:               	}
271:               	goto Boot_WriteResetAddress;
000724  37015F     BRA 0x9E4
272:               
273:               #if	(BOOT_UART != NO_PORT)
274:               Boot_ProgrammFromUart:
275:               	{	// Uart Programming	---------------------------------------------------------
276:               		unsigned int rxTimeOut = 0, ledTime = 0;
000866  EB0100     CLR W2
000868  EB0280     CLR W5
277:               		rxData		= &BootData.command;
000726  220030     MOV #0x2003, W0
000728  891030     MOV W0, rxData
278:               		BootState	= BootState_Wait;
00072A  EB0000     CLR W0
00072C  891000     MOV W0, BootState
279:               		resetL		= 0xFFFF;
00072E  EB8080     SETM W1
000730  891071     MOV W1, resetL
280:               		resetH		= 0xFFFF;
000732  891061     MOV W1, resetH
281:               		BootData.len.u16 = 0;
000734  890000     MOV W0, BootData
282:               
283:               		Boot_TxString_p(Msg_Start);
000736  20A1C0     MOV #0xA1C, W0
000738  201001     MOV #0x100, W1
00073A  202004     MOV #0x200, W4
00073C  370007     BRA 0x74C
00073E  801299     MOV U3STA, W9
000740  620189     AND W4, W9, W3
000742  3AFFFD     BRA NZ, 0x73E
000744  FB0102     SE W2, W2
000746  8812A2     MOV W2, U3TXREG
000748  400061     ADD W0, #0x1, W0
00074A  4880E0     ADDC W1, #0x0, W1
00074C  800195     MOV DSRPAG, W5
00074E  780100     MOV W0, W2
000750  A4F002     BTSTS.C W2, #15
000752  D28181     RLC W1, W3
000754  880193     MOV W3, DSRPAG
000756  784112     MOV.B [W2], W2
000758  880195     MOV W5, DSRPAG
00075A  E00402     CP0.B W2
00075C  3AFFF0     BRA NZ, 0x73E
00075E  20A300     MOV #0xA30, W0
000760  201001     MOV #0x100, W1
284:               		Boot_TxString_p(Msg_B_Vers);	Boot_TxString_p(Msg_Vers);
000762  202004     MOV #0x200, W4
000764  370007     BRA 0x774
000766  80129B     MOV U3STA, W11
000768  62018B     AND W4, W11, W3
00076A  3AFFFD     BRA NZ, 0x766
00076C  FB0102     SE W2, W2
00076E  8812A2     MOV W2, U3TXREG
000770  400061     ADD W0, #0x1, W0
000772  4880E0     ADDC W1, #0x0, W1
000774  800195     MOV DSRPAG, W5
000776  780100     MOV W0, W2
000778  A4F002     BTSTS.C W2, #15
00077A  D28181     RLC W1, W3
00077C  880193     MOV W3, DSRPAG
00077E  784112     MOV.B [W2], W2
000780  880195     MOV W5, DSRPAG
000782  E00402     CP0.B W2
000784  3AFFF0     BRA NZ, 0x766
000786  20A660     MOV #0xA66, W0
000788  201001     MOV #0x100, W1
00078A  202004     MOV #0x200, W4
00078C  370007     BRA 0x79C
00078E  801295     MOV U3STA, W5
000790  620185     AND W4, W5, W3
000792  3AFFFD     BRA NZ, 0x78E
000794  FB0102     SE W2, W2
000796  8812A2     MOV W2, U3TXREG
000798  400061     ADD W0, #0x1, W0
00079A  4880E0     ADDC W1, #0x0, W1
00079C  800195     MOV DSRPAG, W5
00079E  780100     MOV W0, W2
0007A0  A4F002     BTSTS.C W2, #15
0007A2  D28181     RLC W1, W3
0007A4  880193     MOV W3, DSRPAG
0007A6  784112     MOV.B [W2], W2
0007A8  880195     MOV W5, DSRPAG
0007AA  E00402     CP0.B W2
0007AC  3AFFF0     BRA NZ, 0x78E
0007AE  20A420     MOV #0xA42, W0
0007B0  201001     MOV #0x100, W1
285:               		Boot_TxString_p(Msg_B_Date);	Boot_TxString_p(Msg_Date);
0007B2  202004     MOV #0x200, W4
0007B4  370007     BRA 0x7C4
0007B6  801296     MOV U3STA, W6
0007B8  620186     AND W4, W6, W3
0007BA  3AFFFD     BRA NZ, 0x7B6
0007BC  FB0102     SE W2, W2
0007BE  8812A2     MOV W2, U3TXREG
0007C0  400061     ADD W0, #0x1, W0
0007C2  4880E0     ADDC W1, #0x0, W1
0007C4  800195     MOV DSRPAG, W5
0007C6  780100     MOV W0, W2
0007C8  A4F002     BTSTS.C W2, #15
0007CA  D28181     RLC W1, W3
0007CC  880193     MOV W3, DSRPAG
0007CE  784112     MOV.B [W2], W2
0007D0  880195     MOV W5, DSRPAG
0007D2  E00402     CP0.B W2
0007D4  3AFFF0     BRA NZ, 0x7B6
0007D6  20A700     MOV #0xA70, W0
0007D8  201001     MOV #0x100, W1
0007DA  202004     MOV #0x200, W4
0007DC  370007     BRA 0x7EC
0007DE  801297     MOV U3STA, W7
0007E0  620187     AND W4, W7, W3
0007E2  3AFFFD     BRA NZ, 0x7DE
0007E4  FB0102     SE W2, W2
0007E6  8812A2     MOV W2, U3TXREG
0007E8  400061     ADD W0, #0x1, W0
0007EA  4880E0     ADDC W1, #0x0, W1
0007EC  800195     MOV DSRPAG, W5
0007EE  780100     MOV W0, W2
0007F0  A4F002     BTSTS.C W2, #15
0007F2  D28181     RLC W1, W3
0007F4  880193     MOV W3, DSRPAG
0007F6  784112     MOV.B [W2], W2
0007F8  880195     MOV W5, DSRPAG
0007FA  E00402     CP0.B W2
0007FC  3AFFF0     BRA NZ, 0x7DE
0007FE  20A540     MOV #0xA54, W0
000800  201001     MOV #0x100, W1
286:               		Boot_TxString_p(Msg_B_Time);	Boot_TxString_p(Msg_Time);
000802  202004     MOV #0x200, W4
000804  370007     BRA 0x814
000806  801298     MOV U3STA, W8
000808  620188     AND W4, W8, W3
00080A  3AFFFD     BRA NZ, 0x806
00080C  FB0102     SE W2, W2
00080E  8812A2     MOV W2, U3TXREG
000810  400061     ADD W0, #0x1, W0
000812  4880E0     ADDC W1, #0x0, W1
000814  800195     MOV DSRPAG, W5
000816  780100     MOV W0, W2
000818  A4F002     BTSTS.C W2, #15
00081A  D28181     RLC W1, W3
00081C  880193     MOV W3, DSRPAG
00081E  784112     MOV.B [W2], W2
000820  880195     MOV W5, DSRPAG
000822  E00402     CP0.B W2
000824  3AFFF0     BRA NZ, 0x806
000826  20A7C0     MOV #0xA7C, W0
000828  201001     MOV #0x100, W1
00082A  202004     MOV #0x200, W4
00082C  370007     BRA 0x83C
00082E  801299     MOV U3STA, W9
000830  620189     AND W4, W9, W3
000832  3AFFFD     BRA NZ, 0x82E
000834  FB0102     SE W2, W2
000836  8812A2     MOV W2, U3TXREG
000838  400061     ADD W0, #0x1, W0
00083A  4880E0     ADDC W1, #0x0, W1
00083C  800195     MOV DSRPAG, W5
00083E  780100     MOV W0, W2
000840  A4F002     BTSTS.C W2, #15
000842  D28181     RLC W1, W3
000844  880193     MOV W3, DSRPAG
000846  784112     MOV.B [W2], W2
000848  880195     MOV W5, DSRPAG
00084A  E00402     CP0.B W2
00084C  3AFFF0     BRA NZ, 0x82E
287:               		TxByte('\r');	TxByte('\n');
00084E  202000     MOV #0x200, W0
000850  80129B     MOV U3STA, W11
000852  60008B     AND W0, W11, W1
000854  3AFFFD     BRA NZ, 0x850
000856  2000D0     MOV #0xD, W0
000858  8812A0     MOV W0, U3TXREG
00085A  202000     MOV #0x200, W0
00085C  801292     MOV U3STA, W2
00085E  600082     AND W0, W2, W1
000860  3AFFFD     BRA NZ, 0x85C
000862  2000A0     MOV #0xA, W0
000864  8812A0     MOV W0, U3TXREG
288:               
289:               		while (1)
290:               		{
291:               			if (!UART_RX_EMPTY)										// Rx have a byte
000886  AB0252     BTST U3STA, #0
000888  32009D     BRA Z, 0x9C4
292:               			{
293:               				register unsigned char data = UART_RX_DATA;			// get byte
00088A  8012B2     MOV U3RXREG, W2
294:               				switch (BootState)
00088C  811005     MOV BootState, W5
00088E  528FE2     SUB W5, #0x2, [W15]
000890  320022     BRA Z, 0x8D6
000892  3E0005     BRA GTU, 0x89E
000894  E00005     CP0 W5
000896  320008     BRA Z, 0x8A8
000898  528FE1     SUB W5, #0x1, [W15]
00089A  3AFFF2     BRA NZ, 0x880
00089C  37000E     BRA 0x8BA
00089E  528FE3     SUB W5, #0x3, [W15]
0008A0  320026     BRA Z, 0x8EE
0008A2  528FE4     SUB W5, #0x4, [W15]
0008A4  3AFFED     BRA NZ, 0x880
0008A6  37003C     BRA 0x920
295:               				{
296:               				case BootState_Wait:	if (data == BOOT_START)	{	csm	= 0; idx = 1;		BootState	= BootState_Len;	}
0008AA  B3CA56     MOV.B #0xA5, W6
0008AC  514F86     SUB.B W2, W6, [W15]
0008AE  3AFFEB     BRA NZ, 0x886
0008B0  EB4880     CLR.B [W1]
0008B2  200012     MOV #0x1, W2
0008B4  891022     MOV W2, idx
0008B6  891002     MOV W2, BootState
0008B8  37FFE6     BRA 0x886
297:               										break;
298:               				case BootState_Len:		if (idx)				{	BootData.len.u8l = data; idx = 0;						}
0008BA  811025     MOV idx, W5
0008BC  E00005     CP0 W5
0008BE  320005     BRA Z, 0x8CA
0008C0  784C82     MOV.B W2, [W9]
0008C2  EB0100     CLR W2
0008C4  891022     MOV W2, idx
299:               										else					{	BootData.len.u8h = data;BootState = BootState_Capture;	}
0008CA  220015     MOV #0x2001, W5
0008CC  784A82     MOV.B W2, [W5]
0008CE  200022     MOV #0x2, W2
0008D0  891002     MOV W2, BootState
300:               										break;
301:               				case BootState_Capture:	rxData[idx++] = data;
0008D6  811026     MOV idx, W6
0008D8  811035     MOV rxData, W5
0008DA  7B7282     MOV.B W2, [W5+W6]
0008DC  E80306     INC W6, W6
0008DE  891026     MOV W6, idx
302:               										csm			 ^= data;
00086A  222021     MOV #0x2202, W1
0008E0  694891     XOR.B W2, [W1], [W1]
303:               										if (idx >= BootData.len.u16)						BootState = BootState_CheckSum;
00086C  220009     MOV #0x2000, W9
0008E4  530F99     SUB W6, [W9], [W15]
0008E6  39FFCF     BRA NC, 0x886
0008E8  200032     MOV #0x3, W2
0008EA  891002     MOV W2, BootState
0008EC  37FFCC     BRA 0x886
304:               										break;
305:               				case BootState_CheckSum: rxData[idx] = data;
0008EE  811025     MOV idx, W5
0008F0  811036     MOV rxData, W6
0008F2  7AF302     MOV.B W2, [W6+W5]
306:               										BootState = BootState_Wait;
0008F4  EB0280     CLR W5
0008F6  891005     MOV W5, BootState
307:               										if (data != csm)		{TxByte(NAK_CS); TxByte(data); TxByte(csm);	break;			}
0008F8  784291     MOV.B [W1], W5
0008FA  514F85     SUB.B W2, W5, [W15]
0008FC  320011     BRA Z, 0x920
0008FE  801297     MOV U3STA, W7
000900  600307     AND W0, W7, W6
000902  3AFFFD     BRA NZ, 0x8FE
000904  200346     MOV #0x34, W6
000906  8812A6     MOV W6, U3TXREG
000908  80129B     MOV U3STA, W11
00090A  60030B     AND W0, W11, W6
00090C  3AFFFD     BRA NZ, 0x908
00090E  FB8102     ZE W2, W2
000910  8812A2     MOV W2, U3TXREG
000912  801296     MOV U3STA, W6
000914  600106     AND W0, W6, W2
000916  3AFFFD     BRA NZ, 0x912
000918  FB8285     ZE W5, W5
00091A  8812A5     MOV W5, U3TXREG
00091E  37FFB3     BRA 0x886
308:               				case BootState_Command:	TxByte(ACK_CS);
00086E  202000     MOV #0x200, W0
000920  801297     MOV U3STA, W7
000922  600107     AND W0, W7, W2
000924  3AFFFD     BRA NZ, 0x920
000926  200332     MOV #0x33, W2
000928  8812A2     MOV W2, U3TXREG
309:               										switch (BootData.command)
000870  448663     ADD W9, #0x3, W12
00092A  78411C     MOV.B [W12], W2
00092C  B3CB15     MOV.B #0xB1, W5
00092E  514F85     SUB.B W2, W5, [W15]
000930  320007     BRA Z, 0x940
000932  E84285     INC.B W5, W5
000934  514F85     SUB.B W2, W5, [W15]
000936  320019     BRA Z, 0x96A
000938  E9C285     DEC2.B W5, W5
00093A  514F85     SUB.B W2, W5, [W15]
00093C  3AFFA3     BRA NZ, 0x884
00093E  370052     BRA 0x9E4
310:               										{
311:               										case BOOT_CMD_RESET:	goto Boot_WriteResetAddress;
312:               										case BOOT_CMD_ERASE:	Boot_CmdErase();				TxByte(ACK_ERASE);	break;
000872  24042E     MOV #0x4042, W14
000874  448466     ADD W9, #0x6, W8
000876  E98208     DEC2 W8, W4
000940  883B0E     MOV W14, NVMCON
000942  780598     MOV [W8], W11
000944  8802AB     MOV W11, TBLPAG
000946  780114     MOV [W4], W2
000948  EB0280     CLR W5
00094A  BB0905     TBLWTL W5, [W2]
00094C  FC0005     DISI #0x5
00094E  200552     MOV #0x55, W2
000950  883B32     MOV W2, NVMKEY
000952  200AA2     MOV #0xAA, W2
000954  883B32     MOV W2, NVMKEY
000956  A8E761     BSET 0x761, #7
000958  000000     NOP
00095A  000000     NOP
00095C  801295     MOV U3STA, W5
00095E  600105     AND W0, W5, W2
000960  3AFFFD     BRA NZ, 0x95C
000962  200352     MOV #0x35, W2
000964  8812A2     MOV W2, U3TXREG
000968  37FF8E     BRA 0x886
313:               										case BOOT_CMD_PROGRAM:	Boot_CmdProgramm();				TxByte(ACK_PROG);	break;
000878  24001D     MOV #0x4001, W13
00087A  4201E6     ADD W4, #0x6, W3
00087C  780502     MOV W2, W10
00087E  370003     BRA 0x886
00096A  200405     MOV #0x40, W5
00096C  780594     MOV [W4], W11
00096E  78030B     MOV W11, W6
000970  220087     MOV #0x2008, W7
000972  883B0D     MOV W13, NVMCON
000974  780118     MOV [W8], W2
000976  8802A2     MOV W2, TBLPAG
000978  E00002     CP0 W2
00097A  3A000D     BRA NZ, 0x996
00097C  201002     MOV #0x100, W2
00097E  558F82     SUB W11, W2, [W15]
000980  3A000A     BRA NZ, 0x996
000982  780597     MOV [W7], W11
000984  89107B     MOV W11, resetL
000986  EB8B80     SETM [W7]
000988  780113     MOV [W3], W2
00098A  891062     MOV W2, resetH
00098C  81104B     MOV resCom, W11
00098E  200F82     MOV #0xF8, W2
000990  558F82     SUB W11, W2, [W15]
000992  320001     BRA Z, 0x996
000994  EB8980     SETM [W3]
000996  E88107     INC2 W7, W2
000998  BB0B17     TBLWTL [W7], [W6]
00099A  780382     MOV W2, W7
00099C  BB8B37     TBLWTH [W7++], [W6]
00099E  E88306     INC2 W6, W6
0009A0  E90105     DEC W5, W2
0009A2  780282     MOV W2, W5
0009A4  3AFFF8     BRA NZ, 0x996
0009A6  FC0005     DISI #0x5
0009A8  200552     MOV #0x55, W2
0009AA  883B32     MOV W2, NVMKEY
0009AC  200AA2     MOV #0xAA, W2
0009AE  883B32     MOV W2, NVMKEY
0009B0  A8E761     BSET 0x761, #7
0009B2  000000     NOP
0009B4  000000     NOP
0009B6  801295     MOV U3STA, W5
0009B8  600105     AND W0, W5, W2
0009BA  3AFFFD     BRA NZ, 0x9B6
0009BC  200362     MOV #0x36, W2
0009BE  8812A2     MOV W2, U3TXREG
0009C2  37FF61     BRA 0x886
314:               										default:															break;
315:               										}
316:               										break;
317:               				default:				break;
318:               				}
319:               				rxTimeOut = 0;
000880  EB0280     CLR W5
000882  370001     BRA 0x886
000884  EB0280     CLR W5
0008A8  EB0280     CLR W5
0008C6  EB0280     CLR W5
0008C8  37FFDE     BRA 0x886
0008D2  EB0280     CLR W5
0008D4  37FFD8     BRA 0x886
0008E2  EB0280     CLR W5
00091C  EB0280     CLR W5
000966  EB0280     CLR W5
0009C0  EB0280     CLR W5
320:               			}
321:               			else if (!--ledTime)
0009C4  E9050A     DEC W10, W10
0009C6  3AFF5F     BRA NZ, 0x886
322:               			{
323:               				if (!rxTimeOut)			{	rxTimeOut = 8;	LED_BOOT = !LED_BOOT;	}
0009C8  E00005     CP0 W5
0009CA  3A0009     BRA NZ, 0x9DE
0009CC  801762     MOV LATF, W2
0009CE  610161     AND W2, #0x1, W2
0009D0  A20002     BTG W2, #0
0009D2  801765     MOV LATF, W5
0009D4  A10005     BCLR W5, #0
0009D6  710285     IOR W2, W5, W5
0009D8  881765     MOV W5, LATF
0009DA  200085     MOV #0x8, W5
0009DC  37FF54     BRA 0x886
324:               				else					{	rxTimeOut--;	LED_BOOT = 1;			}
0009DE  E90285     DEC W5, W5
0009E0  A802EC     BSET LATF, #0
0009E2  37FF51     BRA 0x886
325:               			}
326:               		}
327:               	}
328:               #endif
329:               Boot_WriteResetAddress:
330:               	{	// Set Reset Address	-----------------------------------------------------
331:               		register unsigned int	offset	= RESET_ADDR;
332:               		TBLPAG	= 0;								// Initialize PM Page Boundary SFR
0009E4  EF2054     CLR TBLPAG
333:               		NVMCON	= NVMCON_PROG_WORD;					// Initialize NVMCON
0009E6  240030     MOV #0x4003, W0
0009E8  883B00     MOV W0, NVMCON
334:               		__builtin_tblwtl(offset, resetL);			// Write to address low word
0009EA  201000     MOV #0x100, W0
0009EC  811071     MOV resetL, W1
0009EE  BB0801     TBLWTL W1, [W0]
335:               		__builtin_tblwth(offset, resetH);			// Write to upper byte
0009F0  811061     MOV resetH, W1
0009F2  BB8801     TBLWTH W1, [W0]
336:               		asm("DISI #5");								// Block interrupts with priority <7
0009F4  FC0005     DISI #0x5
337:               		__builtin_write_NVM();						// C30 function to perform unlock
0009F6  200550     MOV #0x55, W0
0009F8  883B30     MOV W0, NVMKEY
0009FA  200AA0     MOV #0xAA, W0
0009FC  883B30     MOV W0, NVMKEY
0009FE  A8E761     BSET 0x761, #7
000A00  000000     NOP
000A02  000000     NOP
338:               		while(NVMCONbits.WR == 1)	{}
000A04  280000     MOV #0x8000, W0
000A06  803B06     MOV NVMCON, W6
000A08  600086     AND W0, W6, W1
000A0A  3AFFFD     BRA NZ, 0xA06
339:               	}
340:               Boot_ResetDevice:
341:               	__asm__ ("RESET");	while(1);
000A0C  FE0000     RESET
000A0E  37FFFF     BRA 0xA0E
342:               }
343:               
344:               void BootFlashInit	(void)
345:               {
346:               	register unsigned int	offset	= RESET_ADDR;
347:               	TBLPAG	= 0;
007A62  EF2054     CLR TBLPAG
348:               	resCom	= __builtin_tblrdh(offset);
007A64  201000     MOV #0x100, W0
007A66  BA8090     TBLRDH [W0], W1
007A68  891041     MOV W1, resCom
349:               	resAddr	= __builtin_tblrdl(offset);
007A6A  BA0090     TBLRDL [W0], W1
007A6C  891051     MOV W1, resAddr
350:               
351:               	resCom	&= FLASH_IN_MEM;
007A6E  811041     MOV resCom, W1
007A70  B20F81     AND #0xF8, W1
007A72  891041     MOV W1, resCom
352:               
353:               	NVMCON	= NVMCON_PROG_WORD;					// Initialize NVMCON
007A74  240031     MOV #0x4003, W1
007A76  883B01     MOV W1, NVMCON
354:               	__builtin_tblwtl(offset, resAddr);			// Write to address low word
007A78  811051     MOV resAddr, W1
007A7A  BB0801     TBLWTL W1, [W0]
355:               	__builtin_tblwth(offset, resCom);			// Write to upper byte
007A7C  811041     MOV resCom, W1
007A7E  BB8801     TBLWTH W1, [W0]
356:               	asm("DISI #5");								// Block interrupts with priority <7
007A80  FC0005     DISI #0x5
357:               	__builtin_write_NVM();						// C30 function to perform unlock
007A82  200550     MOV #0x55, W0
007A84  883B30     MOV W0, NVMKEY
007A86  200AA0     MOV #0xAA, W0
007A88  883B30     MOV W0, NVMKEY
007A8A  A8E761     BSET 0x761, #7
007A8C  000000     NOP
007A8E  000000     NOP
358:               	while(NVMCONbits.WR == 1)	{}
007A90  280001     MOV #0x8000, W1
007A92  803B02     MOV NVMCON, W2
007A94  608002     AND W1, W2, W0
007A96  3AFFFD     BRA NZ, 0x7A92
359:               }
007A98  060000     RETURN
360:               
361:               U8	 BootFlashNew	(void)
362:               {
363:               	if (resCom == FLASH_PROGRAMMED)
007A9A  811042     MOV resCom, W2
007A9E  200FE1     MOV #0xFE, W1
007AA0  510F81     SUB W2, W1, [W15]
007AA2  3A0018     BRA NZ, 0x7AD4
364:               	{
365:               		resCom	&= FLASH_OK;
007AA4  811040     MOV resCom, W0
007AA6  B20FC0     AND #0xFC, W0
007AA8  891040     MOV W0, resCom
366:               		register unsigned int	offset	= RESET_ADDR;
367:               		TBLPAG	= 0;
007AAA  EF2054     CLR TBLPAG
368:               		NVMCON	= NVMCON_PROG_WORD;					// Initialize NVMCON
007AAC  240030     MOV #0x4003, W0
007AAE  883B00     MOV W0, NVMCON
369:               		__builtin_tblwtl(offset, resAddr);			// Write to address low word
007AB0  811051     MOV resAddr, W1
007AB2  201000     MOV #0x100, W0
007AB4  BB0801     TBLWTL W1, [W0]
370:               		__builtin_tblwth(offset, resCom);			// Write to upper byte
007AB6  811041     MOV resCom, W1
007AB8  BB8801     TBLWTH W1, [W0]
371:               		asm("DISI #5");								// Block interrupts with priority <7
007ABA  FC0005     DISI #0x5
372:               		__builtin_write_NVM();						// C30 function to perform unlock
007ABC  200550     MOV #0x55, W0
007ABE  883B30     MOV W0, NVMKEY
007AC0  200AA0     MOV #0xAA, W0
007AC2  883B30     MOV W0, NVMKEY
007AC4  A8E761     BSET 0x761, #7
007AC6  000000     NOP
007AC8  000000     NOP
373:               		while(NVMCONbits.WR == 1)	{}
007ACA  280001     MOV #0x8000, W1
007ACC  803B02     MOV NVMCON, W2
007ACE  608002     AND W1, W2, W0
007AD0  3AFFFD     BRA NZ, 0x7ACC
374:               		return 1;
007AD2  B3C010     MOV.B #0x1, W0
375:               	}
376:               	return 0;
007A9C  EB4000     CLR.B W0
377:               }
007AD4  060000     RETURN
378:               
379:               #else
380:               	#define	BootFlashInit()
381:               	#define BootFlashNew()		0
382:               #endif
---  /home/pele/src/Auto_02/src/Adc.c  ------------------------------------------------------------------
1:                 #include	"Adc.h"
2:                 #include	"Ports.h"
3:                 #include	"Timers.h"
4:                 #include	"Tcp.h"
5:                 #include	<string.h>
6:                 #include	<stdio.h>
7:                 
8:                 volatile	POWER_STATE		PowerState = power_NoPower;
9:                 volatile	BATTERY_LEVEL	AdcPower, AdcBattery;
10:                volatile	U16				Power = 0, Battery = 0;
11:                
12:                #define		DC_LEVEL_3_80	567
13:                //const		U16		DcDcReductionSteps[15] = {DC_LEVEL_3_80, 586, 607, 629, 651, 673, 697, 721, 747, 773, 800, 828, 857, 887, 0};
14:                const		U16		DcDcReductionSteps[15] = {DC_LEVEL_3_80, 586, 604, 623, 643, 664, 686, 709, 733, 758, 784, 811, 818, 847, 0};
15:                //													17	 18	  19   20	21	 22	  23   24	25	 26	  27   28	29
16:                void AdcInit(void)
17:                {
18:                	//AD1CON1 Register
19:                	AD1CON1 = 0b0000000011100100;	// AD1CON1 Register
0075BE  200E40     MOV #0xE4, W0
0075C0  881900     MOV W0, AD1CON1
20:                			//	|||||||||||||||+	-- DONE: A/D Conversion Status bit
21:                			//	||||||||||||||+-	-- SAMP: A/D Sample Enable bit
22:                			//	|||||||||||||+--	-- ASAM: A/D Sample Auto-Start bit
23:                			//	|||||||||||++---	-- Unimplemented
24:                			//	||||||||+++-----	-- SSRC<2:0>: Conversion Trigger Source Select bits (auto-convert)
25:                			//	||||||++--------	-- FORM<1:0>: Data Output Format bits
26:                			//	|||+++----------	-- Unimplemented
27:                			//	||+-------------	-- ADSIDL: Stop in Idle Mode bit
28:                			//	|+--------------	-- Unimplemented
29:                			//	+---------------	-- ADON: A/D Operating Mode bit
30:                    //AD1CON2 Register
31:                	AD1CON2 = 0b0000010000011000;	// AD1CON2 Register
0075C2  B03340     ADD #0x334, W0
0075C4  881910     MOV W0, AD1CON2
32:                			//	|||||||||||||||+	-- ALTS: Alternate Input Sample Mode Select bit
33:                			//	||||||||||||||+-	-- BUFM: Buffer Mode Select bit
34:                			//	|||||||||+++++--	-- SMPI<4:0>: Sample/Convert Sequences Per Interrupt Selection bits
35:                			//	||||||||+-------	-- BUFS: Buffer Fill Status bit (valid only when BUFM = 1)
36:                			//	||||||++--------	-- Unimplemented
37:                			//	|||||+----------	-- CSCNA: Scan Input Selections for the CH0+ S/H Input for MUX A Input Multiplexer Setting bit
38:                			//	||||+-----------	-- Unimplemented
39:                			//	|||+------------	-- Reserved
40:                			//	+++-------------	-- VCFG<2:0>: Voltage Reference Configuration bits - VR+ = AVDD; VR- = AVSS (default)
41:                
42:                	// AD1CON3 Register
43:                	AD1CON3 = 0b0001000000000001;	// AD1CON3 Register
0075C6  210010     MOV #0x1001, W0
0075C8  881920     MOV W0, AD1CON3
44:                			//	||||||||++++++++	-- ADCS<7:0>: A/D Conversion Clock Select bits
45:                			//	|||+++++--------	-- SAMC<4:0>: Auto-Sample Time bits
46:                			//	|++-------------	-- Reserved
47:                			//	+---------------	-- ADRC: A/D Conversion Clock Source bit
48:                
49:                	// AD1CSSL - A/D Input Scan Select Register (low)
50:                    AD1CSSL				= 0x003F;	// AN0-AN5 is selected for input scan
0075CA  2003F0     MOV #0x3F, W0
0075CC  881980     MOV W0, AD1CSSL
51:                	// AD1CSSH - A/D Input Scan Select Register (high)
52:                	_CSSL26				= 1;		// Internal core voltage (VCAP) is selected for input scan
0075CE  A8432F     BSET 0x32F, #2
53:                
54:                	_AD1IF	= 0;		// Clear the ADC1 Interrupt Flag
0075D0  A9A085     BCLR 0x85, #5
55:                	_AD1IE	= 1;		// Enable ADC1 Interrupt
0075D2  A8A095     BSET 0x95, #5
56:                	_AD1IP	= 4;		// Set	  ADC  Interrupt priority
0075D4  2FF8F0     MOV #0xFF8F, W0
0075D6  B600AA     AND IPC3, WREG
0075D8  A06000     BSET W0, #6
0075DA  880550     MOV W0, IPC3
57:                	_ADON	= 1;		// A/D Converter is On
0075DC  A8E321     BSET 0x321, #7
58:                }
0075DE  060000     RETURN
59:                
60:                #define	BATTERY_0_VOLT_LEVEL			13			// 
61:                #define	BATTERY_100_PERCENT_LEVEL		4200		// 4.2V			4200 - 2600 = 1600; 1600 / 100% = 16
62:                #define	BATTERY_0___PERCENT_LEVEL		2560//2592		// 2.6V - (1% / 2)
63:                #define	BATTERY_PERCENTS(V_x_1000)		((V_x_1000 - BATTERY_0___PERCENT_LEVEL) >> 4)	// ((Volts x 1000) - 0%_level ) / 1%_Value ( / 16)
64:                
65:                #define	POWER_ADD_VAL					175			// Power step = 20.5 (20.5 x 2 = 41)
66:                #define	POWER_MULTIPLIER				50			// (20.5 * 25 * 25) >> 10 = 1,0009765625
67:                #define	POWER_DIVIDE_SHIFT				10
68:                #define	POWER_DIVIDE_REMAINDER			0x3FF
69:                #define	POWER_MW_CUT					25			// 0.999 * 1024 = 1022,976
70:                
71:                /* Battery
72:                // 3.59V    535
73:                // 4.01		585
74:                // 4.05		590
75:                // 4.15		605
76:                // 4.20		612
77:                */
78:                
79:                inline	void ADC_Dc_Update		(void);
80:                inline	void ADC_BatteryLevel	(void);
81:                inline	void ADC_PowerLevel		(void);
82:                inline	void ADC_PowerControll	(void);
83:                inline	void ADC_Test			(void);
84:                //	*********************************************************************
85:                //	*							ADC INTERRUPT							*
86:                //	*********************************************************************
87:                void __attribute__((interrupt, no_auto_psv)) _ADC1Interrupt(void)	//	*
88:                {																	//	*
0076A4  F80036     PUSH RCOUNT
0076A6  BE9F80     MOV.D W0, [W15++]
0076A8  BE9F82     MOV.D W2, [W15++]
0076AA  BE9F84     MOV.D W4, [W15++]
0076AC  BE9F86     MOV.D W6, [W15++]
89:                	_AD1IF	= 0;				// Clear the ADC1 Interrupt Flag		*
0076AE  A9A085     BCLR 0x85, #5
90:                
91:                	ADC_Dc_Update();
0076B0  07FF97     RCALL ADC_Dc_Update
92:                	ADC_BatteryLevel();
0076B2  07FFB6     RCALL ADC_BatteryLevel
93:                	ADC_PowerLevel();
0076B4  07FFC6     RCALL ADC_PowerLevel
94:                	ADC_PowerControll();
0076B6  07FFDA     RCALL ADC_PowerControll
95:                //	ADC_Test();
96:                }																	//	*
0076B8  BE034F     MOV.D [--W15], W6
0076BA  BE024F     MOV.D [--W15], W4
0076BC  BE014F     MOV.D [--W15], W2
0076BE  BE004F     MOV.D [--W15], W0
0076C0  F90036     POP RCOUNT
0076C2  064000     RETFIE
97:                
98:                inline void ADC_Dc_Update(void)
99:                {
100:               	if (Battery > 3800)
0075E0  20ED80     MOV #0xED8, W0
0075E2  E308D4     CP Battery
0075E4  360002     BRA LEU, 0x75EA
101:               		OC1R = 0;
0075E6  EF2196     CLR OC1R
0075E8  37001A     BRA 0x761E
102:               	else
103:               	{
104:               		register U16 adc		= AN_V18;
0075EA  801861     MOV ADC1BUF6, W1
105:               		register U16 step;
106:               		if (adc > AN_V18_VALUE)
0075EE  2023C2     MOV #0x23C, W2
0075F0  508F82     SUB W1, W2, [W15]
0075F2  360008     BRA LEU, 0x7604
107:               		{
108:               			register U8 procPowRed = (U8)((adc - 562) / 21);
0075F4  B12321     SUB #0x232, W1
0075F6  200152     MOV #0x15, W2
0075F8  090011     REPEAT #0x11
0075FA  D88082     DIV.UW W1, W2
109:               			step		= DcDcReductionSteps[procPowRed];
0075FC  FB8080     ZE W0, W1
0075FE  408081     ADD W1, W1, W1
007600  2B5E00     MOV #0xB5E0, W0
007602  788060     MOV [W0+W1], W0
110:               		}
111:               		else
112:               			step		= DC_LEVEL_3_80;
0075EC  202370     MOV #0x237, W0
113:               		adc = AN_DC_DC;
007604  801851     MOV ADC1BUF5, W1
114:               		if		(adc > step)	{	if (OC1R)				OC1R--;	}			//  567
007606  500F81     SUB W0, W1, [W15]
007608  310004     BRA C, 0x7612
00760A  E20196     CP0 OC1R
00760C  320008     BRA Z, 0x761E
00760E  ED2196     DEC OC1R
007610  370006     BRA 0x761E
115:               		else if	(adc < step)	{	if (OC1R < DC_DUTY_MAX)	OC1R++;	}
007612  500F81     SUB W0, W1, [W15]
007614  360004     BRA LEU, 0x761E
007616  200310     MOV #0x31, W0
007618  E30196     CP OC1R
00761A  3E0001     BRA GTU, 0x761E
00761C  EC2196     INC OC1R
116:               	}
117:               /*	pirms lietot - JATESTE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
118:               	if		(adc < step)
119:               	{
120:               		if (!OC1R)						OC1R++;
121:               		else if (PR2 > DC_PERIOD_MIN)	PR2--;
122:               	}
123:               	else if (adc > step)
124:               	{
125:               		if (PR2 < DC_PERIOD)			PR2++;
126:               		else							OC1R = 0;
127:               	}
128:               */
129:               }
00761E  060000     RETURN
130:               
131:               // 3.59V    535
132:               // 4.01		585
133:               // 4.05		590
134:               // 4.15		605
135:               // 4.20		612
136:               
137:               inline void ADC_BatteryLevel(void)
138:               {
139:               	static	U16 val_sum = 0;
140:               //	static  S16 cnt     = 0;
141:               	register U16 val = AN_BAT;
007620  801811     MOV ADC1BUF1, W1
142:               
143:               	val_sum += (!val_sum)?	(val << 6) : val;
007622  804730     MOV val_sum, W0
007624  E00000     CP0 W0
007626  3A0001     BRA NZ, 0x762A
007628  DD08C6     SL W1, #6, W1
00762A  408080     ADD W1, W0, W1
144:               	val = val_sum >> 6;
00762C  DE0846     LSR W1, #6, W0
145:               	val_sum -= val;
00762E  508080     SUB W1, W0, W1
007630  884731     MOV W1, val_sum
146:               
147:               	Battery = (val < 82)?	0 : ((val - 81) << 3);
007632  EB0080     CLR W1
007634  200512     MOV #0x51, W2
007636  500F82     SUB W0, W2, [W15]
007638  360002     BRA LEU, 0x763E
00763A  B10510     SUB #0x51, W0
00763C  DD00C3     SL W0, #3, W1
00763E  8846A1     MOV W1, Battery
148:               }
007640  060000     RETURN
149:               
150:               /* Power
151:               // 456			22.00										/ 		
152:               // 287			14.04										/ 	 
153:               // 248-251		12.17		12V = 249 (12 * 20 = 240)		/ 	
154:               // 224-227		11.13		23	1.04	45.2				/ 	
155:               // 206-208		10.26		19	870		45.7				/ 	
156:               // 185-187		9.26		21								/ 	
157:               // 166-168		8.34		19								/ 	
158:               // 103			5.32		146	6.94		353				/ 	
159:               // 
160:               // ADD = 16, step 21
161:               // 456	22	461		22.00	457		| 902	_________________ +5 step 21
162:               // 435	21	440		20.84	430	23	| 861
163:               // 414	20	419					21	| 820
164:               // 393	19	398		19.10	393	21	| 779
165:               // 393	18	377		18.14	375	18	| 737
166:               // 372	17	356		16.96	349	22	| 597
167:               // 351	16	335		16.14	333	19	| 656
168:               // 330	15	314		14.97	308	21	| 615
169:               // 309	14	293		14.05	288	20	| 574	____________________ -6 step 20
170:               // 288	13	272					20	| 533
171:               // 267	12	251		12.18	249	19	| 492
172:               // 246	11	230		11.10	226	23	| 451	____________________ -6 step 20
173:               // 225	10	209		10.23	207	19	| 410
174:               // 204	 9	188		9.22	185	22	| 369
175:               // 183	 8	167		8.31	167	18	| 328
176:               // 162	 7	146		7.30	146	21	| 287
177:               // 141	 6	125					22	| 246
178:               // 120	 5	104		5.29	103	21	| 205
179:               // 99	 4	83						| 164
180:               */
181:               inline void ADC_PowerLevel (void)
182:               {
183:               	static	 U16 val_sum = 0, cnt = 0;
184:               //	static	 S16 cnt = 0;
185:               	register U16 val = AN_POW;
007642  801801     MOV ADC1BUF0, W1
186:               
187:               	val_sum += (!val_sum)?	(val << 6) : val;
007644  804720     MOV val_sum, W0
007646  E00000     CP0 W0
007648  3A0001     BRA NZ, 0x764C
00764A  DD08C6     SL W1, #6, W1
00764C  408080     ADD W1, W0, W1
188:               	val = val_sum >> 6;
00764E  DE0846     LSR W1, #6, W0
189:               	val_sum -= val;
007650  508080     SUB W1, W0, W1
007652  884721     MOV W1, val_sum
190:               
191:               	if (Power == val)
007654  E308D2     CP Power
007656  3A0002     BRA NZ, 0x765C
192:               		cnt = 0;
007658  EF28E2     CLR cnt
00765A  370007     BRA 0x766A
193:               	else if (++cnt & 0x1000)
00765C  804711     MOV cnt, W1
00765E  E80081     INC W1, W1
007660  884711     MOV W1, cnt
007662  A3C801     BTST.Z W1, #12
007664  320002     BRA Z, 0x766A
194:               	{
195:               		Power = val;
007666  884690     MOV W0, Power
196:               		cnt = 0;
007668  EF28E2     CLR cnt
197:               	}
198:               /*	if (val < Power)
199:               	{
200:               		if (cnt > 0)
201:               			cnt = 0;
202:               		else if (--cnt < -32000)
203:               		{
204:               			cnt = 0;
205:               			Power = val;
206:               		}
207:               	}
208:               	else if (val > Power)
209:               	{
210:               		if (cnt < 0)
211:               			cnt = 0;
212:               		else if (++cnt > 32000)
213:               		{
214:               			cnt = 0;
215:               			Power = val;
216:               		}
217:               	}
218:               *	
219:               	static U16 val_sum = 0, val_min = 0xFFFF, val_max = 0, cnt = 64, cnt1 = 64;
220:               	register U16 val = AN_POW;
221:               	if (val_min > val)
222:               		val_min = val;
223:               	if (val_max < val)
224:               		val_max = val;
225:               //	val_sum += val;
226:               
227:               	if (!--cnt1)
228:               	{
229:               		val_sum += (val_min + val_max) >> 1;
230:               		val_min = 0xFFFF;
231:               		val_max = 0;
232:               		cnt1 = 64;
233:               		if (!--cnt)
234:               		{
235:               			Power = (val_sum >> 6);
236:               			cnt = 64;
237:               			val_sum = 0;
238:               		}
239:               	}
240:               *
241:               	static U16 val_last = 0xFFFF, val_sum = 0, cnt = 0;
242:               	register U16 val = AN_POW;
243:               	if (val < val_last)
244:               	{
245:               		if (val_sum)
246:               		{
247:               			Power = val_sum / cnt;
248:               			val_sum = 0;
249:               		}
250:               		cnt = 0;
251:               	}
252:               	else
253:               	{
254:               		val_sum += val;
255:               		cnt++;
256:               	}
257:               	val_last = val;
258:               
259:               
260:               *
261:               	static U16 val_1 = 0, val_2 = 0;
262:               	val_1 += (!val_1)?	(AN_POW << 8) : AN_POW;
263:               	val_2 += (!val_2)?	val_1 : (val_1 >> 8);
264:               	Power = val_2 >> 8;
265:               	val_1 -= Power;
266:               	val_2 -= Power;
267:               */
268:               
269:               /*	
270:               	static		U16 adcSum = 0, pow = 0;
271:               	register	U16	val		= AN_POW;				// value from ADC buff
272:               
273:               	if (adcSum)		adcSum += val;					// equalize 64 times (rounding / remove shaking)
274:               	else			adcSum  = val		<< 6;		// x64
275:               	val						= adcSum	>> 6;		// /64
276:               	adcSum -=  (val);								// 
277:               
278:               //	if (pow != (val >> 8))
279:               	{
280:               		pow = (val >> 8);
281:               		Power			= ((val * POWER_MULTIPLIER) + POWER_ADD_VAL);
282:               		val				= ((val * POWER_MULTIPLIER) + POWER_ADD_VAL);
283:               		AdcPower.V		=  val >> POWER_DIVIDE_SHIFT;
284:               		val			   &=  POWER_DIVIDE_REMAINDER;
285:               		val				= (val > POWER_MW_CUT)? (val - POWER_MW_CUT): 0;
286:               		AdcPower.mV		=  val;
287:               		AdcPower.level	= (AdcPower.V * 10) + ((val * 10) >> POWER_DIVIDE_SHIFT);
288:               	}
289:               */
290:               }
00766A  060000     RETURN
291:               
292:               inline void ADC_PowerControll (void)
293:               {
294:               	register POWER_STATE	newState = power_NoPower;
295:               
296:               	if		(AdcPower.level		> 45)	newState = power_External;	// External power	> 4.5V
00766C  200040     MOV #0x4, W0
00766E  B3C2D1     MOV.B #0x2D, W1
007670  208D62     MOV #0x8D6, W2
007672  784112     MOV.B [W2], W2
007674  514F81     SUB.B W2, W1, [W15]
007676  3E0012     BRA GTU, 0x769C
007694  200010     MOV #0x1, W0
007696  50CFED     SUB.B W1, #0xD, [W15]
007698  3E0001     BRA GTU, 0x769C
00769A  EB0000     CLR W0
297:               	else if (AdcBattery.level	> 100)	newState = power_BatteryMiss;	// Battery level	> 100% (>4.2V)		0% = 2.6V, 1% step = 16mV, 
007678  200030     MOV #0x3, W0
00767A  B3C641     MOV.B #0x64, W1
00767C  208DA2     MOV #0x8DA, W2
00767E  784112     MOV.B [W2], W2
007680  514F81     SUB.B W2, W1, [W15]
007682  3E000C     BRA GTU, 0x769C
298:               	else if (AdcBattery.level	> 50)	newState = power_BatteryOk;	// Battery level	> 43% (~3.3V)		0% = 2.6V, 1% step = 16mV, 
007684  200020     MOV #0x2, W0
007686  B3C321     MOV.B #0x32, W1
007688  208DA2     MOV #0x8DA, W2
00768A  784112     MOV.B [W2], W2
00768C  514F81     SUB.B W2, W1, [W15]
00768E  3E0006     BRA GTU, 0x769C
299:               	else if (AdcBattery.level	> 13)	newState = power_BatteryLow;	// Battery level	> 13% (~2.8V)
007690  208DA1     MOV #0x8DA, W1
007692  784091     MOV.B [W1], W1
300:               //	else								newState = power_NoPower;
301:               
302:               	if	(PowerState != newState)				// Power situation changed
00769C  E308D0     CP PowerState
00769E  320001     BRA Z, 0x76A2
303:               	{
304:               		PowerState = newState;
0076A0  884680     MOV W0, PowerState
305:               		switch (newState)
306:               		{
307:               		case power_External:
308:               		case power_BatteryMiss:
309:               		case power_BatteryOk:
310:               //			if ((!GsmTimerEnabled) && (FLASH_FLAG_GSM))		Gsm_On();
311:               //			if (!GPS_POWER)									Gps_On();
312:               			break;
313:               		case power_BatteryLow:
314:               		case power_NoPower:
315:               		default:
316:               //			Gsm_Off();
317:               //			GPS_POW_OFF();
318:               			break;								// TODO: Switch off device
319:               		}
320:               	}
321:               }
0076A2  060000     RETURN
322:               
323:               inline	void ADC_Test			(void)
324:               {
325:               	static	U16	pow = 0, bat = 0;
326:               	if ((!FL_WIFI_OFFLINE)					&&
0076C4  ABE92C     BTST SysFlags, #7
0076C6  3A000D     BRA NZ, 0x76E2
0076C8  AB692D     BTST 0x92D, #3
0076CA  3A000B     BRA NZ, 0x76E2
327:               		(!FL_POWER_CHANGES)					&&
0076CC  804700     MOV pow, W0
0076CE  E308D2     CP Power
0076D0  3A0003     BRA NZ, 0x76D8
328:               		((pow	!= Power) ||
0076D2  8046F0     MOV bat, W0
0076D4  E308D4     CP Battery
0076D6  320005     BRA Z, 0x76E2
329:               		 (bat	!= Battery))	)
330:               	{
331:               		pow	= Power;
0076D8  F808D2     PUSH Power
0076DA  F908E0     POP pow
332:               		bat	= Battery;
0076DC  F808D4     PUSH Battery
0076DE  F908DE     POP bat
333:               		FL_POWER_CHANGES = 1;
0076E0  A8692D     BSET 0x92D, #3
334:               	}
335:               }
0076E2  060000     RETURN
336:               
337:               void	Tcp_AdcPacket	(void)
338:               {
0076E4  FA0080     LNK #0x80
339:               	char str[128];
340:               
341:               //	register U16 val = Battery >> 3;
342:               //	AdcBattery.V		= val >> POWER_DIVIDE_SHIFT;
343:               //	AdcBattery.mV		= val & POWER_DIVIDE_REMAINDER;
344:               //	if (AdcBattery.mV > 999)	AdcBattery.mV = 999;
345:               //	AdcBattery.level	= BATTERY_PERCENTS((AdcBattery.V * 1000) + AdcBattery.mV);
346:               
347:               //	sprintf(str, "Bat: %d.%02dV (%d), Pow: %d.%02dV (%d)", AdcBattery.V, AdcBattery.mV, Battey, AdcPower.V, AdcPower.mV, Power);
348:               //	sprintf(str, "Bat: %u.%03u (%u%%), Pow: %d", AdcBattery.V, AdcBattery.mV, AdcBattery.level, Power);
349:               	sprintf(str, "Bat: %d, Pow: %d", Battery, Power);
0076E6  804691     MOV Power, W1
0076E8  8046A0     MOV Battery, W0
0076EA  781F81     MOV W1, [W15++]
0076EC  781F80     MOV W0, [W15++]
0076EE  2B5CE0     MOV #0xB5CE, W0
0076F0  781F80     MOV W0, [W15++]
0076F2  2FF7A0     MOV #0xFF7A, W0
0076F4  40000F     ADD W0, W15, W0
0076F6  07CE5A     RCALL __sprintf_cdnopuxX, __sprintf_s, __sprintf_0, __sprintf_cdnopsuxX
350:               	Tcp_SendText(str);
0076F8  2FF7A0     MOV #0xFF7A, W0
0076FA  40000F     ADD W0, W15, W0
0076FC  07F3A6     RCALL Tcp_SendText
351:               	FL_POWER_CHANGES = 0;
0076FE  A9692D     BCLR 0x92D, #3
007700  5787E6     SUB W15, #0x6, W15
352:               }
007702  FA8000     ULNK
007704  060000     RETURN
---  /home/pele/src/Auto_02/Usb/system.c  ---------------------------------------------------------------
1:                 #include	"Timers.h"
2:                 #include	"system.h"
3:                 #include	"usb_device.h"
4:                 #include	"app_device_custom_hid.h"
5:                 
6:                 void SYSTEM_Initialize( SYSTEM_STATE state )
7:                 {
8:                 }
0079D2  060000     RETURN
9:                 
10:                void Usb_Init (void)
11:                {
12:                	USBDeviceInit();
0079D4  07E671     RCALL USBDeviceInit
13:                	USBDeviceAttach();
0079D6  07E753     RCALL USBDeviceAttach
14:                }
0079D8  060000     RETURN
15:                
16:                void Usb_RegularFunctions (void)
17:                {
18:                	#if defined(USB_POLLING)
19:                		USBDeviceTasks();
20:                	#endif
21:                	if(( USBGetDeviceState()	>= CONFIGURED_STATE )	&&
0079DA  8042B0     MOV USBDeviceState, W0
0079DC  500FFF     SUB W0, #0x1F, [W15]
0079DE  360003     BRA LEU, 0x79E6
0079E0  AB2488     BTST U1PWRC, #1
0079E2  3A0001     BRA NZ, 0x79E6
22:                	   ( USBIsDeviceSuspended()	== false )					)
23:                	    APP_DeviceCustomHIDTasks();
0079E4  07E989     RCALL APP_DeviceCustomHIDTasks
24:                }
0079E6  060000     RETURN
25:                
26:                #if defined(USB_INTERRUPT)
27:                void __attribute__((interrupt,auto_psv)) _USB1Interrupt()
28:                {
0079E8  F80036     PUSH RCOUNT
0079EA  BE9F80     MOV.D W0, [W15++]
0079EC  BE9F82     MOV.D W2, [W15++]
0079EE  BE9F84     MOV.D W4, [W15++]
0079F0  BE9F86     MOV.D W6, [W15++]
0079F2  F80032     PUSH DSRPAG
0079F4  F80034     PUSH DSWPAG
0079F6  200010     MOV #0x1, W0
0079F8  8801A0     MOV W0, DSWPAG
0079FA  202000     MOV #0x200, W0
0079FC  880190     MOV W0, DSRPAG
29:                    USBDeviceTasks();
0079FE  07E8D4     RCALL USBDeviceTasks
30:                }
007A00  F90034     POP DSWPAG
007A02  F90032     POP DSRPAG
007A04  BE034F     MOV.D [--W15], W6
007A06  BE024F     MOV.D [--W15], W4
007A08  BE014F     MOV.D [--W15], W2
007A0A  BE004F     MOV.D [--W15], W0
007A0C  F90036     POP RCOUNT
007A0E  064000     RETFIE
31:                #endif
32:                
33:                void APP_LEDUpdateUSBStatus(void)
34:                {
35:                //	if(USBIsDeviceSuspended() == true)
36:                //	{
37:                //		LED_USB = LED_STATUS_1_I;
38:                //		return;
39:                //	}
40:                	switch(USBGetDeviceState())
007A10  8042B0     MOV USBDeviceState, W0
007A12  E00000     CP0 W0
007A14  320004     BRA Z, 0x7A1E
007A16  200201     MOV #0x20, W1
007A18  500F81     SUB W0, W1, [W15]
007A1A  3A0005     BRA NZ, 0x7A26
007A1C  370002     BRA 0x7A22
41:                	{
42:                	case DETACHED_STATE:		LED_USB = LED_STATUS_OFF;			break;
007A1E  EF2898     CLR LedStatus3
007A20  370004     BRA 0x7A2A
43:                	case CONFIGURED_STATE:		LED_USB = LED_STATUS_ON;			break;
007A22  EFA898     SETM LedStatus3
007A24  370002     BRA 0x7A2A
44:                	default:					LED_USB = LED_STATUS_ERROR;			break;
007A26  2AAAA0     MOV #0xAAAA, W0
007A28  8844C0     MOV W0, LedStatus3
45:                	}
46:                }
007A2A  060000     RETURN
47:                
48:                bool USER_USB_CALLBACK_EVENT_HANDLER(int event, void *pdata, uint16_t size)
49:                {
50:                	switch( event )
007A2C  200731     MOV #0x73, W1
007A2E  500F81     SUB W0, W1, [W15]
007A30  32000D     BRA Z, 0x7A4C
007A32  3C0005     BRA GT, 0x7A3E
007A34  500FE1     SUB W0, #0x1, [W15]
007A36  320010     BRA Z, 0x7A58
007A38  500FE3     SUB W0, #0x3, [W15]
007A3A  3A0011     BRA NZ, 0x7A5E
007A3C  37000F     BRA 0x7A5C
007A3E  200741     MOV #0x74, W1
007A40  500F81     SUB W0, W1, [W15]
007A42  320008     BRA Z, 0x7A54
007A44  E80081     INC W1, W1
007A46  500F81     SUB W0, W1, [W15]
007A48  3A000A     BRA NZ, 0x7A5E
007A4A  370002     BRA 0x7A50
51:                	{
52:                		case EVENT_TRANSFER:
53:                			break;
54:                
55:                		case EVENT_SOF:            // We are using the SOF as a timer to time the LED indicator.  Call the LED update function here.
56:                			APP_LEDUpdateUSBStatus();
007A4C  07FFE1     RCALL APP_LEDUpdateUSBStatus
57:                			break;
007A4E  370007     BRA 0x7A5E
58:                
59:                		case EVENT_SUSPEND:			// Update the LED status for the suspend event.
60:                			LED_USB = LED_STATUS_OFF;	//LED_STATUS_1;
007A50  EF2898     CLR LedStatus3
61:                			break;
007A52  370005     BRA 0x7A5E
62:                
63:                		case EVENT_RESUME:			// Update the LED status for the resume event.
64:                			APP_LEDUpdateUSBStatus();
007A54  07FFDD     RCALL APP_LEDUpdateUSBStatus
65:                			break;
007A56  370003     BRA 0x7A5E
66:                
67:                		case EVENT_CONFIGURED:		// When the device is configured, we can (re)initialize the demo code.
68:                			APP_DeviceCustomHIDInitialize();
007A58  07E937     RCALL APP_DeviceCustomHIDInitialize
69:                			break;
007A5A  370001     BRA 0x7A5E
70:                
71:                		case EVENT_SET_DESCRIPTOR:
72:                			break;
73:                
74:                		case EVENT_EP0_REQUEST:		// We have received a non-standard USB request.  The HID driver needs to check to see if the request was for it.
75:                			USBCheckHIDRequest();
007A5C  07FF60     RCALL USBCheckHIDRequest
76:                			break;
77:                
78:                		case EVENT_BUS_ERROR:
79:                			break;
80:                
81:                		case EVENT_TRANSFER_TERMINATED:
82:                			break;
83:                
84:                		default:
85:                			break;
86:                	}
87:                	return true;
88:                }
007A5E  B3C010     MOV.B #0x1, W0
007A60  060000     RETURN
89:                
---  /home/pele/src/Auto_02/Usb/src/usb_device_hid.c  ---------------------------------------------------
1:                 // DOM-IGNORE-BEGIN
2:                 /*******************************************************************************
3:                 Copyright 2015 Microchip Technology Inc. (www.microchip.com)
4:                 
5:                 Licensed under the Apache License, Version 2.0 (the "License");
6:                 you may not use this file except in compliance with the License.
7:                 You may obtain a copy of the License at
8:                 
9:                     http://www.apache.org/licenses/LICENSE-2.0
10:                
11:                Unless required by applicable law or agreed to in writing, software
12:                distributed under the License is distributed on an "AS IS" BASIS,
13:                WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
14:                See the License for the specific language governing permissions and
15:                limitations under the License.
16:                
17:                To request to license the code under the MLA license (www.microchip.com/mla_license), 
18:                please contact mla_licensing@microchip.com
19:                *******************************************************************************/
20:                //DOM-IGNORE-END
21:                
22:                /*******************************************************************************
23:                  USB Device Human Interface Device (HID) Layer
24:                
25:                  Company:
26:                    Microchip Technology Inc.
27:                
28:                  File Name:
29:                    usb_device_hid.c
30:                
31:                  Summary:
32:                    USB Device Human Interface Device (HID) Layer interface API.
33:                
34:                  Description:
35:                    USB Device Human Interface Device (HID) Layer interface API.
36:                *******************************************************************************/
37:                
38:                
39:                // *****************************************************************************
40:                // *****************************************************************************
41:                // Section: Included Files
42:                // *****************************************************************************
43:                // *****************************************************************************
44:                #include "usb_config.h"
45:                #include "usb.h"
46:                #include "usb_device_hid.h"
47:                
48:                // *****************************************************************************
49:                // *****************************************************************************
50:                // Section: File Scope or Global Constants
51:                // *****************************************************************************
52:                // *****************************************************************************
53:                
54:                // *****************************************************************************
55:                // *****************************************************************************
56:                // Section: File Scope Data Types
57:                // *****************************************************************************
58:                // *****************************************************************************
59:                typedef struct __attribute__((packed))
60:                {
61:                    unsigned :8;
62:                    unsigned :8;
63:                    uint8_t reportId;
64:                    uint8_t duration;
65:                } USB_SETUP_SET_IDLE_RATE;
66:                
67:                typedef struct __attribute__((packed))
68:                {
69:                    unsigned :8;
70:                    unsigned :8;
71:                    uint8_t protocol;
72:                } USB_SETUP_SET_PROTOCOL;
73:                
74:                // *****************************************************************************
75:                // *****************************************************************************
76:                // Section: Variables
77:                // *****************************************************************************
78:                // *****************************************************************************
79:                static uint8_t idle_rate;
80:                static uint8_t active_protocol;   // [0] Boot Protocol [1] Report Protocol
81:                
82:                extern const struct{uint8_t report[HID_RPT01_SIZE];}hid_rpt01;
83:                
84:                // *****************************************************************************
85:                // *****************************************************************************
86:                // Section: Prototypes
87:                // *****************************************************************************
88:                // *****************************************************************************
89:                #if defined USER_GET_REPORT_HANDLER
90:                    void USER_GET_REPORT_HANDLER(void);
91:                #endif
92:                
93:                #if defined USER_SET_REPORT_HANDLER
94:                    extern void USER_SET_REPORT_HANDLER(void);
95:                #endif     
96:                
97:                // *****************************************************************************
98:                // *****************************************************************************
99:                // Section: Macros or Functions
100:               // *****************************************************************************
101:               // *****************************************************************************
102:               
103:               //To implement a set idle rate callback function in the application,
104:               //Make sure "#define USB_DEVICE_HID_IDLE_RATE_CALLBACK(reportID, newIdleRate)    USBHIDCBSetIdleRateHandler(reportID, newIdleRate)"
105:               //is placed in your usb_config.h file, and then in your application .c file,
106:               //add the void USBHIDCBSetIdleRateHandler(reportID, newIdleRate) function
107:               //implementation that saves the new idle rate and report ID info, so that it
108:               //gets used later when sending subsequent HID input report packets to the host.
109:               #ifndef USB_DEVICE_HID_IDLE_RATE_CALLBACK
110:                   #define USB_DEVICE_HID_IDLE_RATE_CALLBACK(reportId, idleRate)
111:               #else
112:                   extern void USB_DEVICE_HID_IDLE_RATE_CALLBACK(uint8_t reportId, uint8_t idleRate);
113:               #endif
114:               
115:               /********************************************************************
116:               	Function:
117:               		void USBCheckHIDRequest(void)
118:               
119:                	Summary:
120:                		This routine handles HID specific request that happen on EP0.
121:                       This function should be called from the USBCBCheckOtherReq() call back
122:                       function whenever implementing a HID device.
123:               
124:                	Description:
125:                		This routine handles HID specific request that happen on EP0.  These
126:                       include, but are not limited to, requests for the HID report
127:                       descriptors.  This function should be called from the
128:                       USBCBCheckOtherReq() call back function whenever using an HID device.
129:               
130:                       Typical Usage:
131:                       <code>
132:                       void USBCBCheckOtherReq(void)
133:                       {
134:                           //Since the stack didn't handle the request I need to check
135:                           //  my class drivers to see if it is for them
136:                           USBCheckHIDRequest();
137:                       }
138:                       </code>
139:               
140:               	PreCondition:
141:               		None
142:               
143:               	Parameters:
144:               		None
145:               
146:               	Return Values:
147:               		None
148:               
149:               	Remarks:
150:               		None
151:                
152:                *******************************************************************/
153:               void USBCheckHIDRequest(void)
154:               {
155:                   if(SetupPkt.Recipient != USB_SETUP_RECIPIENT_INTERFACE_BITFIELD) return;
00791E  237A10     MOV #0x37A1, W0
007920  784010     MOV.B [W0], W0
007922  60407F     AND.B W0, #0x1F, W0
007924  504FE1     SUB.B W0, #0x1, [W15]
007926  3A0054     BRA NZ, 0x79D0
156:                   if(SetupPkt.bIntfID != HID_INTF_ID) return;
007928  237A50     MOV #0x37A5, W0
00792A  E00410     CP0.B [W0]
00792C  3A0051     BRA NZ, 0x79D0
157:                   
158:                   /*
159:                    * There are two standard requests that hid.c may support.
160:                    * 1. GET_DSC(DSC_HID,DSC_RPT,DSC_PHY);
161:                    * 2. SET_DSC(DSC_HID,DSC_RPT,DSC_PHY);
162:                    */
163:                   if(SetupPkt.bRequest == USB_REQUEST_GET_DESCRIPTOR)
00792E  500063     SUB W0, #0x3, W0
007930  B3C061     MOV.B #0x6, W1
007932  10CF90     SUBR.B W1, [W0], [W15]
007934  3A001B     BRA NZ, 0x796C
164:                   {
165:                       switch(SetupPkt.bDescriptorType)
007936  E88000     INC2 W0, W0
007938  784010     MOV.B [W0], W0
00793A  40C0FB     ADD.B W1, #0x1B, W1
00793C  504F81     SUB.B W0, W1, [W15]
00793E  320004     BRA Z, 0x7948
007940  E84081     INC.B W1, W1
007942  504F81     SUB.B W0, W1, [W15]
007944  3A0013     BRA NZ, 0x796C
007946  37000B     BRA 0x795E
166:                       {
167:                           case DSC_HID: //HID Descriptor          
168:                               if(USBActiveConfiguration == 1)
007948  BFC858     MOV.B USBActiveConfiguration, WREG
00794A  504FE1     SUB.B W0, #0x1, [W15]
00794C  3A000F     BRA NZ, 0x796C
169:                               {
170:                                   USBEP0SendROMPtr(
00794E  2B4900     MOV #0xB490, W0
007950  89BC80     MOV W0, inPipes
007952  200090     MOV #0x9, W0
007954  89BCA0     MOV W0, 0x3794
007956  B3CC01     MOV.B #0xC0, W1
007958  237920     MOV #0x3792, W0
00795A  784801     MOV.B W1, [W0]
00795C  370007     BRA 0x796C
171:                                       (const uint8_t*)&configDescriptor1 + 18,		//18 is a magic number.  It is the offset from start of the configuration descriptor to the start of the HID descriptor.
172:                                       sizeof(USB_HID_DSC)+3,
173:                                       USB_EP0_INCLUDE_ZERO);
174:                               }
175:                               break;
176:                           case DSC_RPT:  //Report Descriptor           
177:                               //if(USBActiveConfiguration == 1)
178:                               {
179:                                   USBEP0SendROMPtr(
00795E  2B4F20     MOV #0xB4F2, W0
007960  89BC80     MOV W0, inPipes
007962  2001D0     MOV #0x1D, W0
007964  89BCA0     MOV W0, 0x3794
007966  B3CC01     MOV.B #0xC0, W1
007968  237920     MOV #0x3792, W0
00796A  784801     MOV.B W1, [W0]
180:                                       (const uint8_t*)&hid_rpt01,
181:                                       HID_RPT01_SIZE,     //See usbcfg.h
182:                                       USB_EP0_INCLUDE_ZERO);
183:                               }
184:                               break;
185:                           case DSC_PHY:  //Physical Descriptor
186:               				//Note: The below placeholder code is commented out.  HID Physical Descriptors are optional and are not used
187:               				//in many types of HID applications.  If an application does not have a physical descriptor,
188:               				//then the device should return STALL in response to this request (stack will do this automatically
189:               				//if no-one claims ownership of the control transfer).
190:               				//If an application does implement a physical descriptor, then make sure to declare
191:               				//hid_phy01 (rom structure containing the descriptor data), and hid_phy01 (the size of the descriptors in uint8_ts),
192:               				//and then uncomment the below code.
193:                               //if(USBActiveConfiguration == 1)
194:                               //{
195:                               //    USBEP0SendROMPtr((const uint8_t*)&hid_phy01, sizeof(hid_phy01), USB_EP0_INCLUDE_ZERO);
196:                               //}
197:                               break;
198:                       }//end switch(SetupPkt.bDescriptorType)
199:                   }//end if(SetupPkt.bRequest == GET_DSC)
200:                   
201:                   if(SetupPkt.RequestType != USB_SETUP_TYPE_CLASS_BITFIELD)
00796C  237A10     MOV #0x37A1, W0
00796E  B3C602     MOV.B #0x60, W2
007970  614090     AND.B W2, [W0], W1
007972  B3C200     MOV.B #0x20, W0
007974  50CF80     SUB.B W1, W0, [W15]
007976  3A002C     BRA NZ, 0x79D0
202:                   {
203:                       return;
204:                   }
205:               
206:                   switch(SetupPkt.bRequest)
007978  237A20     MOV #0x37A2, W0
00797A  784010     MOV.B [W0], W0
00797C  504FE3     SUB.B W0, #0x3, [W15]
00797E  320019     BRA Z, 0x79B2
007980  3E0003     BRA GTU, 0x7988
007982  504FE2     SUB.B W0, #0x2, [W15]
007984  3A0025     BRA NZ, 0x79D0
007986  370005     BRA 0x7992
007988  504FEA     SUB.B W0, #0xA, [W15]
00798A  32000B     BRA Z, 0x79A2
00798C  504FEB     SUB.B W0, #0xB, [W15]
00798E  3A0020     BRA NZ, 0x79D0
007990  370018     BRA 0x79C2
207:                   {
208:                       case GET_REPORT:
209:                           #if defined USER_GET_REPORT_HANDLER
210:                               USER_GET_REPORT_HANDLER();
211:                           #endif
212:                           break;
213:                       case SET_REPORT:
214:                           #if defined USER_SET_REPORT_HANDLER
215:                               USER_SET_REPORT_HANDLER();
216:                           #endif       
217:                           break;
218:                       case GET_IDLE:
219:                           USBEP0SendRAMPtr(
007992  209320     MOV #0x932, W0
007994  89BC80     MOV W0, inPipes
007996  200010     MOV #0x1, W0
007998  89BCA0     MOV W0, 0x3794
00799A  B3CC11     MOV.B #0xC1, W1
00799C  237920     MOV #0x3792, W0
00799E  784801     MOV.B W1, [W0]
220:                               (uint8_t*)&idle_rate,
221:                               1,
222:                               USB_EP0_INCLUDE_ZERO);
223:                           break;
0079A0  370017     BRA 0x79D0
224:                       case SET_IDLE:
225:                           USBEP0Transmit(USB_EP0_NO_DATA);
0079A2  B3C801     MOV.B #0x80, W1
0079A4  237920     MOV #0x3792, W0
0079A6  784801     MOV.B W1, [W0]
226:                           idle_rate = SetupPkt.W_Value.byte.HB;
0079A8  237A40     MOV #0x37A4, W0
0079AA  784110     MOV.B [W0], W2
0079AC  209321     MOV #0x932, W1
0079AE  784882     MOV.B W2, [W1]
227:                           USB_DEVICE_HID_IDLE_RATE_CALLBACK(SetupPkt.W_Value.byte.LB, idle_rate);
228:                           break;
0079B0  37000F     BRA 0x79D0
229:                       case GET_PROTOCOL:
230:                           USBEP0SendRAMPtr(
0079B2  209330     MOV #0x933, W0
0079B4  89BC80     MOV W0, inPipes
0079B6  200010     MOV #0x1, W0
0079B8  89BCA0     MOV W0, 0x3794
0079BA  B3C811     MOV.B #0x81, W1
0079BC  237920     MOV #0x3792, W0
0079BE  784801     MOV.B W1, [W0]
231:                               (uint8_t*)&active_protocol,
232:                               1,
233:                               USB_EP0_NO_OPTIONS);
234:                           break;
0079C0  370007     BRA 0x79D0
235:                       case SET_PROTOCOL:
236:                           USBEP0Transmit(USB_EP0_NO_DATA);
0079C2  B3C801     MOV.B #0x80, W1
0079C4  237920     MOV #0x3792, W0
0079C6  784801     MOV.B W1, [W0]
237:                           active_protocol = SetupPkt.W_Value.byte.LB;
0079C8  237A30     MOV #0x37A3, W0
0079CA  784110     MOV.B [W0], W2
0079CC  209331     MOV #0x933, W1
0079CE  784882     MOV.B W2, [W1]
238:                           break;
239:                   }//end switch(SetupPkt.bRequest)
240:               
241:               }//end USBCheckHIDRequest
0079D0  060000     RETURN
242:               
243:               /********************************************************************
244:                   Function:
245:                       USB_HANDLE HIDTxPacket(uint8_t ep, uint8_t* data, uint16_t len)
246:                       
247:                   Summary:
248:                       Sends the specified data out the specified endpoint
249:               
250:                   Description:
251:                       This function sends the specified data out the specified 
252:                       endpoint and returns a handle to the transfer information.
253:               
254:                       Typical Usage:
255:                       <code>
256:                       //make sure that the last transfer isn't busy by checking the handle
257:                       if(!HIDTxHandleBusy(USBInHandle))
258:                       {
259:                           //Send the data contained in the ToSendDataBuffer[] array out on
260:                           //  endpoint HID_EP
261:                           USBInHandle = HIDTxPacket(HID_EP,(uint8_t*)&ToSendDataBuffer[0],sizeof(ToSendDataBuffer));
262:                       }
263:                       </code>
264:                       
265:                   PreCondition:
266:                       None
267:                       
268:                   Parameters:
269:                       uint8_t ep    - the endpoint you want to send the data out of
270:                       uint8_t* data - pointer to the data that you wish to send
271:                       uint16_t len   - the length of the data that you wish to send
272:                       
273:                   Return Values:
274:                       USB_HANDLE - a handle for the transfer.  This information
275:                       should be kept to track the status of the transfer
276:                       
277:                   Remarks:
278:                       None
279:                 
280:                *******************************************************************/
281:                // Implemented as a macro. See usb_function_hid.h
282:               
283:               /********************************************************************
284:                   Function:
285:                       USB_HANDLE HIDRxPacket(uint8_t ep, uint8_t* data, uint16_t len)
286:                       
287:                   Summary:
288:                       Receives the specified data out the specified endpoint
289:                       
290:                   Description:
291:                       Receives the specified data out the specified endpoint.
292:               
293:                       Typical Usage:
294:                       <code>
295:                       //Read 64-uint8_ts from endpoint HID_EP, into the ReceivedDataBuffer array.
296:                       //  Make sure to save the return handle so that we can check it later
297:                       //  to determine when the transfer is complete.
298:                       USBOutHandle = HIDRxPacket(HID_EP,(uint8_t*)&ReceivedDataBuffer,64);
299:                       </code>
300:               
301:                   PreCondition:
302:                       None
303:                       
304:                   Parameters:
305:                       uint8_t ep    - the endpoint you want to receive the data into
306:                       uint8_t* data - pointer to where the data will go when it arrives
307:                       uint16_t len   - the length of the data that you wish to receive
308:                       
309:                   Return Values:
310:                       USB_HANDLE - a handle for the transfer.  This information
311:                       should be kept to track the status of the transfer
312:                       
313:                   Remarks:
314:                       None
315:                 
316:                *******************************************************************/
317:                 // Implemented as a macro. See usb_function_hid.h
318:                 
319:               /*******************************************************************************
320:                End of File
321:               */
---  /home/pele/src/Auto_02/Usb/src/usb_device.c  -------------------------------------------------------
1:                 // DOM-IGNORE-BEGIN
2:                 /*******************************************************************************
3:                 Copyright 2015 Microchip Technology Inc. (www.microchip.com)
4:                 
5:                 Licensed under the Apache License, Version 2.0 (the "License");
6:                 you may not use this file except in compliance with the License.
7:                 You may obtain a copy of the License at
8:                 
9:                     http://www.apache.org/licenses/LICENSE-2.0
10:                
11:                Unless required by applicable law or agreed to in writing, software
12:                distributed under the License is distributed on an "AS IS" BASIS,
13:                WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
14:                See the License for the specific language governing permissions and
15:                limitations under the License.
16:                
17:                To request to license the code under the MLA license (www.microchip.com/mla_license), 
18:                please contact mla_licensing@microchip.com
19:                *******************************************************************************/
20:                //DOM-IGNORE-END
21:                
22:                /*******************************************************************************
23:                  USB Device Layer
24:                
25:                  Company:
26:                    Microchip Technology Inc.
27:                
28:                  File Name:
29:                    usb_device.c
30:                
31:                  Summary:
32:                   Provides basic USB device functionality, including enumeration and USB
33:                   chapter 9 required behavior.
34:                
35:                  Description:
36:                   Provides basic USB device functionality, including enumeration and USB
37:                   chapter 9 required behavior.
38:                *******************************************************************************/
39:                
40:                // *****************************************************************************
41:                // *****************************************************************************
42:                // Section: Included Files
43:                // *****************************************************************************
44:                // *****************************************************************************
45:                #include <xc.h>
46:                
47:                #include <stdint.h>
48:                #include <stddef.h>
49:                #include <string.h>
50:                
51:                #include "usb_config.h"
52:                
53:                #include "usb.h"
54:                #include "usb_ch9.h"
55:                #include "usb_device.h"
56:                #include "usb_device_local.h"
57:                
58:                #ifndef uintptr_t
59:                    #if  defined(__XC8__) || defined(__XC16__)
60:                        #define uintptr_t uint16_t
61:                    #elif defined (__XC32__)
62:                        #define uintptr_t uint32_t
63:                    #endif
64:                #endif
65:                
66:                #if defined(USB_USE_MSD)
67:                    #include "usb_device_msd.h"
68:                #endif
69:                
70:                // *****************************************************************************
71:                // *****************************************************************************
72:                // Section: File Scope or Global Constants
73:                // *****************************************************************************
74:                // *****************************************************************************
75:                #if !defined(USE_USB_BUS_SENSE_IO)
76:                    //Assume the +5V VBUS is always present (like it would be in a bus powered
77:                    //only application), unless USE_USB_BUS_SENSE_IO and USB_BUS_SENSE have
78:                    //been properly defined elsewhere in the project.
79:                    #undef USB_BUS_SENSE
80:                    #define USB_BUS_SENSE 1
81:                #endif
82:                
83:                #if defined(USB_DEVICE_DISABLE_DTS_CHECKING)
84:                    #define _DTS_CHECKING_ENABLED 0
85:                #else
86:                    #define _DTS_CHECKING_ENABLED _DTSEN
87:                #endif
88:                
89:                #if !defined(self_power)
90:                    //Assume the application is always bus powered, unless self_power has been
91:                    //defined elsewhere in the project
92:                    #define self_power 0    //0 = bus powered
93:                #endif
94:                
95:                #if !defined(USB_MAX_NUM_CONFIG_DSC)
96:                    //Assume the application only implements one configuration descriptor,
97:                    //unless otherwise specified elsewhere in the project
98:                    #define USB_MAX_NUM_CONFIG_DSC      1
99:                #endif
100:               
101:               #if defined(__XC8)
102:                   //Suppress expected/harmless compiler warning message about unused RAM variables
103:                   //and certain function pointer usage.
104:                   //Certain variables and function pointers are not used if you don't use all
105:                   //of the USB stack APIs.  However, these variables should not be
106:                   //removed (since they are still used/needed in some applications, and this
107:                   //is a common file shared by many projects, some of which rely on the "unused"
108:                   //variables/function pointers).
109:                   #pragma warning disable 1090
110:                   #if __XC8_VERSION > 1300
111:                       #pragma warning disable 1471
112:                   #endif
113:               #endif
114:               
115:               // *****************************************************************************
116:               // *****************************************************************************
117:               // Section: File Scope Data Types
118:               // *****************************************************************************
119:               // *****************************************************************************
120:               typedef union
121:               {
122:                   uint8_t Val;
123:                   struct __PACKED
124:                   {
125:                       unsigned b0:1;
126:                       unsigned b1:1;
127:                       unsigned b2:1;
128:                       unsigned b3:1;
129:                       unsigned b4:1;
130:                       unsigned b5:1;
131:                       unsigned b6:1;
132:                       unsigned b7:1;
133:                   } bits;
134:               } uint8_t_VAL, uint8_t_BITS;
135:               
136:               // *****************************************************************************
137:               // *****************************************************************************
138:               // Section: Variables
139:               // *****************************************************************************
140:               // *****************************************************************************
141:               USB_VOLATILE USB_DEVICE_STATE USBDeviceState;
142:               USB_VOLATILE uint8_t USBActiveConfiguration;
143:               USB_VOLATILE uint8_t USBAlternateInterface[USB_MAX_NUM_INT];
144:               volatile BDT_ENTRY *pBDTEntryEP0OutCurrent;
145:               volatile BDT_ENTRY *pBDTEntryEP0OutNext;
146:               volatile BDT_ENTRY *pBDTEntryOut[USB_MAX_EP_NUMBER+1];
147:               volatile BDT_ENTRY *pBDTEntryIn[USB_MAX_EP_NUMBER+1];
148:               USB_VOLATILE uint8_t shortPacketStatus;
149:               USB_VOLATILE uint8_t controlTransferState;
150:               USB_VOLATILE IN_PIPE inPipes[1];
151:               USB_VOLATILE OUT_PIPE outPipes[1];
152:               USB_VOLATILE uint8_t *pDst;
153:               USB_VOLATILE bool RemoteWakeup;
154:               USB_VOLATILE bool USBBusIsSuspended;
155:               USB_VOLATILE USTAT_FIELDS USTATcopy;
156:               USB_VOLATILE uint8_t endpoint_number;
157:               USB_VOLATILE bool BothEP0OutUOWNsSet;
158:               USB_VOLATILE EP_STATUS ep_data_in[USB_MAX_EP_NUMBER+1];
159:               USB_VOLATILE EP_STATUS ep_data_out[USB_MAX_EP_NUMBER+1];
160:               USB_VOLATILE uint8_t USBStatusStageTimeoutCounter;
161:               volatile bool USBDeferStatusStagePacket;
162:               volatile bool USBStatusStageEnabledFlag1;
163:               volatile bool USBStatusStageEnabledFlag2;
164:               volatile bool USBDeferINDataStagePackets;
165:               volatile bool USBDeferOUTDataStagePackets;
166:               USB_VOLATILE uint32_t USB1msTickCount;
167:               USB_VOLATILE uint8_t USBTicksSinceSuspendEnd;
168:               
169:               /** USB FIXED LOCATION VARIABLES ***********************************/
170:               #if defined(COMPILER_MPLAB_C18)
171:                   #pragma udata USB_BDT=USB_BDT_ADDRESS
172:               #endif
173:               
174:               volatile BDT_ENTRY BDT[BDT_NUM_ENTRIES] BDT_BASE_ADDR_TAG;
175:               
176:               /********************************************************************
177:                * EP0 Buffer Space
178:                *******************************************************************/
179:               volatile CTRL_TRF_SETUP SetupPkt CTRL_TRF_SETUP_ADDR_TAG;
180:               volatile uint8_t CtrlTrfData[USB_EP0_BUFF_SIZE] CTRL_TRF_DATA_ADDR_TAG;
181:               
182:               /********************************************************************
183:                * non-EP0 Buffer Space
184:                *******************************************************************/
185:               #if defined(USB_USE_MSD)
186:                   //Check if the MSD application specific USB endpoint buffer placement address 
187:                   //macros have already been defined or not (ex: in a processor specific header)
188:                   //The msd_cbw and msd_csw buffers must be USB module accessible (and therefore
189:                   //must be at a certain address range on certain microcontrollers).
190:                   #if !defined(MSD_CBW_ADDR_TAG)
191:                       //Not previously defined.  Assume in this case all microcontroller RAM is
192:                       //USB module accessible, and therefore, no specific address tag value is needed.
193:                       #define MSD_CBW_ADDR_TAG
194:                       #define MSD_CSW_ADDR_TAG
195:                   #endif
196:               	volatile USB_MSD_CBW msd_cbw MSD_CBW_ADDR_TAG;  //Must be located in USB module accessible RAM
197:               	volatile USB_MSD_CSW msd_csw MSD_CSW_ADDR_TAG;  //Must be located in USB module accessible RAM
198:               
199:                   #if defined(__18CXX) || defined(__XC8)
200:                       volatile char msd_buffer[512] @ MSD_BUFFER_ADDRESS;
201:                   #else
202:                       volatile char msd_buffer[512];
203:               	#endif
204:               #endif
205:               
206:               //Depricated in v2.2 - will be removed in a future revision
207:               #if !defined(USB_USER_DEVICE_DESCRIPTOR)
208:                   //Device descriptor
209:                   extern const USB_DEVICE_DESCRIPTOR device_dsc;
210:               #else
211:                   USB_USER_DEVICE_DESCRIPTOR_INCLUDE;
212:               #endif
213:               
214:               #if !defined(USB_USER_CONFIG_DESCRIPTOR)
215:                   //Array of configuration descriptors
216:                   extern const uint8_t *const USB_CD_Ptr[];
217:               #else
218:                   USB_USER_CONFIG_DESCRIPTOR_INCLUDE;
219:               #endif
220:               
221:               extern const uint8_t *const USB_SD_Ptr[];
222:               
223:               
224:               // *****************************************************************************
225:               // *****************************************************************************
226:               // Section: Private and External Prototypes
227:               // *****************************************************************************
228:               // *****************************************************************************
229:               extern bool USER_USB_CALLBACK_EVENT_HANDLER(USB_EVENT event, void *pdata, uint16_t size);
230:               
231:               static void USBCtrlEPService(void);
232:               static void USBCtrlTrfSetupHandler(void);
233:               static void USBCtrlTrfInHandler(void);
234:               static void USBCheckStdRequest(void);
235:               static void USBStdGetDscHandler(void);
236:               static void USBCtrlEPServiceComplete(void);
237:               static void USBCtrlTrfTxService(void);
238:               static void USBCtrlTrfRxService(void);
239:               static void USBStdSetCfgHandler(void);
240:               static void USBStdGetStatusHandler(void);
241:               static void USBStdFeatureReqHandler(void);
242:               static void USBCtrlTrfOutHandler(void);
243:               static void USBConfigureEndpoint(uint8_t EPNum, uint8_t direction);
244:               static void USBWakeFromSuspend(void);
245:               static void USBSuspend(void);
246:               static void USBStallHandler(void);
247:               
248:               // *****************************************************************************
249:               // *****************************************************************************
250:               // Section: Macros or Functions
251:               // *****************************************************************************
252:               // *****************************************************************************
253:               
254:               /**************************************************************************
255:                   Function:
256:                       void USBDeviceInit(void)
257:                   
258:                   Description:
259:                       This function initializes the device stack it in the default state. The
260:                       USB module will be completely reset including all of the internal
261:                       variables, registers, and interrupt flags.
262:                               
263:                   Precondition:
264:                       This function must be called before any of the other USB Device
265:                       functions can be called, including USBDeviceTasks().
266:                       
267:                   Parameters:
268:                       None
269:                    
270:                   Return Values:
271:                       None
272:                       
273:                   Remarks:
274:                       None
275:                                                                         
276:                 ***************************************************************************/
277:               void USBDeviceInit(void)
278:               {
279:                   uint8_t i;
280:               
281:                   USBDisableInterrupts();
0046B8  A9C09E     BCLR IEC5, #6
282:               
283:                   //Make sure that if a GPIO output driver exists on VBUS, that it is 
284:                   //tri-stated to avoid potential contention with the host
285:                   USB_HAL_VBUSTristate();
0046BA  A8E2E8     BSET TRISF, #7
286:                   
287:                   // Clear all USB error flags
288:                   USBClearInterruptRegister(U1EIR);  
0046BC  EB8000     SETM W0
0046BE  882470     MOV W0, U1EIR
289:                      
290:                   // Clears all USB interrupts          
291:                   USBClearInterruptRegister(U1IR); 
0046C0  882450     MOV W0, U1IR
292:               
293:                   //Clear all of the endpoint control registers
294:                   U1EP0 = 0;
0046C2  EF24AA     CLR U1EP0
295:                   
296:                   DisableNonZeroEndpoints(USB_MAX_EP_NUMBER);
0046C4  EF24AC     CLR U1EP1
297:               
298:                   SetConfigurationOptions();
0046C6  200020     MOV #0x2, W0
0046C8  882530     MOV W0, U1CNFG1
0046CA  EF24A8     CLR U1CNFG2
0046CC  A94486     BCLR U1OTGCON, #2
0046CE  2009F0     MOV #0x9F, W0
0046D0  882480     MOV W0, U1EIE
0046D2  882460     MOV W0, U1IE
0046D4  A8C482     BSET U1OTGIE, #6
299:               
300:                   //power up the module (if not already powered)
301:                   USBPowerModule();
0046D6  A80488     BSET U1PWRC, #0
302:               
303:                   //set the address of the BDT (if applicable)
304:                   USBSetBDTAddress(BDT);
0046D8  238002     MOV #0x3800, W2
0046DA  DE1048     LSR W2, #8, W0
0046DC  8824C0     MOV W0, U1BDTP1
305:               
306:                   //Clear all of the BDT entries
307:                   for(i = 0; i < (sizeof(BDT)/sizeof(BDT_ENTRY)); i++)
308:                   {
309:                       BDT[i].Val = 0x00;
0046DE  B80060     MUL.UU W0, #0, W0
0046E0  BE8900     MOV.D W0, [W2]
0046E2  89C020     MOV W0, 0x3804
0046E4  89C031     MOV W1, 0x3806
0046E6  89C040     MOV W0, 0x3808
0046E8  89C051     MOV W1, 0x380A
0046EA  89C060     MOV W0, 0x380C
0046EC  89C071     MOV W1, 0x380E
0046EE  89C080     MOV W0, 0x3810
0046F0  89C091     MOV W1, 0x3812
0046F2  89C0A0     MOV W0, 0x3814
0046F4  89C0B1     MOV W1, 0x3816
0046F6  89C0C0     MOV W0, 0x3818
0046F8  89C0D1     MOV W1, 0x381A
0046FA  89C0E0     MOV W0, 0x381C
0046FC  89C0F1     MOV W1, 0x381E
310:                   }
311:               
312:                   // Assert reset request to all of the Ping Pong buffer pointers
313:                   USBPingPongBufferReset = 1;                    
0046FE  A82494     BSET U1CON, #1
314:               
315:                   // Reset to default address
316:                   U1ADDR = 0x00;                   
004700  EF2496     CLR U1ADDR
317:               
318:                   // Make sure packet processing is enabled
319:                   USBPacketDisable = 0;           
004702  A9A494     BCLR U1CON, #5
320:               
321:                   //Stop trying to reset ping pong buffer pointers
322:                   USBPingPongBufferReset = 0;
004704  A92494     BCLR U1CON, #1
323:               
324:                   // Flush any pending transactions
325:                   do
326:                   {
327:                       USBClearInterruptFlag(USBTransactionCompleteIFReg,USBTransactionCompleteIFBitNum);
004706  200085     MOV #0x8, W5
004712  882455     MOV W5, U1IR
328:                       //Initialize USB stack software state variables
329:                       inPipes[0].info.Val = 0;
004708  237924     MOV #0x3792, W4
00470A  EB4000     CLR.B W0
004714  784A00     MOV.B W0, [W4]
330:                       outPipes[0].info.Val = 0;
00470C  237983     MOV #0x3798, W3
004716  784980     MOV.B W0, [W3]
331:                       outPipes[0].wCount.Val = 0;
00470E  E80103     INC W3, W2
004710  E80082     INC W2, W1
004718  784312     MOV.B [W2], W6
00471A  784900     MOV.B W0, [W2]
00471C  784311     MOV.B [W1], W6
00471E  784880     MOV.B W0, [W1]
332:                   }while(USBTransactionCompleteIF == 1);
004720  AB648A     BTST U1IR, #3
004722  3AFFF7     BRA NZ, 0x4712
333:               
334:                   //Set flags to true, so the USBCtrlEPAllowStatusStage() function knows not to
335:                   //try and arm a status stage, even before the first control transfer starts.
336:                   USBStatusStageEnabledFlag1 = true;
004724  B3C010     MOV.B #0x1, W0
004726  B7E870     MOV.B WREG, USBStatusStageEnabledFlag1
004728  B7E871     MOV.B WREG, USBStatusStageEnabledFlag2
337:                   USBStatusStageEnabledFlag2 = true;
338:                   //Initialize other flags
339:                   USBDeferINDataStagePackets = false;
00472A  EF6852     CLR.B USBDeferINDataStagePackets
340:                   USBDeferOUTDataStagePackets = false;
00472C  EF6850     CLR.B USBDeferOUTDataStagePackets
341:                   USBBusIsSuspended = false;
00472E  EF6854     CLR.B USBBusIsSuspended
342:               
343:                   //Initialize all pBDTEntryIn[] and pBDTEntryOut[]
344:                   //pointers to NULL, so they don't get used inadvertently.
345:                   for(i = 0; i < (uint8_t)(USB_MAX_EP_NUMBER+1u); i++)
346:                   {
347:                       pBDTEntryIn[i] = 0u;
00473C  EF2860     CLR 0x860
348:                       pBDTEntryOut[i] = 0u;
004730  EF285A     CLR pBDTEntryOut
00473E  EF285C     CLR 0x85C
349:                       ep_data_in[i].Val = 0u;
004732  EB4000     CLR.B W0
004734  2379D1     MOV #0x379D, W1
004736  784880     MOV.B W0, [W1]
004740  2379E1     MOV #0x379E, W1
004742  784880     MOV.B W0, [W1]
350:                       ep_data_out[i].Val = 0u;
004738  2379F1     MOV #0x379F, W1
00473A  784880     MOV.B W0, [W1]
004744  237A01     MOV #0x37A0, W1
004746  784880     MOV.B W0, [W1]
351:                   }
352:               
353:                   //Get ready for the first packet
354:                   pBDTEntryIn[0] = (volatile BDT_ENTRY*)&BDT[EP0_IN_EVEN];
004748  238080     MOV #0x3808, W0
00474A  8842F0     MOV W0, pBDTEntryIn
355:                   // Initialize EP0 as a Ctrl EP
356:                   U1EP0 = EP_CTRL|USB_HANDSHAKE_ENABLED;        
00474C  2000D0     MOV #0xD, W0
00474E  882550     MOV W0, U1EP0
357:               	//Prepare for the first SETUP on EP0 OUT
358:                   BDT[EP0_OUT_EVEN].ADR = ConvertToPhysicalAddress(&SetupPkt);
004750  237A10     MOV #0x37A1, W0
004752  89C010     MOV W0, 0x3802
359:                   BDT[EP0_OUT_EVEN].CNT = USB_EP0_BUFF_SIZE;
004754  B3C401     MOV.B #0x40, W1
004756  238000     MOV #0x3800, W0
004758  784801     MOV.B W1, [W0]
360:                   BDT[EP0_OUT_EVEN].STAT.Val = _DAT0|_BSTALL;
00475A  E80000     INC W0, W0
00475C  B3C041     MOV.B #0x4, W1
00475E  784801     MOV.B W1, [W0]
361:                   BDT[EP0_OUT_EVEN].STAT.Val |= _USIE;
004760  A07410     BSET.B [W0], #7
362:               
363:                   // Clear active configuration
364:                   USBActiveConfiguration = 0;     
004762  EF6858     CLR.B USBActiveConfiguration
365:               
366:                   USB1msTickCount = 0;            //Keeps track of total number of milliseconds since calling USBDeviceInit() when first initializing the USB module/stack code.
004764  EF2872     CLR USB1msTickCount
004766  EF2874     CLR 0x874
367:                   USBTicksSinceSuspendEnd = 0;    //Keeps track of the number of milliseconds since a suspend condition has ended.
004768  EF6859     CLR.B USBTicksSinceSuspendEnd
368:               
369:                   //Indicate that we are now in the detached state
370:                   USBDeviceState = DETACHED_STATE;
00476A  EF2856     CLR USBDeviceState
371:               }
00476C  060000     RETURN
372:               
373:               
374:               
375:               /**************************************************************************
376:                 Function:
377:                       void USBDeviceTasks(void)
378:                   
379:                 Summary:
380:                   This function is the main state machine/transaction handler of the USB 
381:                   device side stack.  When the USB stack is operated in "USB_POLLING" mode 
382:                   (usb_config.h user option) the USBDeviceTasks() function should be called 
383:                   periodically to receive and transmit packets through the stack. This 
384:                   function also takes care of control transfers associated with the USB 
385:                   enumeration process, and detecting various USB events (such as suspend).  
386:                   This function should be called at least once every 1.8ms during the USB 
387:                   enumeration process. After the enumeration process is complete (which can 
388:                   be determined when USBGetDeviceState() returns CONFIGURED_STATE), the 
389:                   USBDeviceTasks() handler may be called the faster of: either once 
390:                   every 9.8ms, or as often as needed to make sure that the hardware USTAT 
391:                   FIFO never gets full.  A good rule of thumb is to call USBDeviceTasks() at
392:                   a minimum rate of either the frequency that USBTransferOnePacket() gets 
393:                   called, or, once/1.8ms, whichever is faster.  See the inline code comments 
394:                   near the top of usb_device.c for more details about minimum timing 
395:                   requirements when calling USBDeviceTasks().
396:                   
397:                   When the USB stack is operated in "USB_INTERRUPT" mode, it is not necessary
398:                   to call USBDeviceTasks() from the main loop context.  In the USB_INTERRUPT
399:                   mode, the USBDeviceTasks() handler only needs to execute when a USB 
400:                   interrupt occurs, and therefore only needs to be called from the interrupt 
401:                   context.
402:               
403:                 Description:
404:                   This function is the main state machine/transaction handler of the USB 
405:                   device side stack.  When the USB stack is operated in "USB_POLLING" mode 
406:                   (usb_config.h user option) the USBDeviceTasks() function should be called 
407:                   periodically to receive and transmit packets through the stack. This 
408:                   function also takes care of control transfers associated with the USB 
409:                   enumeration process, and detecting various USB events (such as suspend).  
410:                   This function should be called at least once every 1.8ms during the USB 
411:                   enumeration process. After the enumeration process is complete (which can 
412:                   be determined when USBGetDeviceState() returns CONFIGURED_STATE), the 
413:                   USBDeviceTasks() handler may be called the faster of: either once 
414:                   every 9.8ms, or as often as needed to make sure that the hardware USTAT 
415:                   FIFO never gets full.  A good rule of thumb is to call USBDeviceTasks() at
416:                   a minimum rate of either the frequency that USBTransferOnePacket() gets 
417:                   called, or, once/1.8ms, whichever is faster.  See the inline code comments 
418:                   near the top of usb_device.c for more details about minimum timing 
419:                   requirements when calling USBDeviceTasks().
420:                   
421:                   When the USB stack is operated in "USB_INTERRUPT" mode, it is not necessary
422:                   to call USBDeviceTasks() from the main loop context.  In the USB_INTERRUPT
423:                   mode, the USBDeviceTasks() handler only needs to execute when a USB 
424:                   interrupt occurs, and therefore only needs to be called from the interrupt 
425:                   context.
426:               
427:                   Typical usage:
428:                   <code>
429:                   void main(void)
430:                   {
431:                       USBDeviceInit();
432:                       while(1)
433:                       {
434:                           USBDeviceTasks(); //Takes care of enumeration and other USB events
435:                           if((USBGetDeviceState() \< CONFIGURED_STATE) ||
436:                              (USBIsDeviceSuspended() == true))
437:                           {
438:                               //Either the device is not configured or we are suspended,
439:                               // so we don't want to execute any USB related application code
440:                               continue;   //go back to the top of the while loop
441:                           }
442:                           else
443:                           {
444:                               //Otherwise we are free to run USB and non-USB related user 
445:                               //application code.
446:                               UserApplication();
447:                           }
448:                       }
449:                   }
450:                   </code>
451:               
452:                 Precondition:
453:                   Make sure the USBDeviceInit() function has been called prior to calling
454:                   USBDeviceTasks() for the first time.
455:                 Remarks:
456:                   USBDeviceTasks() does not need to be called while in the USB suspend mode, 
457:                   if the user application firmware in the USBCBSuspend() callback function
458:                   enables the ACTVIF USB interrupt source and put the microcontroller into 
459:                   sleep mode.  If the application firmware decides not to sleep the 
460:                   microcontroller core during USB suspend (ex: continues running at full 
461:                   frequency, or clock switches to a lower frequency), then the USBDeviceTasks()
462:                   function must still be called periodically, at a rate frequent enough to 
463:                   ensure the 10ms resume recovery interval USB specification is met.  Assuming
464:                   a worst case primary oscillator and PLL start up time of less than 5ms, then
465:                   USBDeviceTasks() should be called once every 5ms in this scenario.
466:                  
467:                   When the USB cable is detached, or the USB host is not actively powering 
468:                   the VBUS line to +5V nominal, the application firmware does not always have 
469:                   to call USBDeviceTasks() frequently, as no USB activity will be taking 
470:                   place.  However, if USBDeviceTasks() is not called regularly, some 
471:                   alternative means of promptly detecting when VBUS is powered (indicating 
472:                   host attachment), or not powered (host powered down or USB cable unplugged)
473:                   is still needed.  For self or dual self/bus powered USB applications, see 
474:                   the USBDeviceAttach() and USBDeviceDetach() API documentation for additional 
475:                   considerations.
476:                   ***************************************************************************/
477:               void USBDeviceTasks(void)
478:               {
004BA8  BE9F88     MOV.D W8, [W15++]
004BAA  781F8A     MOV W10, [W15++]
479:                   uint8_t i;
480:               
481:                   #ifdef USB_SUPPORT_OTG
482:                       //SRP Time Out Check
483:                       if (USBOTGSRPIsReady())
484:                       {
485:                           if (USBT1MSECIF && USBT1MSECIE)
486:                           {
487:                               if (USBOTGGetSRPTimeOutFlag())
488:                               {
489:                                   if (USBOTGIsSRPTimeOutExpired())
490:                                   {
491:                                       USB_OTGEventHandler(0,OTG_EVENT_SRP_FAILED,0,0);
492:                                   }
493:                               }
494:               
495:                               //Clear Interrupt Flag
496:                               USBClearInterruptFlag(USBT1MSECIFReg,USBT1MSECIFBitNum);
497:                           }
498:                       }
499:                   #endif
500:               
501:                   #if defined(USB_POLLING)
502:                   //If the interrupt option is selected then the customer is required
503:                   //  to notify the stack when the device is attached or removed from the
504:                   //  bus by calling the USBDeviceAttach() and USBDeviceDetach() functions.
505:                   if (USB_BUS_SENSE != 1)
506:                   {
507:                        // Disable module & detach from bus
508:                        U1CON = 0;             
509:               
510:                        // Mask all USB interrupts              
511:                        U1IE = 0;          
512:               
513:                        //Move to the detached state                  
514:                        USBDeviceState = DETACHED_STATE;
515:               
516:                        #ifdef  USB_SUPPORT_OTG    
517:                            //Disable D+ Pullup
518:                            U1OTGCONbits.DPPULUP = 0;
519:               
520:                            //Disable HNP
521:                            USBOTGDisableHnp();
522:               
523:                            //Deactivate HNP
524:                            USBOTGDeactivateHnp();
525:                            
526:                            //If ID Pin Changed State
527:                            if (USBIDIF && USBIDIE)
528:                            {  
529:                                //Re-detect & Initialize
530:                                 USBOTGInitialize();
531:               
532:                                 //Clear ID Interrupt Flag
533:                                 USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);
534:                            }
535:                        #endif
536:               
537:                        #if defined __C30__ || defined __XC16__
538:                            //USBClearInterruptFlag(U1OTGIR, 3); 
539:                        #endif
540:                           //return so that we don't go through the rest of 
541:                           //the state machine
542:                        USBClearUSBInterrupt();
543:                        return;
544:                   }
545:               
546:               	#ifdef USB_SUPPORT_OTG
547:                   //If Session Is Started Then
548:                   else
549:               	{
550:                       //If SRP Is Ready
551:                       if (USBOTGSRPIsReady())
552:                       {   
553:                           //Clear SRPReady
554:                           USBOTGClearSRPReady();
555:               
556:                           //Clear SRP Timeout Flag
557:                           USBOTGClearSRPTimeOutFlag();
558:               
559:                           //Indicate Session Started
560:                           UART2PrintString( "\r\n***** USB OTG B Event - Session Started  *****\r\n" );
561:                       }
562:                   }
563:               	#endif	//#ifdef USB_SUPPORT_OTG
564:               
565:                   //if we are in the detached state
566:                   if(USBDeviceState == DETACHED_STATE)
567:                   {
568:               	    //Initialize register to known value
569:                       U1CON = 0;                          
570:               
571:                       // Mask all USB interrupts
572:                       U1IE = 0;                                
573:               
574:                       //Enable/set things like: pull ups, full/low-speed mode, 
575:                       //set the ping pong mode, and set internal transceiver
576:                       SetConfigurationOptions();
577:               
578:                       // Enable module & attach to bus
579:                       while(!U1CONbits.USBEN){U1CONbits.USBEN = 1;}
580:               
581:                       //moved to the attached state
582:                       USBDeviceState = ATTACHED_STATE;
583:               
584:                       #ifdef  USB_SUPPORT_OTG
585:                           U1OTGCON |= USB_OTG_DPLUS_ENABLE | USB_OTG_ENABLE;  
586:                       #endif
587:                   }
588:               	#endif  //#if defined(USB_POLLING)
589:               
590:                   if(USBDeviceState == ATTACHED_STATE)
004BAC  8042B0     MOV USBDeviceState, W0
004BAE  500FE1     SUB W0, #0x1, [W15]
004BB0  3A0007     BRA NZ, 0x4BC0
591:                   {
592:                       /*
593:                        * After enabling the USB module, it takes some time for the
594:                        * voltage on the D+ or D- line to rise high enough to get out
595:                        * of the SE0 condition. The USB Reset interrupt should not be
596:                        * unmasked until the SE0 condition is cleared. This helps
597:                        * prevent the firmware from misinterpreting this unique event
598:                        * as a USB bus reset from the USB host.
599:                        */
600:               
601:                       if(!USBSE0Event)
004BB2  ABC494     BTST U1CON, #6
004BB4  3A0005     BRA NZ, 0x4BC0
602:                       {
603:                           //We recently attached, make sure we are in a clean state
604:                           #if defined(__dsPIC33E__) || defined(_PIC24E__) || defined(__PIC32MM__)
605:                               U1IR = 0xFFEF;  //Preserve IDLEIF info, so we can detect suspend
606:                                               //during attach de-bounce interval
607:                           #else
608:                               USBClearInterruptRegister(U1IR);
004BB6  EFA48A     SETM U1IR
609:                           #endif
610:               
611:                           #if defined(USB_POLLING)
612:                               U1IE=0;                        // Mask all USB interrupts
613:                           #endif
614:                           USBResetIE = 1;             // Unmask RESET interrupt
004BB8  A8048C     BSET U1IE, #0
615:                           USBIdleIE = 1;             // Unmask IDLE interrupt
004BBA  A8848C     BSET U1IE, #4
616:                           USBDeviceState = POWERED_STATE;
004BBC  200020     MOV #0x2, W0
004BBE  8842B0     MOV W0, USBDeviceState
617:                       }
618:                   }
619:               
620:                   #ifdef  USB_SUPPORT_OTG
621:                       //If ID Pin Changed State
622:                       if (USBIDIF && USBIDIE)
623:                       {  
624:                           //Re-detect & Initialize
625:                           USBOTGInitialize();
626:               
627:                           USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);
628:                       }
629:                   #endif
630:               
631:                   /*
632:                    * Task A: Service USB Activity Interrupt
633:                    */
634:                   if(USBActivityIF && USBActivityIE)
004BC0  AB8480     BTST U1OTGIR, #4
004BC2  320005     BRA Z, 0x4BCE
004BC4  AB8482     BTST U1OTGIE, #4
004BC6  320003     BRA Z, 0x4BCE
635:                   {
636:                       USBClearInterruptFlag(USBActivityIFReg,USBActivityIFBitNum);
004BC8  200100     MOV #0x10, W0
004BCA  882400     MOV W0, U1OTGIR
637:                       #if defined(USB_SUPPORT_OTG)
638:                           U1OTGIR = 0x10;        
639:                       #else
640:                           USBWakeFromSuspend();
004BCC  07FC3C     RCALL _USBWakeFromSuspend
641:                       #endif
642:                   }
643:               
644:                   /*
645:                    * Pointless to continue servicing if the device is in suspend mode.
646:                    */
647:                   if(USBSuspendControl==1)
004BCE  AB2488     BTST U1PWRC, #1
004BD0  320002     BRA Z, 0x4BD6
648:                   {
649:                       USBClearUSBInterrupt();
004BD2  A9C08E     BCLR IFS5, #6
650:                       return;
004BD4  37006D     BRA 0x4CB0
651:                   }
652:               
653:                   /*
654:                    * Task B: Service USB Bus Reset Interrupt.
655:                    * When bus reset is received during suspend, ACTVIF will be set first,
656:                    * once the UCONbits.SUSPND is clear, then the URSTIF bit will be asserted.
657:                    * This is why URSTIF is checked after ACTVIF.
658:                    *
659:                    * The USB reset flag is masked when the USB state is in
660:                    * DETACHED_STATE or ATTACHED_STATE, and therefore cannot
661:                    * cause a USB reset event during these two states.
662:                    */
663:                   if(USBResetIF && USBResetIE)
004BD6  AB048A     BTST U1IR, #0
004BD8  320008     BRA Z, 0x4BEA
004BDA  AB048C     BTST U1IE, #0
004BDC  320006     BRA Z, 0x4BEA
664:                   {
665:                       USBDeviceInit();
004BDE  07FD6C     RCALL USBDeviceInit
666:               
667:                       //Re-enable the interrupts since the USBDeviceInit() function will
668:                       //  disable them.  This will do nothing in a polling setup
669:                       USBUnmaskInterrupts();
004BE0  A8C09E     BSET IEC5, #6
670:               
671:                       USBDeviceState = DEFAULT_STATE;
004BE2  200040     MOV #0x4, W0
004BE4  8842B0     MOV W0, USBDeviceState
672:               
673:                       #ifdef USB_SUPPORT_OTG
674:                            //Disable HNP
675:                            USBOTGDisableHnp();
676:               
677:                            //Deactivate HNP
678:                            USBOTGDeactivateHnp();
679:                       #endif
680:               
681:                       USBClearInterruptFlag(USBResetIFReg,USBResetIFBitNum);
004BE6  200010     MOV #0x1, W0
004BE8  882450     MOV W0, U1IR
682:                   }
683:               
684:                   /*
685:                    * Task C: Service other USB interrupts
686:                    */
687:                   if(USBIdleIF && USBIdleIE)
004BEA  AB848A     BTST U1IR, #4
004BEC  320003     BRA Z, 0x4BF4
004BEE  AB848C     BTST U1IE, #4
004BF0  320001     BRA Z, 0x4BF4
688:                   { 
689:                       #ifdef  USB_SUPPORT_OTG 
690:                           //If Suspended, Try to switch to Host
691:                           USBOTGSelectRole(ROLE_HOST);
692:                           USBClearInterruptFlag(USBIdleIFReg,USBIdleIFBitNum);
693:                       #else
694:                           USBSuspend();
004BF2  07FC33     RCALL _USBSuspend
695:                       #endif
696:                   }
697:               
698:                   #if defined(__XC16__) || defined(__C30__) || defined(__XC32__)
699:                       //Check if a 1ms interval has elapsed.	
700:                       if(USBT1MSECIF)
004BF4  ABC480     BTST U1OTGIR, #6
004BF6  320003     BRA Z, 0x4BFE
701:                       {
702:                           USBClearInterruptFlag(USBT1MSECIFReg, USBT1MSECIFBitNum);
004BF8  200400     MOV #0x40, W0
004BFA  882400     MOV W0, U1OTGIR
703:                           USBIncrement1msInternalTimers();
004BFC  07FFC8     RCALL USBIncrement1msInternalTimers
704:                       }
705:                   #endif
706:               
707:                   //Start-of-Frame Interrupt
708:                   if(USBSOFIF)
004BFE  AB448A     BTST U1IR, #2
004C00  32000E     BRA Z, 0x4C1E
709:                   {
710:                       //Call the user SOF event callback if enabled.
711:                       if(USBSOFIE)
004C02  AB448C     BTST U1IE, #2
004C04  320004     BRA Z, 0x4C0E
712:                       {
713:                           USB_SOF_HANDLER(EVENT_SOF,0,1);
004C06  200012     MOV #0x1, W2
004C08  EB0080     CLR W1
004C0A  200730     MOV #0x73, W0
004C0C  07170F     RCALL USER_USB_CALLBACK_EVENT_HANDLER
714:                       }    
715:                       USBClearInterruptFlag(USBSOFIFReg,USBSOFIFBitNum);
004C0E  200040     MOV #0x4, W0
004C10  882450     MOV W0, U1IR
716:               
717:                       #if defined(__XC8__) || defined(__C18__)
718:                           USBIncrement1msInternalTimers();
719:                       #endif
720:               
721:                       #if defined(USB_ENABLE_STATUS_STAGE_TIMEOUTS)
722:                           //Supporting this feature requires a 1ms time base for keeping track of the timeout interval.
723:                           #if(USB_SPEED_OPTION == USB_LOW_SPEED)
724:                               #warning "Double click this message.  See inline code comments."
725:                               //The "USB_ENABLE_STATUS_STAGE_TIMEOUTS" feature is optional and is
726:                               //not strictly needed in all applications (ex: those that never call 
727:                               //USBDeferStatusStage() and don't use host to device (OUT) control
728:                               //transfers with data stage).  
729:                               //However, if this feature is enabled and used in a low speed application,
730:                               //it is required for the application code to periodically call the
731:                               //USBIncrement1msInternalTimers() function at a nominally 1ms rate.
732:                           #endif
733:                           
734:                           //Decrement our status stage counter.
735:                           if(USBStatusStageTimeoutCounter != 0u)
004C12  E2486F     CP0.B USBStatusStageTimeoutCounter
004C14  320001     BRA Z, 0x4C18
736:                           {
737:                               USBStatusStageTimeoutCounter--;
004C16  ED686F     DEC.B USBStatusStageTimeoutCounter
738:                           }
739:                           //Check if too much time has elapsed since progress was made in 
740:                           //processing the control transfer, without arming the status stage.  
741:                           //If so, auto-arm the status stage to ensure that the control 
742:                           //transfer can [eventually] complete, within the timing limits
743:                           //dictated by section 9.2.6 of the official USB 2.0 specifications.
744:                           if(USBStatusStageTimeoutCounter == 0)
004C18  E2486F     CP0.B USBStatusStageTimeoutCounter
004C1A  3A0001     BRA NZ, 0x4C1E
745:                           {
746:                               USBCtrlEPAllowStatusStage();    //Does nothing if the status stage was already armed.
004C1C  07FE45     RCALL USBCtrlEPAllowStatusStage
747:                           } 
748:                       #endif
749:                   }
750:               
751:                   if(USBStallIF && USBStallIE)
004C1E  ABE48A     BTST U1IR, #7
004C20  320003     BRA Z, 0x4C28
004C22  ABE48C     BTST U1IE, #7
004C24  320001     BRA Z, 0x4C28
752:                   {
753:                       USBStallHandler();
004C26  07FBAA     RCALL _USBStallHandler
754:                   }
755:               
756:                   if(USBErrorIF && USBErrorIE)
004C28  AB248A     BTST U1IR, #1
004C2A  320009     BRA Z, 0x4C3E
004C2C  AB248C     BTST U1IE, #1
004C2E  320007     BRA Z, 0x4C3E
757:                   {
758:                       USB_ERROR_HANDLER(EVENT_BUS_ERROR,0,1);
004C30  200012     MOV #0x1, W2
004C32  EB0080     CLR W1
004C34  27FFF0     MOV #0x7FFF, W0
004C36  0716FA     RCALL USER_USB_CALLBACK_EVENT_HANDLER
759:                       USBClearInterruptRegister(U1EIR);               // This clears UERRIF
004C38  EFA48E     SETM U1EIR
760:               
761:                       //On PIC18, clearing the source of the error will automatically clear
762:                       //  the interrupt flag.  On other devices the interrupt flag must be 
763:                       //  manually cleared. 
764:                       #if defined(__C32__) || defined(__C30__) || defined __XC16__
765:                           USBClearInterruptFlag( USBErrorIFReg, USBErrorIFBitNum );
004C3A  200020     MOV #0x2, W0
004C3C  882450     MOV W0, U1IR
766:                       #endif
767:                   }
768:               
769:                   /*
770:                    * Pointless to continue servicing if the host has not sent a bus reset.
771:                    * Once bus reset is received, the device transitions into the DEFAULT
772:                    * state and is ready for communication.
773:                    */
774:                   if(USBDeviceState < DEFAULT_STATE)
004C3E  8042B0     MOV USBDeviceState, W0
004C40  500FE3     SUB W0, #0x3, [W15]
004C42  3E0002     BRA GTU, 0x4C48
775:                   {
776:                       USBClearUSBInterrupt();
004C44  A9C08E     BCLR IFS5, #6
777:                       return;
004C46  370034     BRA 0x4CB0
778:                   }  
779:               
780:                   /*
781:                    * Task D: Servicing USB Transaction Complete Interrupt
782:                    */
783:                   if(USBTransactionCompleteIE)
004C48  AB648C     BTST U1IE, #3
004C4A  320031     BRA Z, 0x4CAE
784:                   {
785:                       for(i = 0; i < 4u; i++)	//Drain or deplete the USAT FIFO entries.  If the USB FIFO ever gets full, USB bandwidth
004CAC  3AFFD3     BRA NZ, 0x4C54
786:                       {						//utilization can be compromised, and the device won't be able to receive SETUP packets.
787:                           if(USBTransactionCompleteIF)
004C4C  B3C048     MOV.B #0x4, W8
004C4E  AB648A     BTST U1IR, #3
004C50  3A0004     BRA NZ, 0x4C5A
004C52  37002D     BRA 0x4CAE
004C54  AB648A     BTST U1IR, #3
004C56  3A0003     BRA NZ, 0x4C5E
004C58  37002A     BRA 0x4CAE
788:                           {
789:                               //Save and extract USTAT register info.  Will use this info later.
790:                               USTATcopy.Val = U1STAT;
004C5E  802490     MOV U1STAT, W0
004C60  B7E86C     MOV.B WREG, USTATcopy
791:                               endpoint_number = USBHALGetLastEndpoint(USTATcopy);
004C62  BFC86C     MOV.B USTATcopy, WREG
004C64  FB8000     ZE W0, W0
004C66  DE0044     LSR W0, #4, W0
004C68  B7E86D     MOV.B WREG, endpoint_number
792:               
793:                               USBClearInterruptFlag(USBTransactionCompleteIFReg,USBTransactionCompleteIFBitNum);
004C6A  200080     MOV #0x8, W0
004C6C  882450     MOV W0, U1IR
794:               
795:                               //Keep track of the hardware ping pong state for endpoints other
796:                               //than EP0, if ping pong buffering is enabled.
797:                               #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
798:                               if(USBHALGetLastDirection(USTATcopy) == OUT_FROM_HOST)
004C6E  BFC86C     MOV.B USTATcopy, WREG
004C70  A33800     BTST.Z W0, #3
004C72  3A000A     BRA NZ, 0x4C88
799:                               {
800:                                   ep_data_out[endpoint_number].bits.ping_pong_state ^= 1;
004C5A  2379F9     MOV #0x379F, W9
004C74  BFC86D     MOV.B endpoint_number, WREG
004C76  FB8000     ZE W0, W0
004C78  784169     MOV.B [W9+W0], W2
004C7A  614161     AND.B W2, #0x1, W2
004C7C  A20402     BTG.B W2, #0
004C7E  7840E9     MOV.B [W9+W0], W1
004C80  A10401     BCLR.B W1, #0
004C82  70C082     IOR.B W1, W2, W1
004C84  787481     MOV.B W1, [W9+W0]
004C86  370009     BRA 0x4C9A
801:                               }
802:                               else
803:                               {
804:                                   ep_data_in[endpoint_number].bits.ping_pong_state ^= 1;
004C5C  2379DA     MOV #0x379D, W10
004C88  BFC86D     MOV.B endpoint_number, WREG
004C8A  FB8000     ZE W0, W0
004C8C  78416A     MOV.B [W10+W0], W2
004C8E  614161     AND.B W2, #0x1, W2
004C90  A20402     BTG.B W2, #0
004C92  7840EA     MOV.B [W10+W0], W1
004C94  A10401     BCLR.B W1, #0
004C96  70C082     IOR.B W1, W2, W1
004C98  787501     MOV.B W1, [W10+W0]
805:                               }
806:                               #endif
807:               
808:                               //USBCtrlEPService only services transactions over EP0.
809:                               //It ignores all other EP transactions.
810:                               if(endpoint_number == 0)
004C9A  E2486D     CP0.B endpoint_number
004C9C  3A0002     BRA NZ, 0x4CA2
811:                               {
812:                                   USBCtrlEPService();
004C9E  07FF56     RCALL _USBCtrlEPService
004CA0  370004     BRA 0x4CAA
813:                               }
814:                               else
815:                               {
816:                                   USB_TRANSFER_COMPLETE_HANDLER(EVENT_TRANSFER, (uint8_t*)&USTATcopy.Val, 0);
004CA2  EB0100     CLR W2
004CA4  2086C1     MOV #0x86C, W1
004CA6  200720     MOV #0x72, W0
004CA8  0716C1     RCALL USER_USB_CALLBACK_EVENT_HANDLER
004CAA  E94408     DEC.B W8, W8
817:                               }
818:                           }//end if(USBTransactionCompleteIF)
819:                           else
820:                           {
821:                               break;	//USTAT FIFO must be empty.
822:                           }
823:                       }//end for()
824:                   }//end if(USBTransactionCompleteIE)
825:               
826:                   USBClearUSBInterrupt();
004CAE  A9C08E     BCLR IFS5, #6
827:               }//end of USBDeviceTasks()
004CB0  78054F     MOV [--W15], W10
004CB2  BE044F     MOV.D [--W15], W8
004CB4  060000     RETURN
828:               
829:               /*******************************************************************************
830:                 Function:
831:                       void USBEnableEndpoint(uint8_t ep, uint8_t options)
832:                   
833:                 Summary:
834:                   This function will enable the specified endpoint with the specified
835:                   options
836:                 Description:
837:                   This function will enable the specified endpoint with the specified
838:                   options.
839:                   
840:                   Typical Usage:
841:                   <code>
842:                   void USBCBInitEP(void)
843:                   {
844:                       USBEnableEndpoint(MSD_DATA_IN_EP,USB_IN_ENABLED|USB_OUT_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
845:                       USBMSDInit();
846:                   }
847:                   </code>
848:                   
849:                   In the above example endpoint number MSD_DATA_IN_EP is being configured
850:                   for both IN and OUT traffic with handshaking enabled. Also since
851:                   MSD_DATA_IN_EP is not endpoint 0 (MSD does not allow this), then we can
852:                   explicitly disable SETUP packets on this endpoint.
853:                 Conditions:
854:                   None
855:                 Input:
856:                   uint8_t ep -       the endpoint to be configured
857:                   uint8_t options -  optional settings for the endpoint. The options should
858:                                   be ORed together to form a single options string. The
859:                                   available optional settings for the endpoint. The
860:                                   options should be ORed together to form a single options
861:                                   string. The available options are the following\:
862:                                   * USB_HANDSHAKE_ENABLED enables USB handshaking (ACK,
863:                                     NAK)
864:                                   * USB_HANDSHAKE_DISABLED disables USB handshaking (ACK,
865:                                     NAK)
866:                                   * USB_OUT_ENABLED enables the out direction
867:                                   * USB_OUT_DISABLED disables the out direction
868:                                   * USB_IN_ENABLED enables the in direction
869:                                   * USB_IN_DISABLED disables the in direction
870:                                   * USB_ALLOW_SETUP enables control transfers
871:                                   * USB_DISALLOW_SETUP disables control transfers
872:                                   * USB_STALL_ENDPOINT STALLs this endpoint
873:                 Return:
874:                   None
875:                 Remarks:
876:                   None                                                                                                          
877:                 *****************************************************************************/
878:               void USBEnableEndpoint(uint8_t ep, uint8_t options)
879:               {
00476E  BE9F88     MOV.D W8, [W15++]
004770  781F8A     MOV W10, [W15++]
004772  784500     MOV.B W0, W10
004774  784481     MOV.B W1, W9
880:                   unsigned char* p;
881:                       
882:                   //Use USBConfigureEndpoint() to set up the pBDTEntryIn/Out[ep] pointer and 
883:                   //starting DTS state in the BDT entry.
884:                   if(options & USB_OUT_ENABLED)
004776  FB8409     ZE W9, W8
004778  A33808     BTST.Z W8, #3
00477A  320003     BRA Z, 0x4782
885:                   {
886:                       USBConfigureEndpoint(ep, OUT_FROM_HOST);
00477C  EB4080     CLR.B W1
00477E  78400A     MOV.B W10, W0
004780  07FD3B     RCALL _USBConfigureEndpoint
887:                   }
888:                   if(options & USB_IN_ENABLED)
004782  A32808     BTST.Z W8, #2
004784  320003     BRA Z, 0x478C
889:                   {
890:                       USBConfigureEndpoint(ep, IN_TO_HOST);
004786  B3C011     MOV.B #0x1, W1
004788  78400A     MOV.B W10, W0
00478A  07FD36     RCALL _USBConfigureEndpoint
891:                   }
892:               
893:                   //Update the relevant UEPx register to actually enable the endpoint with
894:                   //the specified options (ex: handshaking enabled, control transfers allowed,
895:                   //etc.)
896:                   #if defined(__C32__)
897:                       p = (unsigned char*)(&U1EP0+(4*ep));
898:                   #else
899:                       p = (unsigned char*)(&U1EP0+ep);
00478C  FB850A     ZE W10, W10
900:                   #endif
901:                   *p = options;
00478E  45050A     ADD W10, W10, W10
004790  204AA0     MOV #0x4AA, W0
004792  7D7009     MOV.B W9, [W0+W10]
902:               }
004794  78054F     MOV [--W15], W10
004796  BE044F     MOV.D [--W15], W8
004798  060000     RETURN
903:               
904:               
905:               /*************************************************************************
906:                 Function:
907:                   USB_HANDLE USBTransferOnePacket(uint8_t ep, uint8_t dir, uint8_t* data, uint8_t len)
908:                   
909:                 Summary:
910:                   Transfers a single packet (one transaction) of data on the USB bus.
911:               
912:                 Description:
913:                   The USBTransferOnePacket() function prepares a USB endpoint
914:                   so that it may send data to the host (an IN transaction), or 
915:                   receive data from the host (an OUT transaction).  The 
916:                   USBTransferOnePacket() function can be used both to receive	and 
917:                   send data to the host.  This function is the primary API function 
918:                   provided by the USB stack firmware for sending or receiving application 
919:                   data over the USB port.  
920:               
921:                   The USBTransferOnePacket() is intended for use with all application 
922:                   endpoints.  It is not used for sending or receiving application data 
923:                   through endpoint 0 by using control transfers.  Separate API 
924:                   functions, such as USBEP0Receive(), USBEP0SendRAMPtr(), and
925:                   USBEP0SendROMPtr() are provided for this purpose.
926:               
927:                   The	USBTransferOnePacket() writes to the Buffer Descriptor Table (BDT)
928:                   entry associated with an endpoint buffer, and sets the UOWN bit, which 
929:                   prepares the USB hardware to allow the transaction to complete.  The 
930:                   application firmware can use the USBHandleBusy() macro to check the 
931:                   status of the transaction, to see if the data has been successfully 
932:                   transmitted yet.
933:               
934:               
935:                   Typical Usage
936:                   <code>
937:                   //make sure that the we are in the configured state
938:                   if(USBGetDeviceState() == CONFIGURED_STATE)
939:                   {
940:                       //make sure that the last transaction isn't busy by checking the handle
941:                       if(!USBHandleBusy(USBInHandle))
942:                       {
943:               	        //Write the new data that we wish to send to the host to the INPacket[] array
944:               	        INPacket[0] = USEFUL_APPLICATION_VALUE1;
945:               	        INPacket[1] = USEFUL_APPLICATION_VALUE2;
946:               	        //INPacket[2] = ... (fill in the rest of the packet data)
947:               	      
948:                           //Send the data contained in the INPacket[] array through endpoint "EP_NUM"
949:                           USBInHandle = USBTransferOnePacket(EP_NUM,IN_TO_HOST,(uint8_t*)&INPacket[0],sizeof(INPacket));
950:                       }
951:                   }
952:                   </code>
953:               
954:                 Conditions:
955:                   Before calling USBTransferOnePacket(), the following should be true.
956:                   1.  The USB stack has already been initialized (USBDeviceInit() was called).
957:                   2.  A transaction is not already pending on the specified endpoint.  This
958:                       is done by checking the previous request using the USBHandleBusy() 
959:                       macro (see the typical usage example).
960:                   3.  The host has already sent a set configuration request and the 
961:                       enumeration process is complete.
962:                       This can be checked by verifying that the USBGetDeviceState() 
963:                       macro returns "CONFIGURED_STATE", prior to calling 
964:                       USBTransferOnePacket().
965:                					
966:                 Input:
967:                   uint8_t ep - The endpoint number that the data will be transmitted or
968:               	          received on
969:                   uint8_t dir - The direction of the transfer
970:                              This value is either OUT_FROM_HOST or IN_TO_HOST
971:                   uint8_t* data - For IN transactions: pointer to the RAM buffer containing
972:                                the data to be sent to the host.  For OUT transactions: pointer
973:                                to the RAM buffer that the received data should get written to.
974:                  uint8_t len - Length of the data needing to be sent (for IN transactions).
975:                             For OUT transactions, the len parameter should normally be set
976:                             to the endpoint size specified in the endpoint descriptor.    
977:               
978:                 Return Values:
979:                   USB_HANDLE - handle to the transfer.  The handle is a pointer to 
980:                                the BDT entry associated with this transaction.  The
981:                                status of the transaction (ex: if it is complete or still
982:                                pending) can be checked using the USBHandleBusy() macro
983:                                and supplying the USB_HANDLE provided by
984:                                USBTransferOnePacket().
985:               
986:                 Remarks:
987:                   If calling the USBTransferOnePacket() function from within the USBCBInitEP()
988:                   callback function, the set configuration is still being processed and the
989:                   USBDeviceState may not be == CONFIGURED_STATE yet.  In this	special case, 
990:                   the USBTransferOnePacket() may still be called, but make sure that the 
991:                   endpoint has been enabled and initialized by the USBEnableEndpoint() 
992:                   function first.  
993:                   
994:                 *************************************************************************/
995:               USB_HANDLE USBTransferOnePacket(uint8_t ep,uint8_t dir,uint8_t* data,uint8_t len)
996:               {
997:                   volatile BDT_ENTRY* handle;
998:               
999:                   //If the direction is IN
1000:                  if(dir != 0)
00479A  E00401     CP0.B W1
00479C  320005     BRA Z, 0x47A8
1001:                  {
1002:                      //point to the IN BDT of the specified endpoint
1003:                      handle = pBDTEntryIn[ep];
00479E  FB8200     ZE W0, W4
0047A0  420204     ADD W4, W4, W4
0047A2  2085E5     MOV #0x85E, W5
0047A4  7A0265     MOV [W5+W4], W4
0047A6  370004     BRA 0x47B0
1004:                  }
1005:                  else
1006:                  {
1007:                      //else point to the OUT BDT of the specified endpoint
1008:                      handle = pBDTEntryOut[ep];
0047A8  FB8200     ZE W0, W4
0047AA  420204     ADD W4, W4, W4
0047AC  2085A5     MOV #0x85A, W5
0047AE  7A0265     MOV [W5+W4], W4
1009:                  }
1010:                  
1011:                  //Error checking code.  Make sure the handle (pBDTEntryIn[ep] or
1012:                  //pBDTEntryOut[ep]) is initialized before using it.
1013:                  if(handle == 0)
0047B2  E00004     CP0 W4
0047B4  32001A     BRA Z, 0x47EA
1014:                  {
1015:                      return 0;
0047B0  EB0280     CLR W5
1016:                  }
1017:              
1018:                  //Toggle the DTS bit if required
1019:                  #if (USB_PING_PONG_MODE == USB_PING_PONG__NO_PING_PONG)
1020:                      handle->STAT.Val ^= _DTSMASK;
1021:                  #elif (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY)
1022:                      if(ep != 0)
1023:                      {
1024:                          handle->STAT.Val ^= _DTSMASK;
1025:                      }
1026:                  #endif
1027:              
1028:                  //Set the data pointer, data length, and enable the endpoint
1029:                  handle->ADR = ConvertToPhysicalAddress(data);
0047B6  980212     MOV W2, [W4+2]
1030:                  handle->CNT = len;
0047B8  784A03     MOV.B W3, [W4]
1031:                  handle->STAT.Val &= _DTSMASK;
0047BA  904114     MOV.B [W4+1], W2
0047BC  B24402     AND.B #0x40, W2
0047BE  984212     MOV.B W2, [W4+1]
1032:                  handle->STAT.Val |= (_DTSEN & _DTS_CHECKING_ENABLED);
0047C0  904114     MOV.B [W4+1], W2
0047C2  A03402     BSET.B W2, #3
0047C4  984212     MOV.B W2, [W4+1]
1033:                  handle->STAT.Val |= _USIE;
0047C6  904114     MOV.B [W4+1], W2
0047C8  A07402     BSET.B W2, #7
0047CA  984212     MOV.B W2, [W4+1]
1034:              
1035:                  //Point to the next buffer for ping pong purposes.
1036:                  if(dir != OUT_FROM_HOST)
0047CC  E00401     CP0.B W1
0047CE  320007     BRA Z, 0x47DE
1037:                  {
1038:                      //toggle over the to the next buffer for an IN endpoint
1039:                      pBDTEntryIn[ep] = (BDT_ENTRY*)(((uintptr_t)pBDTEntryIn[ep]) ^ USB_NEXT_PING_PONG);
0047D0  FB8000     ZE W0, W0
0047D2  400000     ADD W0, W0, W0
0047D4  2085E1     MOV #0x85E, W1
0047D6  408000     ADD W1, W0, W0
0047D8  A22010     BTG [W0], #2
1040:                  }
1041:                  else
1042:                  {
1043:                      //toggle over the to the next buffer for an OUT endpoint
1044:                      pBDTEntryOut[ep] = (BDT_ENTRY*)(((uintptr_t)pBDTEntryOut[ep]) ^ USB_NEXT_PING_PONG);
0047DE  FB8000     ZE W0, W0
0047E0  400000     ADD W0, W0, W0
0047E2  2085A1     MOV #0x85A, W1
0047E4  408000     ADD W1, W0, W0
0047E6  A22010     BTG [W0], #2
1045:                  }
1046:                  return (USB_HANDLE)handle;
0047DA  780284     MOV W4, W5
0047DC  370006     BRA 0x47EA
0047E8  780284     MOV W4, W5
1047:              }
0047EA  780005     MOV W5, W0
0047EC  060000     RETURN
1048:              
1049:              
1050:              /********************************************************************
1051:                  Function:
1052:                      void USBStallEndpoint(uint8_t ep, uint8_t dir)
1053:                      
1054:                  Summary:
1055:                       Configures the specified endpoint to send STALL to the host, the next
1056:                       time the host tries to access the endpoint.
1057:                  
1058:                  PreCondition:
1059:                      None
1060:                      
1061:                  Parameters:
1062:                      uint8_t ep - The endpoint number that should be configured to send STALL.
1063:                      uint8_t dir - The direction of the endpoint to STALL, either
1064:                                 IN_TO_HOST or OUT_FROM_HOST.
1065:                      
1066:                  Return Values:
1067:                      None
1068:                      
1069:                  Remarks:
1070:                      None
1071:              
1072:               *******************************************************************/
1073:              void USBStallEndpoint(uint8_t ep, uint8_t dir)
1074:              {
1075:                  BDT_ENTRY *p;
1076:              
1077:                  if(ep == 0)
0047EE  E00400     CP0.B W0
0047F0  3A0015     BRA NZ, 0x481C
1078:                  {
1079:                      //For control endpoints (ex: EP0), we need to STALL both IN and OUT
1080:                      //endpoints.  EP0 OUT must also be prepared to receive the next SETUP 
1081:                      //packet that will arrive.
1082:                      pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
0047F2  B3C401     MOV.B #0x40, W1
0047F4  804330     MOV pBDTEntryEP0OutNext, W0
0047F6  784801     MOV.B W1, [W0]
1083:                      pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
0047F8  804330     MOV pBDTEntryEP0OutNext, W0
0047FA  237A11     MOV #0x37A1, W1
0047FC  980011     MOV W1, [W0+2]
1084:                      pBDTEntryEP0OutNext->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
0047FE  B3C0C1     MOV.B #0xC, W1
004800  984011     MOV.B W1, [W0+1]
1085:                      pBDTEntryEP0OutNext->STAT.Val |= _USIE;
004802  804330     MOV pBDTEntryEP0OutNext, W0
004804  904110     MOV.B [W0+1], W2
004806  B3C801     MOV.B #0x80, W1
004808  714101     IOR.B W2, W1, W2
00480A  984012     MOV.B W2, [W0+1]
1086:                      pBDTEntryIn[0]->STAT.Val = _BSTALL; 
00480C  B3C042     MOV.B #0x4, W2
00480E  8042F0     MOV pBDTEntryIn, W0
004810  984012     MOV.B W2, [W0+1]
1087:                      pBDTEntryIn[0]->STAT.Val |= _USIE;
004812  8042F0     MOV pBDTEntryIn, W0
004814  904110     MOV.B [W0+1], W2
004816  714081     IOR.B W2, W1, W1
004818  984011     MOV.B W1, [W0+1]
00481A  370010     BRA 0x483C
1088:                             
1089:                  }
1090:                  else
1091:                  {
1092:                      p = (BDT_ENTRY*)(&BDT[EP(ep,dir,0)]);
00481C  FB8081     ZE W1, W1
00481E  FB8000     ZE W0, W0
004820  400000     ADD W0, W0, W0
004822  408000     ADD W1, W0, W0
004824  DD0043     SL W0, #3, W0
004826  238002     MOV #0x3800, W2
004828  400182     ADD W0, W2, W3
1093:                      p->STAT.Val |= _BSTALL;
1094:                      p->STAT.Val |= _USIE;
00482A  904213     MOV.B [W3+1], W4
00482C  B3C841     MOV.B #0x84, W1
00482E  724201     IOR.B W4, W1, W4
004830  984194     MOV.B W4, [W3+1]
1095:                  
1096:                      //If the device is in FULL or ALL_BUT_EP0 ping pong modes
1097:                      //then stall that entry as well
1098:                      #if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG) || (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0)
1099:                      p = (BDT_ENTRY*)(&BDT[EP(ep,dir,1)]);
004832  400064     ADD W0, #0x4, W0
004834  400002     ADD W0, W2, W0
1100:                      p->STAT.Val |= _BSTALL;
1101:                      p->STAT.Val |= _USIE;
004836  904110     MOV.B [W0+1], W2
004838  714081     IOR.B W2, W1, W1
00483A  984011     MOV.B W1, [W0+1]
1102:                      #endif
1103:                  }
1104:              }
00483C  060000     RETURN
1105:              
1106:              /**************************************************************************
1107:                  Function:
1108:                      void USBCancelIO(uint8_t endpoint)
1109:                  
1110:                  Description:
1111:                      This function cancels the transfers pending on the specified endpoint.
1112:                      This function can only be used after a SETUP packet is received and 
1113:                      before that setup packet is handled.  This is the time period in which
1114:                      the EVENT_EP0_REQUEST is thrown, before the event handler function
1115:                      returns to the stack.
1116:              
1117:                  Precondition:
1118:                
1119:                  Parameters:
1120:                      uint8_t endpoint - the endpoint number you wish to cancel the transfers for
1121:                   
1122:                  Return Values:
1123:                      None
1124:                      
1125:                  Remarks:
1126:                      None
1127:                                                                        
1128:                **************************************************************************/
1129:              void USBCancelIO(uint8_t endpoint)
1130:              {
1131:                  if(USBPacketDisable == 1)
00483E  ABA494     BTST U1CON, #5
004840  320019     BRA Z, 0x4874
1132:                  {
1133:                  	//The PKTDIS bit is currently set right now.  It is therefore "safe"
1134:                  	//to mess with the BDT right now.
1135:                  	pBDTEntryIn[endpoint]->Val &= _DTSMASK;	//Makes UOWN = 0 (_UCPU mode).  Deactivates endpoint.  Only sends NAKs.
004842  FB8000     ZE W0, W0
004844  400000     ADD W0, W0, W0
004846  2085E1     MOV #0x85E, W1
004848  408000     ADD W1, W0, W0
00484A  780090     MOV [W0], W1
00484C  BE0311     MOV.D [W1], W6
00484E  200404     MOV #0x40, W4
004850  200005     MOV #0x0, W5
004852  620306     AND W4, W6, W6
004854  EB0380     CLR W7
004856  BE8886     MOV.D W6, [W1]
1136:                  	pBDTEntryIn[endpoint]->Val ^= _DTSMASK;	//Toggle the DTS bit.  This packet didn't get sent yet, and the next call to USBTransferOnePacket() will re-toggle the DTS bit back to the original (correct) value.
004858  780090     MOV [W0], W1
00485A  BE0311     MOV.D [W1], W6
00485C  6B1884     XOR W6, W4, [W1++]
00485E  6B9085     XOR W7, W5, [W1--]
1137:                  	
1138:                  	//Need to do additional handling if ping-pong buffering is being used
1139:                      #if ((USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG) || (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0))
1140:                      //Point to the next buffer for ping pong purposes.  UOWN getting cleared
1141:                      //(either due to SIE clearing it after a transaction, or the firmware
1142:                      //clearing it) makes hardware ping pong pointer advance.
1143:                      pBDTEntryIn[endpoint] = (BDT_ENTRY*)(((uintptr_t)pBDTEntryIn[endpoint]) ^ USB_NEXT_PING_PONG);
004860  780090     MOV [W0], W1
004862  A22001     BTG W1, #2
004864  780801     MOV W1, [W0]
1144:                      
1145:                  	pBDTEntryIn[endpoint]->STAT.Val &= _DTSMASK;
004866  904191     MOV.B [W1+1], W3
004868  B24403     AND.B #0x40, W3
00486A  984093     MOV.B W3, [W1+1]
1146:                  	pBDTEntryIn[endpoint]->STAT.Val ^= _DTSMASK;
00486C  780010     MOV [W0], W0
00486E  904090     MOV.B [W0+1], W1
004870  68C104     XOR.B W1, W4, W2
004872  984012     MOV.B W2, [W0+1]
1147:                      #endif
1148:                  }
1149:              }
004874  060000     RETURN
1150:              
1151:              /**************************************************************************
1152:                  Function:
1153:                      void USBDeviceDetach(void)
1154:                 
1155:                  Summary:
1156:                      This function configures the USB module to "soft detach" itself from
1157:                      the USB host.
1158:                      
1159:                  Description:
1160:                      This function configures the USB module to perform a "soft detach"
1161:                      operation, by disabling the D+ (or D-) ~1.5k pull up resistor, which
1162:                      lets the host know the device is present and attached.  This will make
1163:                      the host think that the device has been unplugged.  This is potentially
1164:                      useful, as it allows the USB device to force the host to re-enumerate
1165:                      the device (on the firmware has re-enabled the USB module/pull up, by
1166:                      calling USBDeviceAttach(), to "soft re-attach" to the host).
1167:                      
1168:                  Precondition:
1169:                      Should only be called when USB_INTERRUPT is defined.  See remarks
1170:                      section if USB_POLLING mode option is being used (usb_config.h option).
1171:              
1172:                      Additionally, this function should only be called from the main() loop 
1173:                      context.  Do not call this function from within an interrupt handler, as 
1174:                      this function may modify global interrupt enable bits and settings.
1175:                      
1176:                  Parameters:
1177:                      None
1178:                   
1179:                  Return Values:
1180:                      None
1181:                      
1182:                  Remarks:
1183:                      If the application firmware calls USBDeviceDetach(), it is strongly
1184:                      recommended that the firmware wait at least >= 80ms before calling
1185:                      USBDeviceAttach().  If the firmware performs a soft detach, and then
1186:                      re-attaches too soon (ex: after a few micro seconds for instance), some
1187:                      hosts may interpret this as an unexpected "glitch" rather than as a
1188:                      physical removal/re-attachment of the USB device.  In this case the host
1189:                      may simply ignore the event without re-enumerating the device.  To 
1190:                      ensure that the host properly detects and processes the device soft
1191:                      detach/re-attach, it is recommended to make sure the device remains 
1192:                      detached long enough to mimic a real human controlled USB 
1193:                      unplug/re-attach event (ex: after calling USBDeviceDetach(), do not
1194:                      call USBDeviceAttach() for at least 80+ms, preferably longer.
1195:                      
1196:                      Neither the USBDeviceDetach() or USBDeviceAttach() functions are blocking
1197:                      or take long to execute.  It is the application firmwares 
1198:                      responsibility for adding the 80+ms delay, when using these API 
1199:                      functions.
1200:                      
1201:                      Note: The Windows plug and play event handler processing is fairly 
1202:                      slow, especially in certain versions of Windows, and for certain USB
1203:                      device classes.  It has been observed that some device classes need to
1204:                      provide even more USB detach dwell interval (before calling 
1205:                      USBDeviceAttach()), in order to work correctly after re-enumeration.
1206:                      If the USB device is a CDC class device, it is recommended to wait
1207:                      at least 1.5 seconds or longer, before soft re-attaching to the host,
1208:                      to provide the plug and play event handler enough time to finish 
1209:                      processing the removal event, before the re-attach occurs.
1210:                      
1211:                      If the application is using the USB_POLLING mode option, then the 
1212:                      USBDeviceDetach() and USBDeviceAttach() functions are not available.  
1213:                      In this mode, the USB stack relies on the "#define USE_USB_BUS_SENSE_IO" 
1214:                      and "#define USB_BUS_SENSE" options in the 
1215:                      HardwareProfile  [platform name].h file. 
1216:              
1217:                      When using the USB_POLLING mode option, and the 
1218:                      "#define USE_USB_BUS_SENSE_IO" definition has been commented out, then 
1219:                      the USB stack assumes that it should always enable the USB module at 
1220:                      pretty much all times.  Basically, anytime the application firmware 
1221:                      calls USBDeviceTasks(), the firmware will automatically enable the USB 
1222:                      module.  This mode would typically be selected if the application was 
1223:                      designed to be a purely bus powered device.  In this case, the 
1224:                      application is powered from the +5V VBUS supply from the USB port, so 
1225:                      it is correct and sensible in this type of application to power up and 
1226:                      turn on the USB module, at anytime that the microcontroller is 
1227:                      powered (which implies the USB cable is attached and the host is also 
1228:                      powered).
1229:              
1230:                      In a self powered application, the USB stack is designed with the 
1231:                      intention that the user will enable the "#define USE_USB_BUS_SENSE_IO" 
1232:                      option in the HardwareProfile  [platform name].h file.  When this 
1233:                      option is defined, then the USBDeviceTasks() function will automatically 
1234:                      check the I/O pin port value of the designated pin (based on the 
1235:                      #define USB_BUS_SENSE option in the HardwareProfile  [platform name].h 
1236:                      file), every time the application calls USBDeviceTasks().  If the 
1237:                      USBDeviceTasks() function is executed and finds that the pin defined by 
1238:                      the #define USB_BUS_SENSE is in a logic low state, then it will 
1239:                      automatically disable the USB module and tri-state the D+ and D- pins.  
1240:                      If however the USBDeviceTasks() function is executed and finds the pin 
1241:                      defined by the #define USB_BUS_SENSE is in a logic high state, then it 
1242:                      will automatically enable the USB module, if it has not already been 
1243:                      enabled.        
1244:                                                                        
1245:                **************************************************************************/
1246:              #if defined(USB_INTERRUPT)
1247:              void USBDeviceDetach(void)
1248:              {
1249:                  //If the interrupt option is selected then the customer is required
1250:                  //  to notify the stack when the device is attached or removed from the
1251:                  //  bus by calling the USBDeviceAttach() and USBDeviceDetach() functions.
1252:              #ifdef USB_SUPPORT_OTG
1253:                  if (USB_BUS_SENSE != 1)
1254:              #endif
1255:                  {
1256:                       // Disable module & detach from bus
1257:                       U1CON = 0;             
004876  EF2494     CLR U1CON
1258:              
1259:                       // Mask all USB interrupts              
1260:                       U1IE = 0;          
004878  EF248C     CLR U1IE
1261:              
1262:                       //Move to the detached state                  
1263:                       USBDeviceState = DETACHED_STATE;
00487A  EF2856     CLR USBDeviceState
1264:              
1265:                       #ifdef  USB_SUPPORT_OTG    
1266:                           //Disable D+ Pull-up
1267:                           U1OTGCONbits.DPPULUP = 0;
1268:              
1269:                           //Disable HNP
1270:                           USBOTGDisableHnp();
1271:              
1272:                           //Deactivate HNP
1273:                           USBOTGDeactivateHnp();
1274:                           
1275:                           //If ID Pin Changed State
1276:                           if (USBIDIF && USBIDIE)
1277:                           {  
1278:                               //Re-detect & Initialize
1279:                                USBOTGInitialize();
1280:              
1281:                                //Clear ID Interrupt Flag
1282:                                USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);
1283:                           }
1284:                       #endif
1285:              
1286:                       #if defined __C30__ || defined __XC16__
1287:                           //USBClearInterruptFlag(U1OTGIR, 3); 
1288:                       #endif
1289:                          //return so that we don't go through the rest of 
1290:                          //the state machine
1291:                        return;
1292:                  }
1293:              
1294:              #ifdef USB_SUPPORT_OTG
1295:                  //If Session Is Started Then
1296:                 else
1297:                 {
1298:                      //If SRP Is Ready
1299:                      if (USBOTGSRPIsReady())
1300:                      {   
1301:                          //Clear SRPReady
1302:                          USBOTGClearSRPReady();
1303:              
1304:                          //Clear SRP Timeout Flag
1305:                          USBOTGClearSRPTimeOutFlag();
1306:              
1307:                          //Indicate Session Started
1308:                          UART2PrintString( "\r\n***** USB OTG B Event - Session Started  *****\r\n" );
1309:                      }
1310:                  }
1311:              #endif
1312:              }
00487C  060000     RETURN
1313:              #endif  //#if defined(USB_INTERRUPT)
1314:              /**************************************************************************
1315:                  Function:
1316:                      void USBDeviceAttach(void)
1317:                  
1318:                  Summary:
1319:                      Checks if VBUS is present, and that the USB module is not already 
1320:                      initialized, and if so, enables the USB module so as to signal device 
1321:                      attachment to the USB host.   
1322:              
1323:                  Description:
1324:                      This function indicates to the USB host that the USB device has been
1325:                      attached to the bus.  This function needs to be called in order for the
1326:                      device to start to enumerate on the bus.
1327:                              
1328:                  Precondition:
1329:                      Should only be called when USB_INTERRUPT is defined.  Also, should only 
1330:                      be called from the main() loop context.  Do not call USBDeviceAttach()
1331:                      from within an interrupt handler, as the USBDeviceAttach() function
1332:                      may modify global interrupt enable bits and settings.
1333:              
1334:                      For normal USB devices:
1335:                      Make sure that if the module was previously on, that it has been turned off 
1336:                      for a long time (ex: 100ms+) before calling this function to re-enable the module.
1337:                      If the device turns off the D+ (for full speed) or D- (for low speed) ~1.5k ohm
1338:                      pull up resistor, and then turns it back on very quickly, common hosts will sometimes 
1339:                      reject this event, since no human could ever unplug and re-attach a USB device in a 
1340:                      microseconds (or nanoseconds) timescale.  The host could simply treat this as some kind 
1341:                      of glitch and ignore the event altogether.  
1342:                  Parameters:
1343:                      None
1344:                   
1345:                  Return Values:
1346:                      None       
1347:                  
1348:                  Remarks: 
1349:              		See also the USBDeviceDetach() API function documentation.                                                 
1350:              ****************************************************************************/
1351:              #if defined(USB_INTERRUPT)
1352:              void USBDeviceAttach(void)
1353:              {
1354:                  //if we are in the detached state
1355:                  if(USBDeviceState == DETACHED_STATE)
00487E  E20856     CP0 USBDeviceState
004880  3A0012     BRA NZ, 0x48A6
1356:                  {
1357:                      if(USB_BUS_SENSE == 1)
1358:                      {
1359:                  	    //Initialize registers to known states.
1360:                          U1CON = 0;          
004882  EF2494     CLR U1CON
1361:                  
1362:                          // Mask all USB interrupts
1363:                          U1IE = 0;                                
004884  EF248C     CLR U1IE
1364:                  
1365:                          //Configure things like: pull ups, full/low-speed mode, 
1366:                          //set the ping pong mode, and set internal transceiver
1367:                          SetConfigurationOptions();
004886  200020     MOV #0x2, W0
004888  882530     MOV W0, U1CNFG1
00488A  EF24A8     CLR U1CNFG2
00488C  A94486     BCLR U1OTGCON, #2
00488E  2009F0     MOV #0x9F, W0
004890  882480     MOV W0, U1EIE
004892  882460     MOV W0, U1IE
004894  A8C482     BSET U1OTGIE, #6
1368:                  
1369:                          USBEnableInterrupts();  //Modifies global interrupt settings
004896  A8C09E     BSET IEC5, #6
1370:                  
1371:                          // Enable module & attach to bus
1372:                          while(!U1CONbits.USBEN){U1CONbits.USBEN = 1;}
004898  AB0494     BTST U1CON, #0
00489A  3A0003     BRA NZ, 0x48A2
00489C  A80494     BSET U1CON, #0
00489E  AB0494     BTST U1CON, #0
0048A0  32FFFD     BRA Z, 0x489C
1373:                  
1374:                          //moved to the attached state
1375:                          USBDeviceState = ATTACHED_STATE;
0048A2  200010     MOV #0x1, W0
0048A4  8842B0     MOV W0, USBDeviceState
1376:                  
1377:                          #ifdef  USB_SUPPORT_OTG
1378:                              U1OTGCON = USB_OTG_DPLUS_ENABLE | USB_OTG_ENABLE;  
1379:                          #endif
1380:                      }
1381:                  }
1382:              }
0048A6  060000     RETURN
1383:              #endif  //#if defined(USB_INTERRUPT)
1384:              
1385:              
1386:              /*******************************************************************************
1387:                Function: void USBCtrlEPAllowStatusStage(void);
1388:              
1389:                Summary: This function prepares the proper endpoint 0 IN or endpoint 0 OUT
1390:                          (based on the controlTransferState) to allow the status stage packet
1391:                          of a control transfer to complete.  This function gets used
1392:                          internally by the USB stack itself, but it may also be called from
1393:                          the application firmware, IF the application firmware called
1394:                          the USBDeferStatusStage() function during the initial processing
1395:                          of the control transfer request.  In this case, the application
1396:                          must call the USBCtrlEPAllowStatusStage() once, after it has fully
1397:                          completed processing and handling the data stage portion of the
1398:                          request.
1399:              
1400:                          If the application firmware has no need for delaying control
1401:                          transfers, and therefore never calls USBDeferStatusStage(), then the
1402:                          application firmware should not call USBCtrlEPAllowStatusStage().
1403:              
1404:                Description:
1405:              
1406:                Conditions:
1407:                  None
1408:              
1409:                Input:
1410:              
1411:                Return:
1412:              
1413:                Remarks:
1414:                  None
1415:                *****************************************************************************/
1416:              void USBCtrlEPAllowStatusStage(void)
1417:              {
1418:                  //Check and set two flags, prior to actually modifying any BDT entries.
1419:                  //This double checking is necessary to make certain that 
1420:                  //USBCtrlEPAllowStatusStage() can be called twice simultaneously (ex: once 
1421:                  //in main loop context, while simultaneously getting an interrupt which 
1422:                  //tries to call USBCtrlEPAllowStatusStage() again, at the same time).
1423:                  if(USBStatusStageEnabledFlag1 == false)
0048A8  E24870     CP0.B USBStatusStageEnabledFlag1
0048AA  3A002B     BRA NZ, 0x4902
1424:                  {
1425:                      USBStatusStageEnabledFlag1 = true;
0048AC  B3C010     MOV.B #0x1, W0
0048AE  B7E870     MOV.B WREG, USBStatusStageEnabledFlag1
1426:                      if(USBStatusStageEnabledFlag2 == false)
0048B0  E24871     CP0.B USBStatusStageEnabledFlag2
0048B2  3A0027     BRA NZ, 0x4902
1427:                      {
1428:                          USBStatusStageEnabledFlag2 = true;
0048B4  B7E871     MOV.B WREG, USBStatusStageEnabledFlag2
1429:                      
1430:                          //Determine which endpoints (EP0 IN or OUT needs arming for the status
1431:                          //stage), based on the type of control transfer currently pending.
1432:                          if(controlTransferState == CTRL_TRF_RX)
0048B6  BFC869     MOV.B controlTransferState, WREG
0048B8  504FE2     SUB.B W0, #0x2, [W15]
0048BA  3A000A     BRA NZ, 0x48D0
1433:                          {
1434:                              pBDTEntryIn[0]->CNT = 0;
0048BC  8042F0     MOV pBDTEntryIn, W0
0048BE  EB4800     CLR.B [W0]
1435:                              pBDTEntryIn[0]->STAT.Val = _DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);        
0048C0  B3C481     MOV.B #0x48, W1
0048C2  8042F0     MOV pBDTEntryIn, W0
0048C4  984011     MOV.B W1, [W0+1]
1436:                              pBDTEntryIn[0]->STAT.Val |= _USIE;
0048C6  8042F0     MOV pBDTEntryIn, W0
0048C8  904090     MOV.B [W0+1], W1
0048CA  A07401     BSET.B W1, #7
0048CC  984011     MOV.B W1, [W0+1]
0048CE  370019     BRA 0x4902
1437:                          }
1438:                          else if(controlTransferState == CTRL_TRF_TX)
0048D0  BFC869     MOV.B controlTransferState, WREG
0048D2  504FE1     SUB.B W0, #0x1, [W15]
0048D4  3A0016     BRA NZ, 0x4902
1439:                          {
1440:                              BothEP0OutUOWNsSet = false;	//Indicator flag used in USBCtrlTrfOutHandler()
0048D6  EF686E     CLR.B BothEP0OutUOWNsSet
1441:              
1442:                              //This buffer (when ping pong buffering is enabled on EP0 OUT) receives the
1443:                              //next SETUP packet.
1444:                              #if((USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG))
1445:                                  pBDTEntryEP0OutCurrent->CNT = USB_EP0_BUFF_SIZE;
0048D8  B3C400     MOV.B #0x40, W0
0048DA  804321     MOV pBDTEntryEP0OutCurrent, W1
0048DC  784880     MOV.B W0, [W1]
1446:                                  pBDTEntryEP0OutCurrent->ADR = ConvertToPhysicalAddress(&SetupPkt);
0048DE  804321     MOV pBDTEntryEP0OutCurrent, W1
0048E0  237A12     MOV #0x37A1, W2
0048E2  980092     MOV W2, [W1+2]
1447:                                  pBDTEntryEP0OutCurrent->STAT.Val = _BSTALL; //Prepare endpoint to accept a SETUP transaction
0048E4  B3C043     MOV.B #0x4, W3
0048E6  984093     MOV.B W3, [W1+1]
1448:                                  pBDTEntryEP0OutCurrent->STAT.Val |= _USIE;
0048E8  804323     MOV pBDTEntryEP0OutCurrent, W3
0048EA  904213     MOV.B [W3+1], W4
0048EC  B3C801     MOV.B #0x80, W1
0048EE  724201     IOR.B W4, W1, W4
0048F0  984194     MOV.B W4, [W3+1]
1449:                                  BothEP0OutUOWNsSet = true;	//Indicator flag used in USBCtrlTrfOutHandler()
0048F2  B3C015     MOV.B #0x1, W5
0048F4  2086E4     MOV #0x86E, W4
0048F6  784A05     MOV.B W5, [W4]
1450:                              #endif
1451:              
1452:                              //This EP0 OUT buffer receives the 0-byte OUT status stage packet.
1453:                              pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
0048F8  804333     MOV pBDTEntryEP0OutNext, W3
0048FA  784980     MOV.B W0, [W3]
1454:                              pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
0048FC  804330     MOV pBDTEntryEP0OutNext, W0
0048FE  980012     MOV W2, [W0+2]
1455:                              pBDTEntryEP0OutNext->STAT.Val = _USIE;           // Note: DTSEN is 0
004900  984011     MOV.B W1, [W0+1]
1456:                          }
1457:                      }    
1458:                  }
1459:              }   
004902  060000     RETURN
1460:              
1461:              
1462:              /*******************************************************************************
1463:                Function: void USBCtrlEPAllowDataStage(void);
1464:                  
1465:                Summary: This function allows the data stage of either a host-to-device or
1466:                          device-to-host control transfer (with data stage) to complete.
1467:                          This function is meant to be used in conjunction with either the
1468:                          USBDeferOUTDataStage() or USBDeferINDataStage().  If the firmware
1469:                          does not call either USBDeferOUTDataStage() or USBDeferINDataStage(),
1470:                          then the firmware does not need to manually call 
1471:                          USBCtrlEPAllowDataStage(), as the USB stack will call this function
1472:                          instead.
1473:                   
1474:                Description:
1475:                  
1476:                Conditions: A control transfer (with data stage) should already be pending, 
1477:                              if the firmware calls this function.  Additionally, the firmware
1478:                              should have called either USBDeferOUTDataStage() or 
1479:                              USBDeferINDataStage() at the start of the control transfer, if
1480:                              the firmware will be calling this function manually.
1481:              
1482:                Input:
1483:              
1484:                Return:
1485:              
1486:                Remarks: 
1487:                *****************************************************************************/
1488:              void USBCtrlEPAllowDataStage(void)
1489:              {
1490:                  USBDeferINDataStagePackets = false;
004A12  EF6852     CLR.B USBDeferINDataStagePackets
1491:                  USBDeferOUTDataStagePackets = false;
004A14  EF6850     CLR.B USBDeferOUTDataStagePackets
1492:              
1493:                  if(controlTransferState == CTRL_TRF_RX) //(<setup><out><out>...<out><in>)
004A16  BFC869     MOV.B controlTransferState, WREG
004A18  504FE2     SUB.B W0, #0x2, [W15]
004A1A  3A000D     BRA NZ, 0x4A36
1494:                  {
1495:                      //Prepare EP0 OUT to receive the first OUT data packet in the data stage sequence.
1496:                      pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
004A1C  B3C401     MOV.B #0x40, W1
004A1E  804330     MOV pBDTEntryEP0OutNext, W0
004A20  784801     MOV.B W1, [W0]
1497:                      pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&CtrlTrfData);
004A22  804330     MOV pBDTEntryEP0OutNext, W0
004A24  237A91     MOV #0x37A9, W1
004A26  980011     MOV W1, [W0+2]
1498:                      pBDTEntryEP0OutNext->STAT.Val = _DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
004A28  B3C481     MOV.B #0x48, W1
004A2A  984011     MOV.B W1, [W0+1]
1499:                      pBDTEntryEP0OutNext->STAT.Val |= _USIE;
004A2C  804330     MOV pBDTEntryEP0OutNext, W0
004A2E  904090     MOV.B [W0+1], W1
004A30  A07401     BSET.B W1, #7
004A32  984011     MOV.B W1, [W0+1]
004A34  37001B     BRA 0x4A6C
1500:                  }   
1501:                  else    //else must be controlTransferState == CTRL_TRF_TX (<setup><in><in>...<in><out>)
1502:                  {
1503:                      //Error check the data stage byte count.  Make sure the user specified
1504:                      //value was no greater than the number of bytes the host requested.
1505:              		if(SetupPkt.wLength < inPipes[0].wCount.Val)
004A36  237A70     MOV #0x37A7, W0
004A38  FB8010     ZE [W0], W0
004A3A  237A81     MOV #0x37A8, W1
004A3C  FB8091     ZE [W1], W1
004A3E  DD08C8     SL W1, #8, W1
004A40  700081     IOR W0, W1, W1
004A42  81BCA0     MOV 0x3794, W0
004A44  508F80     SUB W1, W0, [W15]
004A46  310007     BRA C, 0x4A56
1506:              		{
1507:              			inPipes[0].wCount.Val = SetupPkt.wLength;
004A48  237A70     MOV #0x37A7, W0
004A4A  FB8090     ZE [W0], W1
004A4C  E80000     INC W0, W0
004A4E  FB8110     ZE [W0], W2
004A50  DD1148     SL W2, #8, W2
004A52  237940     MOV #0x3794, W0
004A54  710801     IOR W2, W1, [W0]
1508:              		}
1509:              		USBCtrlTrfTxService();  //Copies one IN data packet worth of data from application buffer
004A56  07FBE5     RCALL _USBCtrlTrfTxService
1510:              		                        //to CtrlTrfData buffer.  Also keeps track of how many bytes remaining.
1511:              
1512:              	    //Cnt should have been initialized by responsible request owner (ex: by
1513:              	    //using the USBEP0SendRAMPtr() or USBEP0SendROMPtr() API function).
1514:              		pBDTEntryIn[0]->ADR = ConvertToPhysicalAddress(&CtrlTrfData);
004A58  237A91     MOV #0x37A9, W1
004A5A  8042F0     MOV pBDTEntryIn, W0
004A5C  980011     MOV W1, [W0+2]
1515:              		pBDTEntryIn[0]->STAT.Val = _DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
004A5E  B3C481     MOV.B #0x48, W1
004A60  8042F0     MOV pBDTEntryIn, W0
004A62  984011     MOV.B W1, [W0+1]
1516:                      pBDTEntryIn[0]->STAT.Val |= _USIE;
004A64  8042F0     MOV pBDTEntryIn, W0
004A66  904090     MOV.B [W0+1], W1
004A68  A07401     BSET.B W1, #7
004A6A  984011     MOV.B W1, [W0+1]
1517:                  }     
1518:              }    
004A6C  060000     RETURN
1519:              
1520:              
1521:              /******************************************************************************/
1522:              /** Internal Functions *********************************************************/
1523:              /******************************************************************************/
1524:              
1525:              /********************************************************************
1526:               * Function:        void USBConfigureEndpoint(uint8_t EPNum, uint8_t direction)
1527:               *
1528:               * PreCondition:    None
1529:               *
1530:               * Input:           uint8_t EPNum - the endpoint to be configured
1531:               *                  uint8_t direction - the direction to be configured
1532:               *                                   (either OUT_FROM_HOST or IN_TO_HOST)
1533:               *
1534:               * Output:          None
1535:               *
1536:               * Side Effects:    None
1537:               *
1538:               * Overview:        This function will configure the specified 
1539:               *                  endpoint
1540:               *
1541:               * Note:            None
1542:               *******************************************************************/
1543:              static void USBConfigureEndpoint(uint8_t EPNum, uint8_t direction)
1544:              {
1545:                  volatile BDT_ENTRY* handle;
1546:              
1547:                  //Compute a pointer to the even BDT entry corresponding to the
1548:                  //EPNum and direction values passed to this function.
1549:                  handle = (volatile BDT_ENTRY*)&BDT[EP0_OUT_EVEN]; //Get address of start of BDT
1550:                  handle += EP(EPNum,direction,0u);     //Add in offset to the BDT of interest
0041F8  FB8000     ZE W0, W0
0041FA  FB8181     ZE W1, W3
0041FC  400100     ADD W0, W0, W2
0041FE  418102     ADD W3, W2, W2
004200  DD1143     SL W2, #3, W2
004202  238003     MOV #0x3800, W3
004204  410103     ADD W2, W3, W2
1551:                  
1552:                  handle->STAT.UOWN = 0;  //mostly redundant, since USBStdSetCfgHandler() 
004206  A1F012     BCLR [W2], #15
1553:                  //already cleared the entire BDT table
1554:              
1555:                  //Make sure our pBDTEntryIn/Out[] pointer is initialized.  Needed later
1556:                  //for USBTransferOnePacket() API calls.
1557:                  if(direction == OUT_FROM_HOST)
004208  E00401     CP0.B W1
00420A  3A0004     BRA NZ, 0x4214
1558:                  {
1559:                      pBDTEntryOut[EPNum] = handle;
00420C  400000     ADD W0, W0, W0
00420E  2085A1     MOV #0x85A, W1
004210  783082     MOV W2, [W1+W0]
004212  370003     BRA 0x421A
1560:                  }
1561:                  else
1562:                  {
1563:                      pBDTEntryIn[EPNum] = handle;
004214  400000     ADD W0, W0, W0
004216  2085E1     MOV #0x85E, W1
004218  783082     MOV W2, [W1+W0]
1564:                  }
1565:              
1566:                  #if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
1567:                      handle->STAT.DTS = 0;
00421A  A1E012     BCLR [W2], #14
1568:                      (handle+1)->STAT.DTS = 1;
00421C  410164     ADD W2, #0x4, W2
00421E  A0E012     BSET [W2], #14
1569:                  #elif (USB_PING_PONG_MODE == USB_PING_PONG__NO_PING_PONG)
1570:                      //Set DTS to one because the first thing we will do
1571:                      //when transmitting is toggle the bit
1572:                      handle->STAT.DTS = 1;
1573:                  #elif (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY)
1574:                      if(EPNum != 0)
1575:                      {
1576:                          handle->STAT.DTS = 1;
1577:                      }
1578:                  #elif (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0)    
1579:                      if(EPNum != 0)
1580:                      {
1581:                          handle->STAT.DTS = 0;
1582:                          (handle+1)->STAT.DTS = 1;
1583:                      }
1584:                  #endif
1585:              }
004220  060000     RETURN
1586:              
1587:              
1588:              /******************************************************************************
1589:               * Function:        void USBCtrlEPServiceComplete(void)
1590:               *
1591:               * PreCondition:    None
1592:               *
1593:               * Input:           None
1594:               *
1595:               * Output:          None
1596:               *
1597:               * Side Effects:    None
1598:               *
1599:               * Overview:        This routine wrap up the remaining tasks in servicing
1600:               *                  a Setup Request. Its main task is to set the endpoint
1601:               *                  controls appropriately for a given situation. See code
1602:               *                  below.
1603:               *                  There are three main scenarios:
1604:               *                  a) There was no handler for the Request, in this case
1605:               *                     a STALL should be sent out.
1606:               *                  b) The host has requested a read control transfer,
1607:               *                     endpoints are required to be setup in a specific way.
1608:               *                  c) The host has requested a write control transfer, or
1609:               *                     a control data stage is not required, endpoints are
1610:               *                     required to be setup in a specific way.
1611:               *
1612:               *                  Packet processing is resumed by clearing PKTDIS bit.
1613:               *
1614:               * Note:            None
1615:               *****************************************************************************/
1616:              static void USBCtrlEPServiceComplete(void)
1617:              {
1618:                  /*
1619:                   * PKTDIS bit is set when a Setup Transaction is received.
1620:                   * Clear to resume packet processing.
1621:                   */
1622:                  USBPacketDisable = 0;
004A6E  A9A494     BCLR U1CON, #5
1623:              
1624:              	//Check the busy bits and the SetupPtk.DataDir variables to determine what type of
1625:              	//control transfer is currently in progress.  We need to know the type of control
1626:              	//transfer that is currently pending, in order to know how to properly arm the 
1627:              	//EP0 IN and EP0 OUT endpoints.
1628:                  if(inPipes[0].info.bits.busy == 0)
004A70  81BC90     MOV 0x3792, W0
004A72  A37800     BTST.Z W0, #7
004A74  3A0020     BRA NZ, 0x4AB6
1629:                  {
1630:                      if(outPipes[0].info.bits.busy == 1)
004A76  237980     MOV #0x3798, W0
004A78  E00410     CP0.B [W0]
004A7A  3D0008     BRA GE, 0x4A8C
1631:                      {
1632:                          controlTransferState = CTRL_TRF_RX;
004A7C  B3C020     MOV.B #0x2, W0
004A7E  B7E869     MOV.B WREG, controlTransferState
1633:                          /*
1634:                           * Control Write:
1635:                           * <SETUP[0]><OUT[1]><OUT[0]>...<IN[1]> | <SETUP[0]>
1636:                           */
1637:              
1638:                          //1. Prepare OUT EP to receive data, unless a USB class request handler
1639:                          //   function decided to defer the data stage (ex: because the intended
1640:                          //   RAM buffer wasn't available yet) by calling USBDeferDataStage().
1641:                          //   If it did so, it is then responsible for calling USBCtrlEPAllowDataStage(),
1642:                          //   once it is ready to begin receiving the data.
1643:                          if(USBDeferOUTDataStagePackets == false)
004A80  E24850     CP0.B USBDeferOUTDataStagePackets
004A82  3A0001     BRA NZ, 0x4A86
1644:                          {
1645:                              USBCtrlEPAllowDataStage();
004A84  07FFC6     RCALL USBCtrlEPAllowDataStage
1646:                          }
1647:                          
1648:                          //2.  IN endpoint 0 status stage will be armed by USBCtrlEPAllowStatusStage() 
1649:                          //after all of the OUT data has been received and consumed, or if a timeout occurs.
1650:                          USBStatusStageEnabledFlag2 = false;
004A86  EF6871     CLR.B USBStatusStageEnabledFlag2
1651:                          USBStatusStageEnabledFlag1 = false;
004A88  EF6870     CLR.B USBStatusStageEnabledFlag1
004A8A  370036     BRA 0x4AF8
1652:                      }
1653:                      else
1654:                      {
1655:                          /*
1656:                           * If no one knows how to service this request then stall.
1657:                           * Must also prepare EP0 to receive the next SETUP transaction.
1658:                           */
1659:                          pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
004A8C  B3C401     MOV.B #0x40, W1
004A8E  804330     MOV pBDTEntryEP0OutNext, W0
004A90  784801     MOV.B W1, [W0]
1660:                          pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
004A92  804330     MOV pBDTEntryEP0OutNext, W0
004A94  237A11     MOV #0x37A1, W1
004A96  980011     MOV W1, [W0+2]
1661:                          pBDTEntryEP0OutNext->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
004A98  B3C0C1     MOV.B #0xC, W1
004A9A  984011     MOV.B W1, [W0+1]
1662:                          pBDTEntryEP0OutNext->STAT.Val |= _USIE;
004A9C  804330     MOV pBDTEntryEP0OutNext, W0
004A9E  904110     MOV.B [W0+1], W2
004AA0  B3C801     MOV.B #0x80, W1
004AA2  714101     IOR.B W2, W1, W2
004AA4  984012     MOV.B W2, [W0+1]
1663:                          pBDTEntryIn[0]->STAT.Val = _BSTALL;
004AA6  B3C042     MOV.B #0x4, W2
004AA8  8042F0     MOV pBDTEntryIn, W0
004AAA  984012     MOV.B W2, [W0+1]
1664:                          pBDTEntryIn[0]->STAT.Val |= _USIE;
004AAC  8042F0     MOV pBDTEntryIn, W0
004AAE  904110     MOV.B [W0+1], W2
004AB0  714081     IOR.B W2, W1, W1
004AB2  984011     MOV.B W1, [W0+1]
004AB4  370021     BRA 0x4AF8
1665:                      }
1666:                  }
1667:                  else    // A module has claimed ownership of the control transfer session.
1668:                  {
1669:              		if(SetupPkt.DataDir == USB_SETUP_DEVICE_TO_HOST_BITFIELD)
004AB6  237A10     MOV #0x37A1, W0
004AB8  E00410     CP0.B [W0]
004ABA  3D000B     BRA GE, 0x4AD2
1670:              		{
1671:              			controlTransferState = CTRL_TRF_TX;
004ABC  B3C010     MOV.B #0x1, W0
004ABE  B7E869     MOV.B WREG, controlTransferState
1672:              			/*
1673:              			 * Control Read:
1674:              			 * <SETUP[0]><IN[1]><IN[0]>...<OUT[1]> | <SETUP[0]>
1675:              			 *
1676:              			 * 1. Prepare IN EP to transfer data to the host.  If however the data
1677:              			 *    wasn't ready yet (ex: because the firmware needs to go and read it from
1678:              			 *    some slow/currently unavailable resource, such as an external I2C EEPconst),
1679:              			 *    Then the class request handler responsible should call the USBDeferDataStage()
1680:              			 *    macro.  In this case, the firmware may wait up to 500ms, before it is required
1681:              			 *    to transmit the first IN data packet.  Once the data is ready, and the firmware
1682:              			 *    is ready to begin sending the data, it should then call the 
1683:              			 *    USBCtrlEPAllowDataStage() function to start the data stage.
1684:              			 */
1685:              			if(USBDeferINDataStagePackets == false)
004AC0  E24852     CP0.B USBDeferINDataStagePackets
004AC2  3A0001     BRA NZ, 0x4AC6
1686:                          {
1687:                              USBCtrlEPAllowDataStage();
004AC4  07FFA6     RCALL USBCtrlEPAllowDataStage
1688:              			}
1689:              
1690:                          // 2. (Optionally) allow the status stage now, to prepare for early termination.
1691:                          //    Note: If a class request handler decided to set USBDeferStatusStagePacket == true,
1692:                          //    then it is responsible for eventually calling USBCtrlEPAllowStatusStage() once it
1693:                          //    is ready.  If the class request handler does this, it needs to be careful to
1694:                          //    be written so that it can handle the early termination scenario.
1695:                          //    Ex: It should call USBCtrlEPAllowStatusStage() when any of the following occurs:
1696:                          //    1.  The desired total number of bytes were sent to the host.
1697:                          //    2.  The number of bytes that the host originally requested (in the SETUP packet that 
1698:                          //        started the control transfer) has been reached.
1699:                          //    3.  Or, if a timeout occurs (ex: <50ms since the last successful EP0 IN transaction), regardless 
1700:                          //        of how many bytes have actually been sent.  This is necessary to prevent a deadlock situation
1701:                          //        (where the control transfer can't complete, due to continuous NAK on status stage) if the
1702:                          //        host performs early termination.  If enabled, the USB_ENABLE_STATUS_STAGE_TIMEOUTS usb_config.h
1703:                          //        option can take care of this for you.
1704:                          //    Note: For this type of control transfer, there is normally no harm in simply arming the
1705:                          //    status stage packet right now, even if the IN data is not ready yet.  This allows for
1706:                          //    immediate early termination, without adding unnecessary delay.  Therefore, it is generally not
1707:                          //    recommended for the USB class handler firmware to call USBDeferStatusStage(), for this 
1708:                          //    type of control transfer.  If the USB class handler firmware needs more time to fetch the IN
1709:                          //    data that needs to be sent to the host, it should instead use the USBDeferDataStage() function.
1710:                          USBStatusStageEnabledFlag2 = false;
004AC6  EF6871     CLR.B USBStatusStageEnabledFlag2
1711:                          USBStatusStageEnabledFlag1 = false;
004AC8  EF6870     CLR.B USBStatusStageEnabledFlag1
1712:                          if(USBDeferStatusStagePacket == false)
004ACA  E24851     CP0.B USBDeferStatusStagePacket
004ACC  3A0015     BRA NZ, 0x4AF8
1713:                          {
1714:                              USBCtrlEPAllowStatusStage();
004ACE  07FEEC     RCALL USBCtrlEPAllowStatusStage
004AD0  370013     BRA 0x4AF8
1715:                          } 
1716:              		}
1717:              		else   // (SetupPkt.DataDir == USB_SETUP_DIRECTION_HOST_TO_DEVICE)
1718:              		{
1719:              			//This situation occurs for special types of control transfers,
1720:              			//such as that which occurs when the host sends a SET_ADDRESS
1721:              			//control transfer.  Ex:
1722:              			//
1723:              			//<SETUP[0]><IN[1]> | <SETUP[0]>
1724:              				
1725:              			//Although the data direction is HOST_TO_DEVICE, there is no data stage
1726:              			//(hence: outPipes[0].info.bits.busy == 0).  There is however still
1727:              			//an IN status stage.
1728:              
1729:              			controlTransferState = CTRL_TRF_RX;     //Since this is a HOST_TO_DEVICE control transfer
004AD2  B3C020     MOV.B #0x2, W0
004AD4  B7E869     MOV.B WREG, controlTransferState
1730:              			
1731:              			//1. Prepare OUT EP to receive the next SETUP packet.
1732:              			pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
004AD6  B3C401     MOV.B #0x40, W1
004AD8  804330     MOV pBDTEntryEP0OutNext, W0
004ADA  784801     MOV.B W1, [W0]
1733:              			pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
004ADC  804330     MOV pBDTEntryEP0OutNext, W0
004ADE  237A11     MOV #0x37A1, W1
004AE0  980011     MOV W1, [W0+2]
1734:              			pBDTEntryEP0OutNext->STAT.Val = _BSTALL;
004AE2  B3C041     MOV.B #0x4, W1
004AE4  984011     MOV.B W1, [W0+1]
1735:                          pBDTEntryEP0OutNext->STAT.Val |= _USIE;
004AE6  804330     MOV pBDTEntryEP0OutNext, W0
004AE8  904090     MOV.B [W0+1], W1
004AEA  A07401     BSET.B W1, #7
004AEC  984011     MOV.B W1, [W0+1]
1736:              				
1737:              			//2. Prepare for IN status stage of the control transfer
1738:                          USBStatusStageEnabledFlag2 = false;
004AEE  EF6871     CLR.B USBStatusStageEnabledFlag2
1739:                          USBStatusStageEnabledFlag1 = false;
004AF0  EF6870     CLR.B USBStatusStageEnabledFlag1
1740:              			if(USBDeferStatusStagePacket == false)
004AF2  E24851     CP0.B USBDeferStatusStagePacket
004AF4  3A0001     BRA NZ, 0x4AF8
1741:                          {
1742:                              USBCtrlEPAllowStatusStage();
004AF6  07FED8     RCALL USBCtrlEPAllowStatusStage
1743:                          } 
1744:              		}
1745:              
1746:                  }//end if(ctrl_trf_session_owner == MUID_NULL)
1747:              
1748:              }//end USBCtrlEPServiceComplete
004AF8  060000     RETURN
1749:              
1750:              
1751:              /******************************************************************************
1752:               * Function:        void USBCtrlTrfTxService(void)
1753:               *
1754:               * PreCondition:    pSrc, wCount, and usb_stat.ctrl_trf_mem are setup properly.
1755:               *
1756:               * Input:           None
1757:               *
1758:               * Output:          None
1759:               *
1760:               * Side Effects:    None
1761:               *
1762:               * Overview:        This routine is used for device to host control transfers 
1763:               *					(IN transactions).  This function takes care of managing a
1764:               *                  transfer over multiple USB transactions.
1765:               *					This routine should be called from only two places.
1766:               *                  One from USBCtrlEPServiceComplete() and one from
1767:               *                  USBCtrlTrfInHandler().
1768:               *
1769:               * Note:            
1770:               *****************************************************************************/
1771:              static void USBCtrlTrfTxService(void)
1772:              {
1773:                  uint8_t byteToSend;
1774:              
1775:                  //Figure out how many bytes of data to send in the next IN transaction.
1776:                  //Assume a full size packet, unless otherwise determined below.
1777:                  byteToSend = USB_EP0_BUFF_SIZE;         
004224  B3C400     MOV.B #0x40, W0
1778:                  if(inPipes[0].wCount.Val < (uint8_t)USB_EP0_BUFF_SIZE)
004222  81BCA2     MOV 0x3794, W2
004226  2003F1     MOV #0x3F, W1
004228  510F81     SUB W2, W1, [W15]
00422A  3E000E     BRA GTU, 0x4248
1779:                  {
1780:                      byteToSend = inPipes[0].wCount.Val;
00422C  81BCA0     MOV 0x3794, W0
1781:              
1782:                      //Keep track of whether or not we have sent a "short packet" yet.
1783:                      //This is useful so that later on, we can configure EP0 IN to STALL,
1784:                      //after we have sent all of the intended data.  This makes sure the
1785:                      //hardware STALLs if the host erroneously tries to send more IN token 
1786:                      //packets, requesting more data than intended in the control transfer.
1787:                      if(shortPacketStatus == SHORT_PKT_NOT_USED)
00422E  E24868     CP0.B shortPacketStatus
004230  3A0004     BRA NZ, 0x423A
1788:                      {
1789:                          shortPacketStatus = SHORT_PKT_PENDING;
004232  B3C013     MOV.B #0x1, W3
004234  208682     MOV #0x868, W2
004236  784903     MOV.B W3, [W2]
004238  370007     BRA 0x4248
1790:                      }
1791:                      else if(shortPacketStatus == SHORT_PKT_PENDING)
00423A  208681     MOV #0x868, W1
00423C  784091     MOV.B [W1], W1
00423E  50CFE1     SUB.B W1, #0x1, [W15]
004240  3A0003     BRA NZ, 0x4248
1792:                      {
1793:                          shortPacketStatus = SHORT_PKT_SENT;
004242  B3C023     MOV.B #0x2, W3
004244  208682     MOV #0x868, W2
004246  784903     MOV.B W3, [W2]
1794:                      }
1795:                  }
1796:              
1797:                  //Keep track of how many bytes remain to be sent in the transfer, by
1798:                  //subtracting the number of bytes about to be sent from the total.
1799:                  inPipes[0].wCount.Val -= byteToSend;
004248  237941     MOV #0x3794, W1
00424A  FB8100     ZE W0, W2
00424C  110891     SUBR W2, [W1], [W1]
1800:                  
1801:                  //Next, load the number of bytes to send to BC7..0 in buffer descriptor.
1802:                  //Note: Control endpoints may never have a max packet size of > 64 bytes.
1803:                  //Therefore, the BC8 and BC9 bits should always be maintained clear.
1804:                  pBDTEntryIn[0]->CNT = byteToSend;
00424E  8042F1     MOV pBDTEntryIn, W1
004250  784880     MOV.B W0, [W1]
1805:              
1806:                  //Now copy the data from the source location, to the CtrlTrfData[] buffer,
1807:                  //which we will send to the host.
1808:                  pDst = (USB_VOLATILE uint8_t*)CtrlTrfData;                // Set destination pointer
004252  237A91     MOV #0x37A9, W1
004254  884351     MOV W1, pDst
1809:                  if(inPipes[0].info.bits.ctrl_trf_mem == USB_EP0_ROM)   // Determine type of memory source
004256  81BC91     MOV 0x3792, W1
004258  A30801     BTST.Z W1, #0
00425A  320004     BRA Z, 0x4264
1810:                  {
1811:                      while(byteToSend)
004264  E00400     CP0.B W0
004266  320010     BRA Z, 0x4288
004276  3AFFF9     BRA NZ, 0x426A
004278  370007     BRA 0x4288
1812:                      {
1813:                          *pDst++ = *inPipes[0].pSrc.bRom++;
004268  237903     MOV #0x3790, W3
00426A  780093     MOV [W3], W1
00426C  804352     MOV pDst, W2
00426E  785931     MOV.B [W1++], [W2++]
004270  884352     MOV W2, pDst
004272  780981     MOV W1, [W3]
1814:                          byteToSend--;
004274  E94000     DEC.B W0, W0
1815:                      }//end while(byte_to_send.Val)
1816:                  }
1817:                  else  // RAM
1818:                  {
1819:                      while(byteToSend)
00425E  E00400     CP0.B W0
004260  3A000C     BRA NZ, 0x427A
004262  370012     BRA 0x4288
004286  3AFFF9     BRA NZ, 0x427A
1820:                      {
1821:                          *pDst++ = *inPipes[0].pSrc.bRam++;
00425C  237903     MOV #0x3790, W3
00427A  780093     MOV [W3], W1
00427C  804352     MOV pDst, W2
00427E  785931     MOV.B [W1++], [W2++]
004280  884352     MOV W2, pDst
004282  780981     MOV W1, [W3]
1822:                          byteToSend--;
004284  E94000     DEC.B W0, W0
1823:                      }//end while(byte_to_send.Val)
1824:                  }//end if(usb_stat.ctrl_trf_mem == _const)
1825:              }//end USBCtrlTrfTxService
004288  060000     RETURN
1826:              
1827:              /******************************************************************************
1828:               * Function:        void USBCtrlTrfRxService(void)
1829:               *
1830:               * PreCondition:    pDst and wCount are setup properly.
1831:               *                  pSrc is always &CtrlTrfData
1832:               *                  usb_stat.ctrl_trf_mem is always USB_EP0_RAM.
1833:               *                  wCount should be set to 0 at the start of each control
1834:               *                  transfer.
1835:               *
1836:               * Input:           None
1837:               *
1838:               * Output:          None
1839:               *
1840:               * Side Effects:    None
1841:               *
1842:               * Overview:        This routine is used for host to device control transfers
1843:               *					(uses OUT transactions).  This function receives the data that arrives
1844:               *					on EP0 OUT, and copies it into the appropriate outPipes[0].pDst.bRam
1845:               *					buffer.  Once the host has sent all the data it was intending
1846:               *					to send, this function will call the appropriate outPipes[0].pFunc()
1847:               *					handler (unless it is NULL), so that it can be used by the
1848:               *					intended target firmware.
1849:               *
1850:               * Note:            None
1851:               *****************************************************************************/
1852:              static void USBCtrlTrfRxService(void)
1853:              {
1854:                  uint8_t byteToRead;
1855:                  uint8_t i;
1856:              
1857:                  //Load byteToRead with the number of bytes the host just sent us in the 
1858:                  //last OUT transaction.
1859:                  byteToRead = pBDTEntryEP0OutCurrent->CNT;   
004904  804320     MOV pBDTEntryEP0OutCurrent, W0
004906  784290     MOV.B [W0], W5
1860:              
1861:                  //Update the "outPipes[0].wCount.Val", which keeps track of the total number
1862:                  //of remaining bytes expected to be received from the host, in the control
1863:                  //transfer.  First check to see if the host sent us more bytes than the
1864:                  //application firmware was expecting to receive.
1865:                  if(byteToRead > outPipes[0].wCount.Val)
004908  237990     MOV #0x3799, W0
00490A  FB8010     ZE [W0], W0
00490C  2379A1     MOV #0x379A, W1
00490E  FB8091     ZE [W1], W1
004910  DD08C8     SL W1, #8, W1
004912  700001     IOR W0, W1, W0
004914  FB8085     ZE W5, W1
004916  508F80     SUB W1, W0, [W15]
004918  360004     BRA LEU, 0x4922
1866:                  {
1867:                      byteToRead = outPipes[0].wCount.Val;
00491A  237990     MOV #0x3799, W0
00491C  FB8290     ZE [W0], W5
00491E  E80000     INC W0, W0
004920  FB8010     ZE [W0], W0
1868:                  }	
1869:                  //Reduce the number of remaining bytes by the number we just received.
1870:                  outPipes[0].wCount.Val -= byteToRead;
004922  237991     MOV #0x3799, W1
004924  FB8111     ZE [W1], W2
004926  E80001     INC W1, W0
004928  FB8190     ZE [W0], W3
00492A  DD19C8     SL W3, #8, W3
00492C  710183     IOR W2, W3, W3
00492E  FB8105     ZE W5, W2
004930  518102     SUB W3, W2, W2
004932  784191     MOV.B [W1], W3
004934  784882     MOV.B W2, [W1]
004936  DE1148     LSR W2, #8, W2
004938  784090     MOV.B [W0], W1
00493A  784802     MOV.B W2, [W0]
1871:              
1872:                  //Copy the OUT DATAx packet bytes that we just received from the host,
1873:                  //into the user application buffer space.
1874:                  for(i=0;i<byteToRead;i++)
00493C  E00405     CP0.B W5
00493E  320012     BRA Z, 0x4964
004940  EB0080     CLR W1
004960  52CF81     SUB.B W5, W1, [W15]
004962  3EFFF3     BRA GTU, 0x494A
1875:                  {
1876:                      *outPipes[0].pDst.bRam++ = CtrlTrfData[i];
004942  5001E4     SUB W0, #0x4, W3
004944  500163     SUB W0, #0x3, W2
004946  237A97     MOV #0x37A9, W7
004948  200FF6     MOV #0xFF, W6
00494A  FB8213     ZE [W3], W4
00494C  FB8012     ZE [W2], W0
00494E  DD0048     SL W0, #8, W0
004950  720000     IOR W4, W0, W0
004952  78D867     MOV.B [W7+W1], [W0++]
004954  784213     MOV.B [W3], W4
004956  604986     AND.B W0, W6, [W3]
004958  DE0048     LSR W0, #8, W0
00495A  784212     MOV.B [W2], W4
00495C  784900     MOV.B W0, [W2]
00495E  E80081     INC W1, W1
1877:                  }//end while(byteToRead.Val)
1878:              
1879:                  //If there is more data to receive, prepare EP0 OUT so that it can receive 
1880:              	//the next packet in the sequence.
1881:                  if(outPipes[0].wCount.Val > 0)
004964  237990     MOV #0x3799, W0
004966  FB8010     ZE [W0], W0
004968  2379A1     MOV #0x379A, W1
00496A  FB8091     ZE [W1], W1
00496C  DD08C8     SL W1, #8, W1
00496E  700001     IOR W0, W1, W0
004970  320019     BRA Z, 0x49A4
1882:                  {
1883:                      pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
004972  B3C401     MOV.B #0x40, W1
004974  804330     MOV pBDTEntryEP0OutNext, W0
004976  784801     MOV.B W1, [W0]
1884:                      pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&CtrlTrfData);
004978  237A91     MOV #0x37A9, W1
00497A  804330     MOV pBDTEntryEP0OutNext, W0
00497C  980011     MOV W1, [W0+2]
1885:                      if(pBDTEntryEP0OutCurrent->STAT.DTS == 0)
00497E  804320     MOV pBDTEntryEP0OutCurrent, W0
004980  A3E810     BTST.Z [W0], #14
004982  3A0008     BRA NZ, 0x4994
1886:                      {
1887:                          pBDTEntryEP0OutNext->STAT.Val = _DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
004984  B3C481     MOV.B #0x48, W1
004986  804330     MOV pBDTEntryEP0OutNext, W0
004988  984011     MOV.B W1, [W0+1]
1888:                          pBDTEntryEP0OutNext->STAT.Val |= _USIE;
00498A  804330     MOV pBDTEntryEP0OutNext, W0
00498C  904090     MOV.B [W0+1], W1
00498E  A07401     BSET.B W1, #7
004990  984011     MOV.B W1, [W0+1]
004992  370027     BRA 0x49E2
1889:                      }
1890:                      else
1891:                      {
1892:                          pBDTEntryEP0OutNext->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED);
004994  B3C081     MOV.B #0x8, W1
004996  804330     MOV pBDTEntryEP0OutNext, W0
004998  984011     MOV.B W1, [W0+1]
1893:                          pBDTEntryEP0OutNext->STAT.Val |= _USIE;
00499A  804330     MOV pBDTEntryEP0OutNext, W0
00499C  904090     MOV.B [W0+1], W1
00499E  A07401     BSET.B W1, #7
0049A0  984011     MOV.B W1, [W0+1]
0049A2  37001F     BRA 0x49E2
1894:                      }
1895:                  }
1896:                  else
1897:                  {
1898:              	    //We have received all OUT packets that we were expecting to
1899:              	    //receive for the control transfer.  Prepare EP0 OUT to receive
1900:              		//the next SETUP transaction that may arrive.
1901:                      pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
0049A4  B3C401     MOV.B #0x40, W1
0049A6  804330     MOV pBDTEntryEP0OutNext, W0
0049A8  784801     MOV.B W1, [W0]
1902:                      pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
0049AA  804330     MOV pBDTEntryEP0OutNext, W0
0049AC  237A11     MOV #0x37A1, W1
0049AE  980011     MOV W1, [W0+2]
1903:                      //Configure EP0 OUT to receive the next SETUP transaction for any future
1904:                      //control transfers.  However, set BSTALL in case the host tries to send
1905:                      //more data than it claims it was going to send.
1906:                      pBDTEntryEP0OutNext->STAT.Val = _BSTALL;
0049B0  B3C041     MOV.B #0x4, W1
0049B2  984011     MOV.B W1, [W0+1]
1907:                      pBDTEntryEP0OutNext->STAT.Val |= _USIE;
0049B4  804330     MOV pBDTEntryEP0OutNext, W0
0049B6  904090     MOV.B [W0+1], W1
0049B8  A07401     BSET.B W1, #7
0049BA  984011     MOV.B W1, [W0+1]
1908:              
1909:              		//All data bytes for the host to device control write (OUT) have now been
1910:              		//received successfully.
1911:              		//Go ahead and call the user specified callback function, to use/consume
1912:              		//the control transfer data (ex: if the "void (*function)" parameter 
1913:              		//was non-NULL when USBEP0Receive() was called).
1914:                      if(outPipes[0].pFunc != NULL)
0049BC  2379B0     MOV #0x379B, W0
0049BE  FB8010     ZE [W0], W0
0049C0  2379C1     MOV #0x379C, W1
0049C2  FB8091     ZE [W1], W1
0049C4  DD08C8     SL W1, #8, W1
0049C6  700001     IOR W0, W1, W0
0049C8  320007     BRA Z, 0x49D8
1915:                      {
1916:                          #if defined(__XC8)
1917:                              //Special pragmas to suppress an expected/harmless warning
1918:                              //message when building with the XC8 compiler
1919:                              #pragma warning push
1920:                              #pragma warning disable 1088
1921:                              outPipes[0].pFunc();    //Call the user's callback function
1922:                              #pragma warning pop
1923:                          #else
1924:                              outPipes[0].pFunc();    //Call the user's callback function
0049CA  2379B0     MOV #0x379B, W0
0049CC  FB8010     ZE [W0], W0
0049CE  2379C1     MOV #0x379C, W1
0049D0  FB8091     ZE [W1], W1
0049D2  DD08C8     SL W1, #8, W1
0049D4  700001     IOR W0, W1, W0
0049D6  010000     CALL W0
1925:                          #endif
1926:                      }
1927:                      outPipes[0].info.bits.busy = 0;    
0049D8  237980     MOV #0x3798, W0
0049DA  A17410     BCLR.B [W0], #7
1928:              
1929:                      //Ready to arm status stage IN transaction now, if the application
1930:                      //firmware has completed processing the request.  If it is still busy
1931:                      //and needs more time to finish handling the request, then the user
1932:                      //callback (the one called by the outPipes[0].pFunc();) should set the
1933:                      //USBDeferStatusStagePacket to true (by calling USBDeferStatusStage()).  In
1934:                      //this case, it is the application's firmware responsibility to call 
1935:                      //the USBCtrlEPAllowStatusStage() function, once it is fully done handling the request.
1936:                      //Note: The application firmware must process the request and call
1937:                      //USBCtrlEPAllowStatusStage() in a semi-timely fashion.  "Semi-timely"
1938:                      //means either 50ms, 500ms, or 5 seconds, depending on the type of
1939:                      //control transfer.  See the USB 2.0 specification section 9.2.6 for
1940:                      //more details.
1941:                      if(USBDeferStatusStagePacket == false)
0049DC  E24851     CP0.B USBDeferStatusStagePacket
0049DE  3A0001     BRA NZ, 0x49E2
1942:                      {
1943:                          USBCtrlEPAllowStatusStage();
0049E0  07FF63     RCALL USBCtrlEPAllowStatusStage
1944:                      }            
1945:                  }    
1946:              
1947:              }//end USBCtrlTrfRxService
0049E2  060000     RETURN
1948:              
1949:              
1950:              /********************************************************************
1951:               * Function:        void USBStdSetCfgHandler(void)
1952:               *
1953:               * PreCondition:    None
1954:               *
1955:               * Input:           None
1956:               *
1957:               * Output:          None
1958:               *
1959:               * Side Effects:    None
1960:               *
1961:               * Overview:        This routine first disables all endpoints by
1962:               *                  clearing UEP registers. It then configures
1963:               *                  (initializes) endpoints by calling the callback
1964:               *                  function USBCBInitEP().
1965:               *
1966:               * Note:            None
1967:               *******************************************************************/
1968:              static void USBStdSetCfgHandler(void)
1969:              {
0045D8  781F88     MOV W8, [W15++]
1970:                  uint8_t i;
1971:              
1972:                  // This will generate a zero length packet
1973:                  inPipes[0].info.bits.busy = 1;            
0045DA  237920     MOV #0x3792, W0
0045DC  A07010     BSET [W0], #7
1974:              
1975:                  //Clear all of the endpoint control registers
1976:                  DisableNonZeroEndpoints(USB_MAX_EP_NUMBER);
0045DE  EF24AC     CLR U1EP1
1977:              
1978:                  //Clear all of the BDT entries
1979:                  memset((void*)&BDT[0], 0x00, sizeof(BDT));
0045E0  238008     MOV #0x3800, W8
0045E2  200202     MOV #0x20, W2
0045E4  EB0080     CLR W1
0045E6  780008     MOV W8, W0
0045E8  07E614     RCALL _memset
1980:              
1981:                  // Assert reset request to all of the Ping Pong buffer pointers
1982:                  USBPingPongBufferReset = 1;                                   
0045EA  A82494     BSET U1CON, #1
1983:              
1984:              	//Re-Initialize all ping pong software state bits to 0 (which corresponds to
1985:              	//the EVEN buffer being the next one that will be used), since we are also 
1986:              	//doing a hardware ping pong pointer reset above.
1987:              	for(i = 0; i < (uint8_t)(USB_MAX_EP_NUMBER+1u); i++)
1988:              	{
1989:              		ep_data_in[i].Val = 0u;
0045EC  EB4000     CLR.B W0
0045EE  2379D1     MOV #0x379D, W1
0045F0  784880     MOV.B W0, [W1]
0045F6  2379E1     MOV #0x379E, W1
0045F8  784880     MOV.B W0, [W1]
1990:                      ep_data_out[i].Val = 0u;
0045F2  2379F1     MOV #0x379F, W1
0045F4  784880     MOV.B W0, [W1]
0045FA  237A01     MOV #0x37A0, W1
0045FC  784880     MOV.B W0, [W1]
1991:              	}
1992:              
1993:                  //clear the alternate interface settings
1994:                  memset((void*)&USBAlternateInterface,0x00,USB_MAX_NUM_INT);
0045FE  EF6862     CLR.B USBAlternateInterface
1995:              
1996:                  //Stop trying to reset ping pong buffer pointers
1997:                  USBPingPongBufferReset = 0;
004600  A92494     BCLR U1CON, #1
1998:              
1999:                  pBDTEntryIn[0] = (volatile BDT_ENTRY*)&BDT[EP0_IN_EVEN];
004602  440068     ADD W8, #0x8, W0
004604  8842F0     MOV W0, pBDTEntryIn
2000:              
2001:              	//Set the next out to the current out packet
2002:                  pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[EP0_OUT_EVEN];
004606  884328     MOV W8, pBDTEntryEP0OutCurrent
2003:                  pBDTEntryEP0OutNext = pBDTEntryEP0OutCurrent;
004608  884338     MOV W8, pBDTEntryEP0OutNext
2004:              
2005:                  //set the current configuration
2006:                  USBActiveConfiguration = SetupPkt.bConfigurationValue;
00460A  237A30     MOV #0x37A3, W0
00460C  784110     MOV.B [W0], W2
00460E  208581     MOV #0x858, W1
004610  784882     MOV.B W2, [W1]
2007:              
2008:                  //if the configuration value == 0
2009:                  if(USBActiveConfiguration == 0)
004612  E24858     CP0.B USBActiveConfiguration
004614  3A0003     BRA NZ, 0x461C
2010:                  {
2011:                      //Go back to the addressed state
2012:                      USBDeviceState = ADDRESS_STATE;
004616  200100     MOV #0x10, W0
004618  8842B0     MOV W0, USBDeviceState
00461A  370006     BRA 0x4628
2013:                  }
2014:                  else
2015:                  {
2016:                      //initialize the required endpoints
2017:                      USB_SET_CONFIGURATION_HANDLER(EVENT_CONFIGURED,(void*)&USBActiveConfiguration,1);
00461C  200012     MOV #0x1, W2
00461E  208581     MOV #0x858, W1
004620  200010     MOV #0x1, W0
004622  071A04     RCALL USER_USB_CALLBACK_EVENT_HANDLER
2018:              
2019:                      //Otherwise go to the configured state.  Update the state variable last,
2020:                      //after performing all of the set configuration related initialization
2021:                      //tasks.
2022:                      USBDeviceState = CONFIGURED_STATE;		
004624  200200     MOV #0x20, W0
004626  8842B0     MOV W0, USBDeviceState
2023:                  }//end if(SetupPkt.bConfigurationValue == 0)
2024:              }//end USBStdSetCfgHandler
004628  78044F     MOV [--W15], W8
00462A  060000     RETURN
2025:              
2026:              
2027:              /********************************************************************
2028:               * Function:        void USBStdGetDscHandler(void)
2029:               *
2030:               * PreCondition:    None
2031:               *
2032:               * Input:           None
2033:               *
2034:               * Output:          None
2035:               *
2036:               * Side Effects:    None
2037:               *
2038:               * Overview:        This routine handles the standard GET_DESCRIPTOR
2039:               *                  request.
2040:               *
2041:               * Note:            None
2042:               *******************************************************************/
2043:              static void USBStdGetDscHandler(void)
2044:              {
2045:                  if(SetupPkt.bmRequestType == 0x80)
00428A  B3C800     MOV.B #0x80, W0
00428C  237A11     MOV #0x37A1, W1
00428E  104F91     SUBR.B W0, [W1], [W15]
004290  3A0036     BRA NZ, 0x42FE
2046:                  {
2047:                      inPipes[0].info.Val = USB_EP0_ROM | USB_EP0_BUSY | USB_EP0_INCLUDE_ZERO;
004292  B3CC01     MOV.B #0xC0, W1
004294  237920     MOV #0x3792, W0
004296  784801     MOV.B W1, [W0]
2048:              
2049:                      switch(SetupPkt.bDescriptorType)
004298  237A40     MOV #0x37A4, W0
00429A  784010     MOV.B [W0], W0
00429C  504FE2     SUB.B W0, #0x2, [W15]
00429E  320009     BRA Z, 0x42B2
0042A0  504FE3     SUB.B W0, #0x3, [W15]
0042A2  32001B     BRA Z, 0x42DA
0042A4  504FE1     SUB.B W0, #0x1, [W15]
0042A6  3A0029     BRA NZ, 0x42FA
2050:                      {
2051:                          case USB_DESCRIPTOR_DEVICE:
2052:                              #if !defined(USB_USER_DEVICE_DESCRIPTOR)
2053:                                  inPipes[0].pSrc.bRom = (const uint8_t*)&device_dsc;
2054:                              #else
2055:                                  inPipes[0].pSrc.bRom = (const uint8_t*)USB_USER_DEVICE_DESCRIPTOR;
0042A8  2B46C0     MOV #0xB46C, W0
0042AA  89BC80     MOV W0, inPipes
2056:                              #endif
2057:                              inPipes[0].wCount.Val = sizeof(device_dsc);
0042AC  200120     MOV #0x12, W0
0042AE  89BCA0     MOV W0, 0x3794
2058:                              break;
0042B0  370026     BRA 0x42FE
2059:                          case USB_DESCRIPTOR_CONFIGURATION:
2060:                              //First perform error case check, to make sure the host is requesting a 
2061:                              //legal descriptor index.  If the request index is illegal, don't do 
2062:                              //anything (so that the default STALL response will be sent).
2063:                              if(SetupPkt.bDscIndex < USB_MAX_NUM_CONFIG_DSC)
0042B2  237A30     MOV #0x37A3, W0
0042B4  E00410     CP0.B [W0]
0042B6  3A000E     BRA NZ, 0x42D4
2064:                              {
2065:                                  #if !defined(USB_USER_CONFIG_DESCRIPTOR)
2066:                                      inPipes[0].pSrc.bRom = *(USB_CD_Ptr+SetupPkt.bDscIndex);
2067:                                  #else
2068:                                      inPipes[0].pSrc.bRom = *(USB_USER_CONFIG_DESCRIPTOR+SetupPkt.bDscIndex);
0042B8  FB8010     ZE [W0], W0
0042BA  400080     ADD W0, W0, W1
0042BC  237900     MOV #0x3790, W0
0042BE  2B5102     MOV #0xB510, W2
0042C0  788862     MOV [W2+W1], [W0]
2069:                                  #endif
2070:              
2071:                                  //This must be loaded using byte addressing.  The source pointer
2072:                                  //  may not be word aligned for the 16 or 32 bit machines resulting
2073:                                  //  in an address error on the dereference.
2074:                                  inPipes[0].wCount.byte.LB = *(inPipes[0].pSrc.bRom+2);
0042C2  780110     MOV [W0], W2
0042C4  4000E4     ADD W0, #0x4, W1
0042C6  904122     MOV.B [W2+2], W2
0042C8  784882     MOV.B W2, [W1]
2075:                                  inPipes[0].wCount.byte.HB = *(inPipes[0].pSrc.bRom+3);
0042CA  780090     MOV [W0], W1
0042CC  400065     ADD W0, #0x5, W0
0042CE  9040B1     MOV.B [W1+3], W1
0042D0  784801     MOV.B W1, [W0]
0042D2  370015     BRA 0x42FE
2076:                              }
2077:              				else
2078:              				{
2079:              					inPipes[0].info.Val = 0;
0042D4  237920     MOV #0x3792, W0
0042D6  EB4800     CLR.B [W0]
0042D8  370012     BRA 0x42FE
2080:              				}
2081:                              break;
2082:                          case USB_DESCRIPTOR_STRING:
2083:                              //USB_NUM_STRING_DESCRIPTORS was introduced as optional in release v2.3.  In v2.4 and
2084:                              //  later it is now mandatory.  This should be defined in usb_config.h and should
2085:                              //  indicate the number of string descriptors.
2086:                              if(SetupPkt.bDscIndex<USB_NUM_STRING_DESCRIPTORS)
0042DA  237A30     MOV #0x37A3, W0
0042DC  B3C021     MOV.B #0x2, W1
0042DE  10CF90     SUBR.B W1, [W0], [W15]
0042E0  3E0009     BRA GTU, 0x42F4
2087:                              {
2088:                                  //Get a pointer to the String descriptor requested
2089:                                  inPipes[0].pSrc.bRom = *(USB_SD_Ptr+SetupPkt.bDscIndex);
0042E2  FB8010     ZE [W0], W0
0042E4  400080     ADD W0, W0, W1
0042E6  237900     MOV #0x3790, W0
0042E8  2B5122     MOV #0xB512, W2
0042EA  788862     MOV [W2+W1], [W0]
2090:                                  // Set data count
2091:                                  inPipes[0].wCount.Val = *inPipes[0].pSrc.bRom;                    
0042EC  780010     MOV [W0], W0
0042EE  FB8010     ZE [W0], W0
0042F0  89BCA0     MOV W0, 0x3794
0042F2  370005     BRA 0x42FE
2092:                              }
2093:                              #if defined(IMPLEMENT_MICROSOFT_OS_DESCRIPTOR)
2094:                              else if(SetupPkt.bDscIndex == MICROSOFT_OS_DESCRIPTOR_INDEX)
2095:                              {
2096:                                  //Get a pointer to the special MS OS string descriptor requested
2097:                                  inPipes[0].pSrc.bRom = (const uint8_t*)&MSOSDescriptor;
2098:                                  // Set data count
2099:                                  inPipes[0].wCount.Val = *inPipes[0].pSrc.bRom;                    
2100:                              }    
2101:                              #endif
2102:                              else
2103:                              {
2104:                                  inPipes[0].info.Val = 0;
0042F4  237920     MOV #0x3792, W0
0042F6  EB4800     CLR.B [W0]
0042F8  370002     BRA 0x42FE
2105:                              }
2106:                              break;
2107:                          default:
2108:                              inPipes[0].info.Val = 0;
0042FA  237920     MOV #0x3792, W0
0042FC  EB4800     CLR.B [W0]
2109:                              break;
2110:                      }//end switch
2111:                  }//end if
2112:              }//end USBStdGetDscHandler
0042FE  060000     RETURN
2113:              
2114:              /********************************************************************
2115:               * Function:        void USBStdGetStatusHandler(void)
2116:               *
2117:               * PreCondition:    None
2118:               *
2119:               * Input:           None
2120:               *
2121:               * Output:          None
2122:               *
2123:               * Side Effects:    None
2124:               *
2125:               * Overview:        This routine handles the standard GET_STATUS request
2126:               *
2127:               * Note:            None
2128:               *******************************************************************/
2129:              static void USBStdGetStatusHandler(void)
2130:              {
2131:                  CtrlTrfData[0] = 0;                 // Initialize content
004300  EB4000     CLR.B W0
004302  237A91     MOV #0x37A9, W1
004304  784880     MOV.B W0, [W1]
2132:                  CtrlTrfData[1] = 0;
004306  E80081     INC W1, W1
004308  784880     MOV.B W0, [W1]
2133:              
2134:                  switch(SetupPkt.Recipient)
00430A  237A10     MOV #0x37A1, W0
00430C  784010     MOV.B [W0], W0
00430E  60407F     AND.B W0, #0x1F, W0
004310  FB8000     ZE W0, W0
004312  500FE1     SUB W0, #0x1, [W15]
004314  32000B     BRA Z, 0x432C
004316  500FE2     SUB W0, #0x2, [W15]
004318  32000C     BRA Z, 0x4332
00431A  E00000     CP0 W0
00431C  3A0024     BRA NZ, 0x4366
2135:                  {
2136:                      case USB_SETUP_RECIPIENT_DEVICE_BITFIELD:
2137:                          inPipes[0].info.bits.busy = 1;
00431E  237920     MOV #0x3792, W0
004320  A07010     BSET [W0], #7
2138:                          /*
2139:                           * [0]: bit0: Self-Powered Status [0] Bus-Powered [1] Self-Powered
2140:                           *      bit1: RemoteWakeup        [0] Disabled    [1] Enabled
2141:                           */
2142:                          if(self_power == 1) // self_power is defined in HardwareProfile.h
2143:                          {
2144:                              CtrlTrfData[0]|=0x01;
2145:                          }
2146:              
2147:                          if(RemoteWakeup == true)
004322  E24853     CP0.B RemoteWakeup
004324  320020     BRA Z, 0x4366
2148:                          {
2149:                              CtrlTrfData[0]|=0x02;
004326  E90001     DEC W1, W0
004328  A01410     BSET.B [W0], #1
00432A  37001D     BRA 0x4366
2150:                          }
2151:                          break;
2152:                      case USB_SETUP_RECIPIENT_INTERFACE_BITFIELD:
2153:                          inPipes[0].info.bits.busy = 1;     // No data to update
00432C  237920     MOV #0x3792, W0
00432E  A07010     BSET [W0], #7
2154:                          break;
004330  37001A     BRA 0x4366
2155:                      case USB_SETUP_RECIPIENT_ENDPOINT_BITFIELD:
2156:                          inPipes[0].info.bits.busy = 1;
004332  237920     MOV #0x3792, W0
004334  A07010     BSET [W0], #7
2157:                          /*
2158:                           * [0]: bit0: Halt Status [0] Not Halted [1] Halted
2159:                           */
2160:                          {
2161:                              BDT_ENTRY *p;
2162:              
2163:                              if(SetupPkt.EPDir == 0)
004336  237A50     MOV #0x37A5, W0
004338  E00410     CP0.B [W0]
00433A  350007     BRA LT, 0x434A
2164:                              {
2165:                                  p = (BDT_ENTRY*)pBDTEntryOut[SetupPkt.EPNum];
00433C  784010     MOV.B [W0], W0
00433E  60406F     AND.B W0, #0xF, W0
004340  FB8000     ZE W0, W0
004342  400000     ADD W0, W0, W0
004344  2085A1     MOV #0x85A, W1
004346  7800E1     MOV [W1+W0], W1
004348  370007     BRA 0x4358
2166:                              }
2167:                              else
2168:                              {
2169:                                  p = (BDT_ENTRY*)pBDTEntryIn[SetupPkt.EPNum];
00434A  237A50     MOV #0x37A5, W0
00434C  784010     MOV.B [W0], W0
00434E  60406F     AND.B W0, #0xF, W0
004350  FB8000     ZE W0, W0
004352  400000     ADD W0, W0, W0
004354  2085E1     MOV #0x85E, W1
004356  7800E1     MOV [W1+W0], W1
2170:                              }
2171:              
2172:                              if((p->STAT.UOWN == 1) && (p->STAT.BSTALL == 1))
004358  284000     MOV #0x8400, W0
00435A  600091     AND W0, [W1], W1
00435C  508F80     SUB W1, W0, [W15]
00435E  3A0003     BRA NZ, 0x4366
2173:                                  CtrlTrfData[0]=0x01;    // Set bit0
004360  B3C011     MOV.B #0x1, W1
004362  237A90     MOV #0x37A9, W0
004364  784801     MOV.B W1, [W0]
2174:                              break;
2175:                          }
2176:                  }//end switch
2177:              
2178:                  if(inPipes[0].info.bits.busy == 1)
004366  81BC90     MOV 0x3792, W0
004368  A37800     BTST.Z W0, #7
00436A  320007     BRA Z, 0x437A
2179:                  {
2180:                      inPipes[0].pSrc.bRam = (uint8_t*)&CtrlTrfData;        // Set Source
00436C  237A90     MOV #0x37A9, W0
00436E  89BC80     MOV W0, inPipes
2181:                      inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;      // Set memory type
004370  237920     MOV #0x3792, W0
004372  A00010     BSET [W0], #0
2182:                      inPipes[0].wCount.v[0] = 2;                           // Set data count
004374  B3C021     MOV.B #0x2, W1
004376  E88000     INC2 W0, W0
004378  784801     MOV.B W1, [W0]
2183:                  }//end if(...)
2184:              }//end USBStdGetStatusHandler
00437A  060000     RETURN
2185:              
2186:              /********************************************************************
2187:               * Function:        void USBStallHandler(void)
2188:               *
2189:               * PreCondition:    None
2190:               *
2191:               * Input:           None
2192:               *
2193:               * Output:          None
2194:               *
2195:               * Side Effects:    
2196:               *
2197:               * Overview:        This function handles the event of a STALL 
2198:               *                  occurring on the bus
2199:               *
2200:               * Note:            None
2201:               *******************************************************************/
2202:              static void USBStallHandler(void)
2203:              {
2204:                  /*
2205:                   * Does not really have to do anything here,
2206:                   * even for the control endpoint.
2207:                   * All BDs of Endpoint 0 are owned by SIE right now,
2208:                   * but once a Setup Transaction is received, the ownership
2209:                   * for EP0_OUT will be returned to CPU.
2210:                   * When the Setup Transaction is serviced, the ownership
2211:                   * for EP0_IN will then be forced back to CPU by firmware.
2212:                   */
2213:              
2214:                  if(U1EP0bits.EPSTALL == 1)
00437C  AB24AA     BTST U1EP0, #1
00437E  320011     BRA Z, 0x43A2
2215:                  {
2216:                      // UOWN - if 0, owned by CPU, if 1, owned by SIE
2217:                      if((pBDTEntryEP0OutCurrent->STAT.Val == _USIE) && (pBDTEntryIn[0]->STAT.Val == (_USIE|_BSTALL)))
004380  804320     MOV pBDTEntryEP0OutCurrent, W0
004382  904110     MOV.B [W0+1], W2
004384  B3C801     MOV.B #0x80, W1
004386  514F81     SUB.B W2, W1, [W15]
004388  3A000B     BRA NZ, 0x43A0
00438A  8042F1     MOV pBDTEntryIn, W1
00438C  904111     MOV.B [W1+1], W2
00438E  B3C841     MOV.B #0x84, W1
004390  514F81     SUB.B W2, W1, [W15]
004392  3A0006     BRA NZ, 0x43A0
2218:                      {
2219:                          // Set ep0Bo to stall also
2220:                          pBDTEntryEP0OutCurrent->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
004394  B3C0C1     MOV.B #0xC, W1
004396  984011     MOV.B W1, [W0+1]
2221:                          pBDTEntryEP0OutCurrent->STAT.Val |= _USIE;
004398  804320     MOV pBDTEntryEP0OutCurrent, W0
00439A  904090     MOV.B [W0+1], W1
00439C  A07401     BSET.B W1, #7
00439E  984011     MOV.B W1, [W0+1]
2222:                      }//end if
2223:                      U1EP0bits.EPSTALL = 0;               // Clear stall status
0043A0  A924AA     BCLR U1EP0, #1
2224:                  }//end if
2225:              
2226:                  USBClearInterruptFlag(USBStallIFReg,USBStallIFBitNum);
0043A2  200800     MOV #0x80, W0
0043A4  882450     MOV W0, U1IR
2227:              }
0043A6  060000     RETURN
2228:              
2229:              /********************************************************************
2230:               * Function:        void USBSuspend(void)
2231:               *
2232:               * PreCondition:    None
2233:               *
2234:               * Input:           None
2235:               *
2236:               * Output:          None
2237:               *
2238:               * Side Effects:    
2239:               *
2240:               * Overview:        This function handles if the host tries to 
2241:               *                  suspend the device
2242:               *
2243:               * Note:            None
2244:               *******************************************************************/
2245:              static void USBSuspend(void)
2246:              {
2247:                  /*
2248:                   * NOTE: Do not clear UIRbits.ACTVIF here!
2249:                   * Reason:
2250:                   * ACTVIF is only generated once an IDLEIF has been generated.
2251:                   * This is a 1:1 ratio interrupt generation.
2252:                   * For every IDLEIF, there will be only one ACTVIF regardless of
2253:                   * the number of subsequent bus transitions.
2254:                   *
2255:                   * If the ACTIF is cleared here, a problem could occur when:
2256:                   * [       IDLE       ][bus activity ->
2257:                   * <--- 3 ms ----->     ^
2258:                   *                ^     ACTVIF=1
2259:                   *                IDLEIF=1
2260:                   *  #           #           #           #   (#=Program polling flags)
2261:                   *                          ^
2262:                   *                          This polling loop will see both
2263:                   *                          IDLEIF=1 and ACTVIF=1.
2264:                   *                          However, the program services IDLEIF first
2265:                   *                          because ACTIVIE=0.
2266:                   *                          If this routine clears the only ACTIVIF,
2267:                   *                          then it can never get out of the suspend
2268:                   *                          mode.
2269:                   */
2270:                  USBActivityIE = 1;                     // Enable bus activity interrupt
00445A  A88482     BSET U1OTGIE, #4
2271:                  USBClearInterruptFlag(USBIdleIFReg,USBIdleIFBitNum);
00445C  200100     MOV #0x10, W0
00445E  882450     MOV W0, U1IR
2272:              
2273:                  #if defined(__18CXX) || defined(_PIC14E) || defined(__XC8)
2274:                      U1CONbits.SUSPND = 1;                   // Put USB module in power conserve
2275:                                                              // mode, SIE clock inactive
2276:                  #endif
2277:                  USBBusIsSuspended = true;
004460  B3C010     MOV.B #0x1, W0
004462  B7E854     MOV.B WREG, USBBusIsSuspended
2278:                  USBTicksSinceSuspendEnd = 0;
004464  EF6859     CLR.B USBTicksSinceSuspendEnd
2279:               
2280:                  /*
2281:                   * At this point the PIC can go into sleep,idle, or
2282:                   * switch to a slower clock, etc.  This should be done in the
2283:                   * USBCBSuspend() if necessary.
2284:                   */
2285:                  USB_SUSPEND_HANDLER(EVENT_SUSPEND,0,0);
004466  EB0100     CLR W2
004468  EB0080     CLR W1
00446A  200750     MOV #0x75, W0
00446C  071ADF     RCALL USER_USB_CALLBACK_EVENT_HANDLER
2286:              }
00446E  060000     RETURN
2287:              
2288:              /********************************************************************
2289:               * Function:        void USBWakeFromSuspend(void)
2290:               *
2291:               * PreCondition:    None
2292:               *
2293:               * Input:           None
2294:               *
2295:               * Output:          None
2296:               *
2297:               * Side Effects:    None
2298:               *
2299:               * Overview:
2300:               *
2301:               * Note:            None
2302:               *******************************************************************/
2303:              static void USBWakeFromSuspend(void)
2304:              {
2305:                  USBBusIsSuspended = false;
004446  EF6854     CLR.B USBBusIsSuspended
2306:              
2307:                  /*
2308:                   * If using clock switching, the place to restore the original
2309:                   * microcontroller core clock frequency is in the USBCBWakeFromSuspend() callback
2310:                   */
2311:                  USB_WAKEUP_FROM_SUSPEND_HANDLER(EVENT_RESUME,0,0);
004448  EB0100     CLR W2
00444A  EB0080     CLR W1
00444C  200740     MOV #0x74, W0
00444E  071AEE     RCALL USER_USB_CALLBACK_EVENT_HANDLER
2312:              
2313:                  #if defined(__18CXX) || defined(_PIC14E) || defined(__XC8)
2314:                      //To avoid improperly clocking the USB module, make sure the oscillator
2315:                      //settings are consistent with USB operation before clearing the SUSPND bit.
2316:                      //Make sure the correct oscillator settings are selected in the 
2317:                      //"USB_WAKEUP_FROM_SUSPEND_HANDLER(EVENT_RESUME,0,0)" handler.
2318:                      U1CONbits.SUSPND = 0;   // Bring USB module out of power conserve
2319:                                              // mode.
2320:                  #endif
2321:              
2322:              
2323:                  USBActivityIE = 0;
004450  A98482     BCLR U1OTGIE, #4
2324:              
2325:                  /********************************************************************
2326:                  Bug Fix: Feb 26, 2007 v2.1
2327:                  *********************************************************************
2328:                  The ACTVIF bit cannot be cleared immediately after the USB module wakes
2329:                  up from Suspend or while the USB module is suspended. A few clock cycles
2330:                  are required to synchronize the internal hardware state machine before
2331:                  the ACTIVIF bit can be cleared by firmware. Clearing the ACTVIF bit
2332:                  before the internal hardware is synchronized may not have an effect on
2333:                  the value of ACTVIF. Additionally, if the USB module uses the clock from
2334:                  the 96 MHz PLL source, then after clearing the SUSPND bit, the USB
2335:                  module may not be immediately operational while waiting for the 96 MHz
2336:                  PLL to lock.
2337:                  ********************************************************************/
2338:              
2339:                  // UIRbits.ACTVIF = 0;                      // Removed
2340:                  #if defined(__18CXX) || defined(__XC8)
2341:                  while(USBActivityIF)
2342:                  #endif
2343:                  {
2344:                      USBClearInterruptFlag(USBActivityIFReg,USBActivityIFBitNum);
004452  200100     MOV #0x10, W0
004454  882400     MOV W0, U1OTGIR
2345:                  }  // Added
2346:              
2347:                  USBTicksSinceSuspendEnd = 0;
004456  EF6859     CLR.B USBTicksSinceSuspendEnd
2348:              
2349:              }//end USBWakeFromSuspend
004458  060000     RETURN
2350:              
2351:              /********************************************************************
2352:               * Function:        void USBCtrlEPService(void)
2353:               *
2354:               * PreCondition:    USTAT is loaded with a valid endpoint address.
2355:               *
2356:               * Input:           None
2357:               *
2358:               * Output:          None
2359:               *
2360:               * Side Effects:    None
2361:               *
2362:               * Overview:        USBCtrlEPService checks for three transaction
2363:               *                  types that it knows how to service and services
2364:               *                  them:
2365:               *                  1. EP0 SETUP
2366:               *                  2. EP0 OUT
2367:               *                  3. EP0 IN
2368:               *                  It ignores all other types (i.e. EP1, EP2, etc.)
2369:               *
2370:               * Note:            None
2371:               *******************************************************************/
2372:              static void USBCtrlEPService(void)
2373:              {
2374:                  //If we get to here, that means a successful transaction has just occurred 
2375:                  //on EP0.  This means "progress" has occurred in the currently pending 
2376:                  //control transfer, so we should re-initialize our timeout counter.
2377:                  #if defined(USB_ENABLE_STATUS_STAGE_TIMEOUTS)
2378:                      USBStatusStageTimeoutCounter = USB_STATUS_STAGE_TIMEOUT;
004B4C  B3C2D0     MOV.B #0x2D, W0
004B4E  B7E86F     MOV.B WREG, USBStatusStageTimeoutCounter
2379:                  #endif
2380:              	
2381:              	//Check if the last transaction was on EP0 OUT endpoint (of any kind, to either the even or odd buffer if ping pong buffers used)
2382:                  if((USTATcopy.Val & USTAT_EP0_PP_MASK) == USTAT_EP0_OUT_EVEN)
004B50  BFC86C     MOV.B USTATcopy, WREG
004B52  B20FB0     AND #0xFB, W0
004B54  3A0016     BRA NZ, 0x4B82
2383:                  {
2384:              		//Point to the EP0 OUT buffer of the buffer that arrived
2385:                      #if defined (_PIC14E) || defined(__18CXX) || defined(__XC8)
2386:                          pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[(USTATcopy.Val & USTAT_EP_MASK)>>1];
2387:                      #elif defined(__C30__) || defined(__C32__) || defined __XC16__
2388:                          pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[(USTATcopy.Val & USTAT_EP_MASK)>>2];
004B56  BFC86C     MOV.B USTATcopy, WREG
004B58  B20FC0     AND #0xFC, W0
004B5A  238001     MOV #0x3800, W1
004B5C  400001     ADD W0, W1, W0
004B5E  884320     MOV W0, pBDTEntryEP0OutCurrent
2389:                      #else
2390:                          #error "unimplemented"
2391:                      #endif
2392:              
2393:              		//Set the next out to the current out packet
2394:                      pBDTEntryEP0OutNext = pBDTEntryEP0OutCurrent;
2395:              		//Toggle it to the next ping pong buffer (if applicable)
2396:                      pBDTEntryEP0OutNext = (volatile BDT_ENTRY*)(((uintptr_t)pBDTEntryEP0OutNext) ^ USB_NEXT_EP0_OUT_PING_PONG);
004B60  780080     MOV W0, W1
004B62  A22001     BTG W1, #2
004B64  884331     MOV W1, pBDTEntryEP0OutNext
2397:              
2398:              		//If the current EP0 OUT buffer has a SETUP packet
2399:                      if(pBDTEntryEP0OutCurrent->STAT.PID == PID_SETUP)
004B66  23C002     MOV #0x3C00, W2
004B68  610110     AND W2, [W0], W2
004B6A  234001     MOV #0x3400, W1
004B6C  510F81     SUB W2, W1, [W15]
004B6E  3A0007     BRA NZ, 0x4B7E
2400:                      {
2401:              	        //The SETUP transaction data may have gone into the the CtrlTrfData 
2402:              	        //buffer, or elsewhere, depending upon how the BDT was prepared
2403:              	        //before the transaction.  Therefore, we should copy the data to the 
2404:              	        //SetupPkt buffer so it can be processed correctly by USBCtrlTrfSetupHandler().		    
2405:                          memcpy((uint8_t*)&SetupPkt, (uint8_t*)ConvertToVirtualAddress(pBDTEntryEP0OutCurrent->ADR), 8);
004B70  900010     MOV [W0+2], W0
004B72  237A11     MOV #0x37A1, W1
004B74  090007     REPEAT #0x7
004B76  7858B0     MOV.B [W0++], [W1++]
004B78  B10080     SUB #0x8, W0
2406:              
2407:              			//Handle the control transfer (parse the 8-byte SETUP command and figure out what to do)
2408:                          USBCtrlTrfSetupHandler();
004B7A  07FFBF     RCALL _USBCtrlTrfSetupHandler
004B7C  370007     BRA 0x4B8C
2409:                      }
2410:                      else
2411:                      {
2412:              			//Handle the DATA transfer
2413:                          USBCtrlTrfOutHandler();
004B7E  07FF32     RCALL _USBCtrlTrfOutHandler
004B80  370005     BRA 0x4B8C
2414:                      }
2415:                  }
2416:                  else if((USTATcopy.Val & USTAT_EP0_PP_MASK) == USTAT_EP0_IN)
004B82  BFC86C     MOV.B USTATcopy, WREG
004B84  B20FB0     AND #0xFB, W0
004B86  500FE8     SUB W0, #0x8, [W15]
004B88  3A0001     BRA NZ, 0x4B8C
2417:                  {
2418:              		//Otherwise the transmission was and EP0 IN
2419:              		//  so take care of the IN transfer
2420:                      USBCtrlTrfInHandler();
004B8A  07FC0E     RCALL _USBCtrlTrfInHandler
2421:                  }
2422:              
2423:              }//end USBCtrlEPService
004B8C  060000     RETURN
2424:              
2425:              /********************************************************************
2426:               * Function:        void USBCtrlTrfSetupHandler(void)
2427:               *
2428:               * PreCondition:    SetupPkt buffer is loaded with valid USB Setup Data
2429:               *
2430:               * Input:           None
2431:               *
2432:               * Output:          None
2433:               *
2434:               * Side Effects:    None
2435:               *
2436:               * Overview:        This routine is a task dispatcher and has 3 stages.
2437:               *                  1. It initializes the control transfer state machine.
2438:               *                  2. It calls on each of the module that may know how to
2439:               *                     service the Setup Request from the host.
2440:               *                     Module Example: USBD, HID, CDC, MSD, ...
2441:               *                     A callback function, USBCBCheckOtherReq(),
2442:               *                     is required to call other module handlers.
2443:               *                  3. Once each of the modules has had a chance to check if
2444:               *                     it is responsible for servicing the request, stage 3
2445:               *                     then checks direction of the transfer to determine how
2446:               *                     to prepare EP0 for the control transfer.
2447:               *                     Refer to USBCtrlEPServiceComplete() for more details.
2448:               *
2449:               * Note:            Microchip USB Firmware has three different states for
2450:               *                  the control transfer state machine:
2451:               *                  1. WAIT_SETUP
2452:               *                  2. CTRL_TRF_TX (device sends data to host through IN transactions)
2453:               *                  3. CTRL_TRF_RX (device receives data from host through OUT transactions)
2454:               *                  Refer to firmware manual to find out how one state
2455:               *                  is transitioned to another.
2456:               *
2457:               *                  A Control Transfer is composed of many USB transactions.
2458:               *                  When transferring data over multiple transactions,
2459:               *                  it is important to keep track of data source, data
2460:               *                  destination, and data count. These three parameters are
2461:               *                  stored in pSrc,pDst, and wCount. A flag is used to
2462:               *                  note if the data source is from const or RAM.
2463:               *
2464:               *******************************************************************/
2465:              static void USBCtrlTrfSetupHandler(void)
2466:              {
2467:                  //--------------------------------------------------------------------------
2468:                  //1. Re-initialize state tracking variables related to control transfers.
2469:                  //--------------------------------------------------------------------------
2470:                  shortPacketStatus = SHORT_PKT_NOT_USED;  
004AFA  EF6868     CLR.B shortPacketStatus
2471:                  USBDeferStatusStagePacket = false;
004AFC  EF6851     CLR.B USBDeferStatusStagePacket
2472:                  USBDeferINDataStagePackets = false;
004AFE  EF6852     CLR.B USBDeferINDataStagePackets
2473:                  USBDeferOUTDataStagePackets = false;
004B00  EF6850     CLR.B USBDeferOUTDataStagePackets
2474:                  BothEP0OutUOWNsSet = false;
004B02  EF686E     CLR.B BothEP0OutUOWNsSet
2475:                  controlTransferState = WAIT_SETUP;
004B04  EF6869     CLR.B controlTransferState
2476:              
2477:                  //Abandon any previous control transfers that might have been using EP0.
2478:                  //Ordinarily, nothing actually needs abandoning, since the previous control
2479:                  //transfer would have completed successfully prior to the host sending the next
2480:                  //SETUP packet.  However, in a timeout error case, or after an EP0 STALL event,
2481:                  //one or more UOWN bits might still be set.  If so, we should clear the UOWN bits,
2482:                  //so the EP0 IN/OUT endpoints are in a known inactive state, ready for re-arming
2483:                  //by the class request handler that will be called next.
2484:                  pBDTEntryIn[0]->STAT.Val &= ~(_USIE);  
004B06  8042F0     MOV pBDTEntryIn, W0
004B08  904090     MOV.B [W0+1], W1
004B0A  A17401     BCLR.B W1, #7
004B0C  984011     MOV.B W1, [W0+1]
2485:                  
2486:                  pBDTEntryIn[0] = (volatile BDT_ENTRY*)(((uintptr_t)pBDTEntryIn[0]) ^ USB_NEXT_EP0_IN_PING_PONG);
004B0E  8042F0     MOV pBDTEntryIn, W0
004B10  A22000     BTG W0, #2
004B12  8842F0     MOV W0, pBDTEntryIn
2487:                  pBDTEntryIn[0]->STAT.Val &= ~(_USIE);      
004B14  904090     MOV.B [W0+1], W1
004B16  A17401     BCLR.B W1, #7
004B18  984011     MOV.B W1, [W0+1]
2488:                  pBDTEntryIn[0] = (volatile BDT_ENTRY*)(((uintptr_t)pBDTEntryIn[0]) ^ USB_NEXT_EP0_IN_PING_PONG);
004B1A  AA485E     BTG pBDTEntryIn, #2
2489:                  pBDTEntryEP0OutNext->STAT.Val &= ~(_USIE);         
004B1C  804330     MOV pBDTEntryEP0OutNext, W0
004B1E  904090     MOV.B [W0+1], W1
004B20  A17401     BCLR.B W1, #7
004B22  984011     MOV.B W1, [W0+1]
2490:              
2491:                  inPipes[0].info.Val = 0;
004B24  EB4000     CLR.B W0
004B26  237921     MOV #0x3792, W1
004B28  784880     MOV.B W0, [W1]
2492:                  inPipes[0].wCount.Val = 0;
004B2A  EB0080     CLR W1
004B2C  89BCA1     MOV W1, 0x3794
2493:                  outPipes[0].info.Val = 0;
004B2E  237982     MOV #0x3798, W2
004B30  784901     MOV.B W1, [W2]
2494:                  outPipes[0].wCount.Val = 0;
004B32  E80082     INC W2, W1
004B34  784111     MOV.B [W1], W2
004B36  784880     MOV.B W0, [W1]
004B38  E80081     INC W1, W1
004B3A  784111     MOV.B [W1], W2
004B3C  784880     MOV.B W0, [W1]
2495:                  
2496:              
2497:                  //--------------------------------------------------------------------------
2498:                  //2. Now find out what was in the SETUP packet, and begin handling the request.
2499:                  //--------------------------------------------------------------------------
2500:                  USBCheckStdRequest();                                               //Check for standard USB "Chapter 9" requests.
004B3E  07FD76     RCALL _USBCheckStdRequest
2501:                  USB_NONSTANDARD_EP0_REQUEST_HANDLER(EVENT_EP0_REQUEST,0,0); //Check for USB device class specific requests
004B40  EB0100     CLR W2
004B42  EB0080     CLR W1
004B44  200030     MOV #0x3, W0
004B46  071772     RCALL USER_USB_CALLBACK_EVENT_HANDLER
2502:              
2503:              
2504:                  //--------------------------------------------------------------------------
2505:                  //3. Re-arm EP0 IN and EP0 OUT endpoints, based on the control transfer in 
2506:                  //   progress.  If one of the above handlers (in step 2) knew how to process
2507:                  //   the request, it will have set one of the inPipes[0].info.bits.busy or
2508:                  //   outPipes[0].info.bits.busy flags = 1.  This lets the
2509:                  //   USBCtrlEPServiceComplete() function know how and which endpoints to 
2510:                  //   arm.  If both info.bits.busy flags are = 0, then no one knew how to
2511:                  //   process the request.  In this case, the default behavior will be to
2512:                  //   perform protocol STALL on EP0.
2513:                  //-------------------------------------------------------------------------- 
2514:                  USBCtrlEPServiceComplete();
004B48  07FF92     RCALL _USBCtrlEPServiceComplete
2515:              }//end USBCtrlTrfSetupHandler
004B4A  060000     RETURN
2516:              
2517:              
2518:              /******************************************************************************
2519:               * Function:        void USBCtrlTrfOutHandler(void)
2520:               *
2521:               * PreCondition:    None
2522:               *
2523:               * Input:           None
2524:               *
2525:               * Output:          None
2526:               *
2527:               * Side Effects:    None
2528:               *
2529:               * Overview:        This routine handles an OUT transaction according to
2530:               *                  which control transfer state is currently active.
2531:               *
2532:               * Note:            Note that if the the control transfer was from
2533:               *                  host to device, the session owner should be notified
2534:               *                  at the end of each OUT transaction to service the
2535:               *                  received data.
2536:               *
2537:               *****************************************************************************/
2538:              static void USBCtrlTrfOutHandler(void)
2539:              {
2540:                  if(controlTransferState == CTRL_TRF_RX)
0049E4  BFC869     MOV.B controlTransferState, WREG
0049E6  504FE2     SUB.B W0, #0x2, [W15]
0049E8  3A0002     BRA NZ, 0x49EE
2541:                  {
2542:                      USBCtrlTrfRxService();	//Copies the newly received data into the appropriate buffer and configures EP0 OUT for next transaction.
0049EA  07FF8C     RCALL _USBCtrlTrfRxService
0049EC  370011     BRA 0x4A10
2543:                  }
2544:                  else //In this case the last OUT transaction must have been a status stage of a CTRL_TRF_TX (<setup><in><in>...<OUT>  <-- this last OUT just occurred as the status stage)
2545:                  {
2546:                      //If the status stage is complete, this means we are done with the 
2547:                      //control transfer.  Go back to the idle "WAIT_SETUP" state.
2548:                      controlTransferState = WAIT_SETUP;
0049EE  EF6869     CLR.B controlTransferState
2549:              
2550:                      //Prepare EP0 OUT for the next SETUP transaction, however, it may have
2551:                      //already been prepared if ping-pong buffering was enabled on EP0 OUT,
2552:                      //and the last control transfer was of direction: device to host, see
2553:                      //USBCtrlEPServiceComplete().  If it was already prepared, do not want
2554:                      //to do anything to the BDT.
2555:                      if(BothEP0OutUOWNsSet == false)
0049F0  E2486E     CP0.B BothEP0OutUOWNsSet
0049F2  3A000D     BRA NZ, 0x4A0E
2556:                      {
2557:                          pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
0049F4  B3C401     MOV.B #0x40, W1
0049F6  804330     MOV pBDTEntryEP0OutNext, W0
0049F8  784801     MOV.B W1, [W0]
2558:                          pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
0049FA  804330     MOV pBDTEntryEP0OutNext, W0
0049FC  237A11     MOV #0x37A1, W1
0049FE  980011     MOV W1, [W0+2]
2559:                          pBDTEntryEP0OutNext->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
004A00  B3C0C1     MOV.B #0xC, W1
004A02  984011     MOV.B W1, [W0+1]
2560:                          pBDTEntryEP0OutNext->STAT.Val |= _USIE;
004A04  804330     MOV pBDTEntryEP0OutNext, W0
004A06  904090     MOV.B [W0+1], W1
004A08  A07401     BSET.B W1, #7
004A0A  984011     MOV.B W1, [W0+1]
004A0C  370001     BRA 0x4A10
2561:                      }
2562:                      else
2563:                      {
2564:                              BothEP0OutUOWNsSet = false;
004A0E  EF686E     CLR.B BothEP0OutUOWNsSet
2565:                      }
2566:                  }
2567:              }
004A10  060000     RETURN
2568:              
2569:              /******************************************************************************
2570:               * Function:        void USBCtrlTrfInHandler(void)
2571:               *
2572:               * PreCondition:    None
2573:               *
2574:               * Input:           None
2575:               *
2576:               * Output:          None
2577:               *
2578:               * Side Effects:    None
2579:               *
2580:               * Overview:        This routine handles an IN transaction according to
2581:               *                  which control transfer state is currently active.
2582:               *
2583:               * Note:            A Set Address Request must not change the actual address
2584:               *                  of the device until the completion of the control
2585:               *                  transfer. The end of the control transfer for Set Address
2586:               *                  Request is an IN transaction. Therefore it is necessary
2587:               *                  to service this unique situation when the condition is
2588:               *                  right. Macro mUSBCheckAdrPendingState is defined in
2589:               *                  usb9.h and its function is to specifically service this
2590:               *                  event.
2591:               *****************************************************************************/
2592:              static void USBCtrlTrfInHandler(void)
2593:              {
0043A8  781F88     MOV W8, [W15++]
2594:                  uint8_t lastDTS;
2595:              
2596:                  lastDTS = pBDTEntryIn[0]->STAT.DTS;
0043AA  8042F0     MOV pBDTEntryIn, W0
0043AC  780410     MOV [W0], W8
0043AE  DE444E     LSR W8, #14, W8
0043B0  644461     AND.B W8, #0x1, W8
2597:              
2598:                  //switch to the next ping pong buffer
2599:                  pBDTEntryIn[0] = (volatile BDT_ENTRY*)(((uintptr_t)pBDTEntryIn[0]) ^ USB_NEXT_EP0_IN_PING_PONG);
0043B2  A22000     BTG W0, #2
0043B4  8842F0     MOV W0, pBDTEntryIn
2600:              
2601:                  //Must check if in ADR_PENDING_STATE.  If so, we need to update the address
2602:                  //now, since the IN status stage of the (set address) control transfer has 
2603:                  //evidently completed successfully.
2604:                  if(USBDeviceState == ADR_PENDING_STATE)
0043B6  8042B0     MOV USBDeviceState, W0
0043B8  500FE8     SUB W0, #0x8, [W15]
0043BA  3A000B     BRA NZ, 0x43D2
2605:                  {
2606:                      U1ADDR = (SetupPkt.bDevADR & 0x7F);
0043BC  237A30     MOV #0x37A3, W0
0043BE  FB8010     ZE [W0], W0
0043C0  B207F0     AND #0x7F, W0
0043C2  8824B0     MOV W0, U1ADDR
2607:                      if(U1ADDR != 0u)
0043C4  E20496     CP0 U1ADDR
0043C6  320003     BRA Z, 0x43CE
2608:                      {
2609:                          USBDeviceState=ADDRESS_STATE;
0043C8  200100     MOV #0x10, W0
0043CA  8842B0     MOV W0, USBDeviceState
0043CC  370002     BRA 0x43D2
2610:                      }
2611:                      else
2612:                      {
2613:                          USBDeviceState=DEFAULT_STATE;
0043CE  200040     MOV #0x4, W0
0043D0  8842B0     MOV W0, USBDeviceState
2614:                      }
2615:                  }//end if
2616:              
2617:              
2618:                  if(controlTransferState == CTRL_TRF_TX)
0043D2  BFC869     MOV.B controlTransferState, WREG
0043D4  504FE1     SUB.B W0, #0x1, [W15]
0043D6  3A0021     BRA NZ, 0x441A
2619:                  {
2620:                      pBDTEntryIn[0]->ADR = ConvertToPhysicalAddress(CtrlTrfData);
0043D8  237A91     MOV #0x37A9, W1
0043DA  8042F0     MOV pBDTEntryIn, W0
0043DC  980011     MOV W1, [W0+2]
2621:                      USBCtrlTrfTxService();
0043DE  07FF21     RCALL _USBCtrlTrfTxService
2622:              
2623:                      //Check if we have already sent a short packet.  If so, configure
2624:                      //the endpoint to STALL in response to any further IN tokens (in the
2625:                      //case that the host erroneously tries to receive more data than it
2626:                      //should).
2627:                      if(shortPacketStatus == SHORT_PKT_SENT)
0043E0  BFC868     MOV.B shortPacketStatus, WREG
0043E2  504FE2     SUB.B W0, #0x2, [W15]
0043E4  3A0008     BRA NZ, 0x43F6
2628:                      {
2629:                          // If a short packet has been sent, don't want to send any more,
2630:                          // stall next time if host is still trying to read.
2631:                          pBDTEntryIn[0]->STAT.Val = _BSTALL;
0043E6  B3C041     MOV.B #0x4, W1
0043E8  8042F0     MOV pBDTEntryIn, W0
0043EA  984011     MOV.B W1, [W0+1]
2632:                          pBDTEntryIn[0]->STAT.Val |= _USIE;
0043EC  8042F0     MOV pBDTEntryIn, W0
0043EE  904090     MOV.B [W0+1], W1
0043F0  A07401     BSET.B W1, #7
0043F2  984011     MOV.B W1, [W0+1]
0043F4  370026     BRA 0x4442
2633:                      }
2634:                      else
2635:                      {
2636:                          if(lastDTS == 0)
0043F6  E00408     CP0.B W8
0043F8  3A0008     BRA NZ, 0x440A
2637:                          {
2638:                              pBDTEntryIn[0]->STAT.Val = _DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
0043FA  B3C481     MOV.B #0x48, W1
0043FC  8042F0     MOV pBDTEntryIn, W0
0043FE  984011     MOV.B W1, [W0+1]
2639:                              pBDTEntryIn[0]->STAT.Val |= _USIE;
004400  8042F0     MOV pBDTEntryIn, W0
004402  904090     MOV.B [W0+1], W1
004404  A07401     BSET.B W1, #7
004406  984011     MOV.B W1, [W0+1]
004408  37001C     BRA 0x4442
2640:                          }
2641:                          else
2642:                          {
2643:                              pBDTEntryIn[0]->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED);
00440A  B3C081     MOV.B #0x8, W1
00440C  8042F0     MOV pBDTEntryIn, W0
00440E  984011     MOV.B W1, [W0+1]
2644:                              pBDTEntryIn[0]->STAT.Val |= _USIE;
004410  8042F0     MOV pBDTEntryIn, W0
004412  904090     MOV.B [W0+1], W1
004414  A07401     BSET.B W1, #7
004416  984011     MOV.B W1, [W0+1]
004418  370014     BRA 0x4442
2645:                          }
2646:                      }//end if(...)else
2647:                  }
2648:              	else // must have been a CTRL_TRF_RX status stage IN packet (<setup><out><out>...<IN>  <-- this last IN just occurred as the status stage)
2649:              	{
2650:                      //if someone is still expecting data from the control transfer
2651:                      //  then make sure to terminate that request and let them know that
2652:                      //  they are done
2653:                      if(outPipes[0].info.bits.busy == 1)
00441A  237980     MOV #0x3798, W0
00441C  E00410     CP0.B [W0]
00441E  3D0010     BRA GE, 0x4440
2654:                      {
2655:                          if(outPipes[0].pFunc != NULL)
004420  400063     ADD W0, #0x3, W0
004422  FB8090     ZE [W0], W1
004424  E80000     INC W0, W0
004426  FB8010     ZE [W0], W0
004428  DD0048     SL W0, #8, W0
00442A  708000     IOR W1, W0, W0
00442C  320007     BRA Z, 0x443C
2656:                          {
2657:                              outPipes[0].pFunc();
00442E  2379B0     MOV #0x379B, W0
004430  FB8090     ZE [W0], W1
004432  E80000     INC W0, W0
004434  FB8010     ZE [W0], W0
004436  DD0048     SL W0, #8, W0
004438  708000     IOR W1, W0, W0
00443A  010000     CALL W0
2658:                          }
2659:                          outPipes[0].info.bits.busy = 0;
00443C  237980     MOV #0x3798, W0
00443E  A17410     BCLR.B [W0], #7
2660:                      }
2661:                  	
2662:                      controlTransferState = WAIT_SETUP;
004440  EF6869     CLR.B controlTransferState
2663:                      //Don't need to arm EP0 OUT here.  It was already armed by the last <out> that
2664:                      //got processed by the USBCtrlTrfRxService() handler.
2665:              	}	
2666:              
2667:              }
004442  78044F     MOV [--W15], W8
004444  060000     RETURN
2668:              
2669:              
2670:              /********************************************************************
2671:               * Function:        void USBCheckStdRequest(void)
2672:               *
2673:               * PreCondition:    None
2674:               *
2675:               * Input:           None
2676:               *
2677:               * Output:          None
2678:               *
2679:               * Side Effects:    None
2680:               *
2681:               * Overview:        This routine checks the setup data packet to see
2682:               *                  if it knows how to handle it
2683:               *
2684:               * Note:            None
2685:               *******************************************************************/
2686:              static void USBCheckStdRequest(void)
2687:              {
2688:                  if(SetupPkt.RequestType != USB_SETUP_TYPE_STANDARD_BITFIELD) return;
00462C  237A10     MOV #0x37A1, W0
00462E  B3C601     MOV.B #0x60, W1
004630  60C010     AND.B W1, [W0], W0
004632  3A0041     BRA NZ, 0x46B6
2689:              
2690:                  switch(SetupPkt.bRequest)
004634  237A20     MOV #0x37A2, W0
004636  FB8010     ZE [W0], W0
004638  EB0080     CLR W1
00463A  500FEB     SUB W0, #0xB, [W15]
00463C  588FE0     SUBB W1, #0x0, [W15]
00463E  3E003B     BRA GTU, 0x46B6
004640  016000     BRA W0
004642  37001D     BRA 0x467E
004644  37001E     BRA 0x4682
004646  370037     BRA 0x46B6
004648  37001C     BRA 0x4682
00464A  370035     BRA 0x46B6
00464C  370006     BRA 0x465A
00464E  37000A     BRA 0x4664
004650  37002E     BRA 0x46AE
004652  37000C     BRA 0x466C
004654  370009     BRA 0x4668
004656  370017     BRA 0x4686
004658  370022     BRA 0x469E
2691:                  {
2692:                      case USB_REQUEST_SET_ADDRESS:
2693:                          inPipes[0].info.bits.busy = 1;            // This will generate a zero length packet
00465A  237920     MOV #0x3792, W0
00465C  A07010     BSET [W0], #7
2694:                          USBDeviceState = ADR_PENDING_STATE;       // Update state only
00465E  200080     MOV #0x8, W0
004660  8842B0     MOV W0, USBDeviceState
2695:                          /* See USBCtrlTrfInHandler() for the next step */
2696:                          break;
004662  370029     BRA 0x46B6
2697:                      case USB_REQUEST_GET_DESCRIPTOR:
2698:                          USBStdGetDscHandler();
004664  07FE12     RCALL _USBStdGetDscHandler
2699:                          break;
004666  370027     BRA 0x46B6
2700:                      case USB_REQUEST_SET_CONFIGURATION:
2701:                          USBStdSetCfgHandler();
004668  07FFB7     RCALL _USBStdSetCfgHandler
2702:                          break;
00466A  370025     BRA 0x46B6
2703:                      case USB_REQUEST_GET_CONFIGURATION:
2704:                          inPipes[0].pSrc.bRam = (uint8_t*)&USBActiveConfiguration;         // Set Source
00466C  208580     MOV #0x858, W0
00466E  89BC80     MOV W0, inPipes
2705:                          inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;               // Set memory type
004670  237920     MOV #0x3792, W0
004672  A00010     BSET [W0], #0
2706:                          inPipes[0].wCount.v[0] = 1;                         // Set data count
004674  B3C012     MOV.B #0x1, W2
004676  E88080     INC2 W0, W1
004678  784882     MOV.B W2, [W1]
2707:                          inPipes[0].info.bits.busy = 1;
00467A  A07010     BSET [W0], #7
2708:                          break;
00467C  37001C     BRA 0x46B6
2709:                      case USB_REQUEST_GET_STATUS:
2710:                          USBStdGetStatusHandler();
00467E  07FE40     RCALL _USBStdGetStatusHandler
2711:                          break;
004680  37001A     BRA 0x46B6
2712:                      case USB_REQUEST_CLEAR_FEATURE:
2713:                      case USB_REQUEST_SET_FEATURE:
2714:                          USBStdFeatureReqHandler();
004682  07FEF6     RCALL _USBStdFeatureReqHandler
2715:                          break;
004684  370018     BRA 0x46B6
2716:                      case USB_REQUEST_GET_INTERFACE:
2717:                          inPipes[0].pSrc.bRam = (uint8_t*)&USBAlternateInterface[SetupPkt.bIntfID];  // Set source
004686  237A50     MOV #0x37A5, W0
004688  FB8090     ZE [W0], W1
00468A  237900     MOV #0x3790, W0
00468C  208622     MOV #0x862, W2
00468E  410801     ADD W2, W1, [W0]
2718:                          inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;               // Set memory type
004690  E88000     INC2 W0, W0
004692  A00010     BSET [W0], #0
2719:                          inPipes[0].wCount.v[0] = 1;                         // Set data count
004694  B3C012     MOV.B #0x1, W2
004696  E88080     INC2 W0, W1
004698  784882     MOV.B W2, [W1]
2720:                          inPipes[0].info.bits.busy = 1;
00469A  A07010     BSET [W0], #7
2721:                          break;
00469C  37000C     BRA 0x46B6
2722:                      case USB_REQUEST_SET_INTERFACE:
2723:                          inPipes[0].info.bits.busy = 1;
00469E  237920     MOV #0x3792, W0
0046A0  A07010     BSET [W0], #7
2724:                          USBAlternateInterface[SetupPkt.bIntfID] = SetupPkt.bAltID;
0046A2  237A50     MOV #0x37A5, W0
0046A4  FB8010     ZE [W0], W0
0046A6  208621     MOV #0x862, W1
0046A8  237A32     MOV #0x37A3, W2
0046AA  787092     MOV.B [W2], [W1+W0]
2725:                          break;
0046AC  370004     BRA 0x46B6
2726:                      case USB_REQUEST_SET_DESCRIPTOR:
2727:                          USB_SET_DESCRIPTOR_HANDLER(EVENT_SET_DESCRIPTOR,0,0);
0046AE  EB0100     CLR W2
0046B0  EB0080     CLR W1
0046B2  200020     MOV #0x2, W0
0046B4  0719BB     RCALL USER_USB_CALLBACK_EVENT_HANDLER
2728:                          break;
2729:                      case USB_REQUEST_SYNCH_FRAME:
2730:                      default:
2731:                          break;
2732:                  }//end switch
2733:              }//end USBCheckStdRequest
0046B6  060000     RETURN
2734:              
2735:              /********************************************************************
2736:               * Function:        void USBStdFeatureReqHandler(void)
2737:               *
2738:               * PreCondition:    None
2739:               *
2740:               * Input:           None
2741:               *
2742:               * Output:          Can alter BDT entries.  Can also modify USB stack
2743:               *                  Maintained variables.
2744:               *
2745:               * Side Effects:    None
2746:               *
2747:               * Overview:        This routine handles the standard SET & CLEAR
2748:               *                  FEATURES requests
2749:               *
2750:               * Note:            This is a private function, intended for internal 
2751:               *                  use by the USB stack, when processing SET/CLEAR
2752:               *                  feature requests.  
2753:               *******************************************************************/
2754:              static void USBStdFeatureReqHandler(void)
2755:              {
004470  BE9F88     MOV.D W8, [W15++]
2756:                  BDT_ENTRY *p;
2757:                  EP_STATUS current_ep_data;
2758:                  #if defined(__C32__)
2759:                      uint32_t* pUEP;
2760:                  #else
2761:                      unsigned char* pUEP;             
2762:                  #endif
2763:                  
2764:              
2765:                  #ifdef	USB_SUPPORT_OTG
2766:                  //Check for USB On-The-Go (OTG) specific requests
2767:                  if ((SetupPkt.bFeature == OTG_FEATURE_B_HNP_ENABLE)&&
2768:                      (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
2769:                  {  
2770:                      inPipes[0].info.bits.busy = 1;
2771:                      if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
2772:                          USBOTGEnableHnp();
2773:                      else
2774:                          USBOTGDisableHnp();
2775:                  }
2776:              
2777:                  if ((SetupPkt.bFeature == OTG_FEATURE_A_HNP_SUPPORT)&&
2778:                      (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
2779:                  {
2780:                      inPipes[0].info.bits.busy = 1;
2781:                      if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
2782:                          USBOTGEnableSupportHnp();
2783:                      else
2784:                          USBOTGDisableSupportHnp();
2785:                  }
2786:              
2787:                  if ((SetupPkt.bFeature == OTG_FEATURE_A_ALT_HNP_SUPPORT)&&
2788:                      (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
2789:                  {
2790:                      inPipes[0].info.bits.busy = 1;
2791:                      if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
2792:                          USBOTGEnableAltHnp();
2793:                      else
2794:                          USBOTGDisableAltHnp();
2795:                  }
2796:                  #endif   //#ifdef USB_SUPPORT_OTG 
2797:              
2798:                  //Check if the host sent a valid SET or CLEAR feature (remote wakeup) request.
2799:                  if((SetupPkt.bFeature == USB_FEATURE_DEVICE_REMOTE_WAKEUP)&&
004472  237A30     MOV #0x37A3, W0
004474  B3C011     MOV.B #0x1, W1
004476  10CF90     SUBR.B W1, [W0], [W15]
004478  3A000E     BRA NZ, 0x4496
004480  3A000A     BRA NZ, 0x4496
2800:                     (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
00447A  E98000     DEC2 W0, W0
00447C  784010     MOV.B [W0], W0
00447E  60407F     AND.B W0, #0x1F, W0
2801:                  {
2802:                      inPipes[0].info.bits.busy = 1;
004482  237920     MOV #0x3792, W0
004484  A07010     BSET [W0], #7
2803:                      if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
004486  237A20     MOV #0x37A2, W0
004488  B3C032     MOV.B #0x3, W2
00448A  114F90     SUBR.B W2, [W0], [W15]
00448C  3A0003     BRA NZ, 0x4494
2804:                          RemoteWakeup = true;
00448E  784001     MOV.B W1, W0
004490  B7E853     MOV.B WREG, RemoteWakeup
004492  370001     BRA 0x4496
2805:                      else
2806:                          RemoteWakeup = false;
004494  EF6853     CLR.B RemoteWakeup
2807:                  }//end if
2808:              
2809:                  //Check if the host sent a valid SET or CLEAR endpoint halt request.
2810:                  if((SetupPkt.bFeature == USB_FEATURE_ENDPOINT_HALT)&&
004496  237A30     MOV #0x37A3, W0
004498  E00410     CP0.B [W0]
00449A  3A009C     BRA NZ, 0x45D4
0044A2  504FE2     SUB.B W0, #0x2, [W15]
0044A4  3A0097     BRA NZ, 0x45D4
2811:                     (SetupPkt.Recipient == USB_SETUP_RECIPIENT_ENDPOINT_BITFIELD)&&
00449C  E98000     DEC2 W0, W0
00449E  784010     MOV.B [W0], W0
0044A0  60407F     AND.B W0, #0x1F, W0
0044AC  320093     BRA Z, 0x45D4
2812:                     (SetupPkt.EPNum != 0) && (SetupPkt.EPNum <= USB_MAX_EP_NUMBER)&&
0044A6  237A50     MOV #0x37A5, W0
0044A8  784010     MOV.B [W0], W0
0044AA  60406F     AND.B W0, #0xF, W0
0044AE  237A50     MOV #0x37A5, W0
0044B0  784010     MOV.B [W0], W0
0044B2  60406F     AND.B W0, #0xF, W0
0044B4  FB8000     ZE W0, W0
0044B6  500FE1     SUB W0, #0x1, [W15]
0044B8  3C008D     BRA GT, 0x45D4
0044BA  200200     MOV #0x20, W0
0044BC  E30856     CP USBDeviceState
0044BE  3A008A     BRA NZ, 0x45D4
2813:                     (USBDeviceState == CONFIGURED_STATE))
2814:                  {
2815:              		//The request was valid.  Take control of the control transfer and
2816:              		//perform the host requested action.
2817:              		inPipes[0].info.bits.busy = 1;
0044C0  237920     MOV #0x3792, W0
0044C2  A07010     BSET [W0], #7
2818:              
2819:                      //Fetch a pointer to the BDT that the host wants to SET/CLEAR halt on.
2820:                      if(SetupPkt.EPDir == OUT_FROM_HOST)
0044C4  237A50     MOV #0x37A5, W0
0044C6  E00410     CP0.B [W0]
0044C8  35000C     BRA LT, 0x44E2
2821:                      {
2822:                          p = (BDT_ENTRY*)pBDTEntryOut[SetupPkt.EPNum];
0044CA  784110     MOV.B [W0], W2
0044CC  6140EF     AND.B W2, #0xF, W1
0044CE  FB8081     ZE W1, W1
0044D0  408081     ADD W1, W1, W1
0044D2  2085A2     MOV #0x85A, W2
0044D4  788462     MOV [W2+W1], W8
2823:                          current_ep_data.Val = ep_data_out[SetupPkt.EPNum].Val;
0044D6  784010     MOV.B [W0], W0
0044D8  60406F     AND.B W0, #0xF, W0
0044DA  FB8000     ZE W0, W0
0044DC  2379F1     MOV #0x379F, W1
0044DE  7844E1     MOV.B [W1+W0], W9
0044E0  37000C     BRA 0x44FA
2824:                      }
2825:                      else
2826:                      {
2827:                          p = (BDT_ENTRY*)pBDTEntryIn[SetupPkt.EPNum];
0044E2  237A50     MOV #0x37A5, W0
0044E4  784110     MOV.B [W0], W2
0044E6  6140EF     AND.B W2, #0xF, W1
0044E8  FB8081     ZE W1, W1
0044EA  408081     ADD W1, W1, W1
0044EC  2085E2     MOV #0x85E, W2
0044EE  788462     MOV [W2+W1], W8
2828:                          current_ep_data.Val = ep_data_in[SetupPkt.EPNum].Val;
0044F0  784010     MOV.B [W0], W0
0044F2  60406F     AND.B W0, #0xF, W0
0044F4  FB8000     ZE W0, W0
0044F6  2379D1     MOV #0x379D, W1
0044F8  7844E1     MOV.B [W1+W0], W9
2829:                      }
2830:              
2831:                      //If ping pong buffering is enabled on the requested endpoint, need 
2832:                      //to point to the one that is the active BDT entry which the SIE will 
2833:                      //use for the next attempted transaction on that EP number.
2834:                      #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)   
2835:                          if(current_ep_data.bits.ping_pong_state == 0) //Check if even
0044FA  A30809     BTST.Z W9, #0
0044FC  3A0002     BRA NZ, 0x4502
2836:                          {
2837:                              p = (BDT_ENTRY*)(((uintptr_t)p) & (~USB_NEXT_PING_PONG));
0044FE  A12008     BCLR W8, #2
004500  370001     BRA 0x4504
2838:                          }
2839:                          else //else must have been odd
2840:                          {
2841:                              p = (BDT_ENTRY*)(((uintptr_t)p) | USB_NEXT_PING_PONG);
004502  A02008     BSET W8, #2
2842:                          }
2843:                      #endif
2844:                      
2845:                      //Update the BDT pointers with the new, next entry based on the feature
2846:                      //  request
2847:                      if(SetupPkt.EPDir == OUT_FROM_HOST)
004504  237A50     MOV #0x37A5, W0
004506  E00410     CP0.B [W0]
004508  350007     BRA LT, 0x4518
2848:                      {
2849:                          pBDTEntryOut[SetupPkt.EPNum] = (volatile BDT_ENTRY *)p;
00450A  784010     MOV.B [W0], W0
00450C  60406F     AND.B W0, #0xF, W0
00450E  FB8000     ZE W0, W0
004510  400000     ADD W0, W0, W0
004512  2085A1     MOV #0x85A, W1
004514  783088     MOV W8, [W1+W0]
004516  370007     BRA 0x4526
2850:                      }
2851:                      else
2852:                      {
2853:                          pBDTEntryIn[SetupPkt.EPNum] = (volatile BDT_ENTRY *)p;
004518  237A50     MOV #0x37A5, W0
00451A  784010     MOV.B [W0], W0
00451C  60406F     AND.B W0, #0xF, W0
00451E  FB8000     ZE W0, W0
004520  400000     ADD W0, W0, W0
004522  2085E1     MOV #0x85E, W1
004524  783088     MOV W8, [W1+W0]
2854:                      }
2855:              
2856:              		//Check if it was a SET_FEATURE endpoint halt request
2857:                      if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
004526  237A20     MOV #0x37A2, W0
004528  B3C031     MOV.B #0x3, W1
00452A  10CF90     SUBR.B W1, [W0], [W15]
00452C  3A001A     BRA NZ, 0x4562
2858:                      {
2859:                          if(p->STAT.UOWN == 1)
00452E  E00018     CP0 [W8]
004530  3D0013     BRA GE, 0x4558
2860:                          {
2861:                              //Mark that we are terminating this transfer and that the user
2862:                              //  needs to be notified later
2863:                              if(SetupPkt.EPDir == OUT_FROM_HOST)
004532  400063     ADD W0, #0x3, W0
004534  E00410     CP0.B [W0]
004536  350008     BRA LT, 0x4548
2864:                              {
2865:                                  ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 1;
004538  784010     MOV.B [W0], W0
00453A  60406F     AND.B W0, #0xF, W0
00453C  FB8000     ZE W0, W0
00453E  2379F1     MOV #0x379F, W1
004540  784161     MOV.B [W1+W0], W2
004542  A01402     BSET.B W2, #1
004544  787082     MOV.B W2, [W1+W0]
004546  370008     BRA 0x4558
2866:                              }
2867:                              else
2868:                              {
2869:                                  ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 1;
004548  237A50     MOV #0x37A5, W0
00454A  784010     MOV.B [W0], W0
00454C  60406F     AND.B W0, #0xF, W0
00454E  FB8000     ZE W0, W0
004550  2379D1     MOV #0x379D, W1
004552  784161     MOV.B [W1+W0], W2
004554  A01402     BSET.B W2, #1
004556  787082     MOV.B W2, [W1+W0]
2870:                              }
2871:                          }
2872:              
2873:              			//Then STALL the endpoint
2874:                          p->STAT.Val |= _BSTALL;
2875:                          p->STAT.Val |= _USIE;
004558  904098     MOV.B [W8+1], W1
00455A  B3C840     MOV.B #0x84, W0
00455C  70C000     IOR.B W1, W0, W0
00455E  984410     MOV.B W0, [W8+1]
004560  370039     BRA 0x45D4
2876:                      }//if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
2877:                      else
2878:                      {
2879:              			//Else the request must have been a CLEAR_FEATURE endpoint halt.
2880:                          #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)   
2881:                              //toggle over the to the non-active BDT
2882:                              p = (BDT_ENTRY*)(((uintptr_t)p) ^ USB_NEXT_PING_PONG);  
004562  780088     MOV W8, W1
004564  A22001     BTG W1, #2
2883:              
2884:                              if(p->STAT.UOWN == 1)
004566  E00011     CP0 [W1]
004568  3D0008     BRA GE, 0x457A
2885:                              {
2886:                                  //Clear UOWN and set DTS state so it will be correct the next time
2887:                                  //the application firmware uses USBTransferOnePacket() on the EP.
2888:                                  p->STAT.Val &= (~_USIE);    //Clear UOWN bit
00456A  904011     MOV.B [W1+1], W0
00456C  A17400     BCLR.B W0, #7
2889:                                  p->STAT.Val |= _DAT1;       //Set DTS to DATA1
00456E  A06400     BSET.B W0, #6
004570  984090     MOV.B W0, [W1+1]
2890:                                  USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p));
004572  200022     MOV #0x2, W2
004574  200050     MOV #0x5, W0
004576  071A5A     RCALL USER_USB_CALLBACK_EVENT_HANDLER
004578  370003     BRA 0x4580
2891:                              }
2892:                              else
2893:                              {
2894:                                  //UOWN already clear, but still need to set DTS to DATA1     
2895:              					p->STAT.Val |= _DAT1;
00457A  904011     MOV.B [W1+1], W0
00457C  A06400     BSET.B W0, #6
00457E  984090     MOV.B W0, [W1+1]
2896:                              }
2897:              
2898:                              //toggle back to the active BDT (the one the SIE is currently looking at
2899:                              //and will use for the next successful transaction to take place on the EP
2900:                              p = (BDT_ENTRY*)(((uintptr_t)p) ^ USB_NEXT_PING_PONG);
2901:                              
2902:                              //Check if we are currently terminating, or have previously terminated
2903:                              //a transaction on the given endpoint.  If so, need to clear UOWN,
2904:                              //set DTS to the proper state, and call the application callback
2905:                              //function.
2906:                              if((current_ep_data.bits.transfer_terminated != 0) || (p->STAT.UOWN == 1))
004580  A31809     BTST.Z W9, #1
004582  3A0002     BRA NZ, 0x4588
004584  E00018     CP0 [W8]
004586  3D001B     BRA GE, 0x45BE
2907:                              {
2908:                                  if(SetupPkt.EPDir == OUT_FROM_HOST)
004588  237A50     MOV #0x37A5, W0
00458A  E00410     CP0.B [W0]
00458C  350008     BRA LT, 0x459E
2909:                                  {
2910:                                      ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 0;
00458E  784010     MOV.B [W0], W0
004590  60406F     AND.B W0, #0xF, W0
004592  FB8000     ZE W0, W0
004594  2379F1     MOV #0x379F, W1
004596  784161     MOV.B [W1+W0], W2
004598  A11402     BCLR.B W2, #1
00459A  787082     MOV.B W2, [W1+W0]
00459C  370008     BRA 0x45AE
2911:                                  }
2912:                                  else
2913:                                  {
2914:                                      ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 0;
00459E  237A50     MOV #0x37A5, W0
0045A0  784010     MOV.B [W0], W0
0045A2  60406F     AND.B W0, #0xF, W0
0045A4  FB8000     ZE W0, W0
0045A6  2379D1     MOV #0x379D, W1
0045A8  784161     MOV.B [W1+W0], W2
0045AA  A11402     BCLR.B W2, #1
0045AC  787082     MOV.B W2, [W1+W0]
2915:                                  }
2916:                                  //clear UOWN, clear DTS to DATA0, and finally remove the STALL condition     
2917:                                  p->STAT.Val &= ~(_USIE | _DAT1 | _BSTALL);  
0045AE  904018     MOV.B [W8+1], W0
0045B0  B243B0     AND.B #0x3B, W0
0045B2  984410     MOV.B W0, [W8+1]
2918:                                  //Call the application event handler callback function, so it can 
2919:              					//decide if the endpoint should get re-armed again or not.
2920:                                  USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p));
0045B4  200022     MOV #0x2, W2
0045B6  780088     MOV W8, W1
0045B8  200050     MOV #0x5, W0
0045BA  071A38     RCALL USER_USB_CALLBACK_EVENT_HANDLER
0045BC  370003     BRA 0x45C4
2921:                              }
2922:                              else
2923:                              {
2924:                                  //clear UOWN, clear DTS to DATA0, and finally remove the STALL condition     
2925:                                  p->STAT.Val &= ~(_USIE | _DAT1 | _BSTALL); 
0045BE  904018     MOV.B [W8+1], W0
0045C0  B243B0     AND.B #0x3B, W0
0045C2  984410     MOV.B W0, [W8+1]
2926:                              } 
2927:                          #else //else we must not be using ping-pong buffering on the requested endpoint
2928:                              //Check if we need to call the user transfer terminated event callback function.
2929:                              //We should call the callback, if the endpoint was previously terminated,
2930:                              //or the endpoint is currently armed, and the host is performing clear
2931:                              //endpoint halt, even though the endpoint wasn't stalled.
2932:                              if((current_ep_data.bits.transfer_terminated != 0) || (p->STAT.UOWN == 1))
2933:                              {
2934:                                  //We are going to call the user transfer terminated callback.
2935:                                  //Clear the flag so we know we took care of it and don't need
2936:                                  //to call it again later.
2937:                                  if(SetupPkt.EPDir == OUT_FROM_HOST)
2938:                                  {
2939:                                      ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 0;
2940:                                  }
2941:                                  else
2942:                                  {
2943:                                      ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 0;
2944:                                  }
2945:               
2946:                                  //Clear UOWN and remove the STALL condition.   
2947:                                  //  In this case we also need to set the DTS bit to 1 so that
2948:                                  //  it toggles to DATA0 the next time the application firmware
2949:                                  //  calls USBTransferOnePacket() (or equivalent macro).  
2950:                                  p->STAT.Val &= ~(_USIE | _BSTALL);  
2951:                                  p->STAT.Val |= _DAT1;
2952:                                  //Let the application firmware know a transaction just
2953:                                  //got terminated by the host, and that it is now free to
2954:                                  //re-arm the endpoint or do other tasks if desired.                                        
2955:                                  USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p));
2956:                              }
2957:                              else
2958:                              {
2959:                                  //Clear UOWN and remove the STALL condition.   
2960:                                  //  In this case we also need to set the DTS bit to 1 so that
2961:                                  //  it toggles to DATA0 the next time the application firmware
2962:                                  //  calls USBTransferOnePacket() (or equivalent macro).  
2963:                                  p->STAT.Val &= ~(_USIE | _BSTALL);  
2964:                                  p->STAT.Val |= _DAT1;
2965:                              } 
2966:                          #endif //end of #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)   
2967:                          
2968:              			//Get a pointer to the appropriate UEPn register
2969:                          #if defined(__C32__)
2970:                              pUEP = (uint32_t*)(&U1EP0);
2971:                              pUEP += (SetupPkt.EPNum*4);
2972:                          #else
2973:                              pUEP = (unsigned char*)(&U1EP0+SetupPkt.EPNum);
0045C4  237A50     MOV #0x37A5, W0
0045C6  784010     MOV.B [W0], W0
0045C8  60406F     AND.B W0, #0xF, W0
0045CA  FB8000     ZE W0, W0
0045CC  400000     ADD W0, W0, W0
0045CE  204AA1     MOV #0x4AA, W1
0045D0  400001     ADD W0, W1, W0
2974:                          #endif
2975:              
2976:              			//Clear the STALL bit in the UEP register
2977:                          *pUEP &= ~UEP_STALL;            
0045D2  A11410     BCLR.B [W0], #1
2978:                      }//end if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
2979:                  }//end if (lots of checks for set/clear endpoint halt)
2980:              }//end USBStdFeatureReqHandler
0045D4  BE044F     MOV.D [--W15], W8
0045D6  060000     RETURN
2981:              
2982:              
2983:              
2984:              
2985:              /**************************************************************************
2986:                  Function:
2987:                      void USBIncrement1msInternalTimers(void)
2988:              
2989:                  Description:
2990:                      This function increments internal 1ms time base counters, which are
2991:                      useful for application code (that can use a 1ms time base/counter), and
2992:                      for certain USB event timing specific purposes.
2993:              
2994:                      In USB full speed applications, the application code does not need to (and should
2995:                      not) explicitly call this function, as the USBDeviceTasks() function will
2996:                      automatically call this function whenever a 1ms time interval has elapsed
2997:                      (assuming the code is calling USBDeviceTasks() frequently enough in USB_POLLING
2998:                      mode, or that USB interrupts aren't being masked for more than 1ms at a time
2999:                      in USB_INTERRUPT mode).
3000:              
3001:                      In USB low speed applications, the application firmware is responsible for
3002:                      periodically calling this function at a ~1ms rate.  This can be done using
3003:                      a general purpose microcontroller timer set to interrupt every 1ms for example.
3004:                      If the low speed application code does not call this function, the internal timers
3005:                      will not increment, and the USBGet1msTickCount() API function will not be available.
3006:                      Additionally, certain USB stack operations (like control transfer timeouts)
3007:                      may be unavailable.
3008:              
3009:                  Precondition:
3010:                      This function should be called only after USBDeviceInit() has been
3011:                      called (at least once at the start of the application).  Ordinarily,
3012:                      application code should never call this function, unless it is a low speed
3013:                      USB device.
3014:              
3015:                  Parameters:
3016:                      None
3017:              
3018:                  Return Values:
3019:                      None
3020:              
3021:                  Remarks:
3022:                      This function does not need to be called during USB suspend conditions, when
3023:                      the USB module/stack is disabled, or when the USB cable is detached from the host.
3024:                ***************************************************************************/
3025:              void USBIncrement1msInternalTimers(void)
3026:              {
3027:                  #if(USB_SPEED_OPTION == USB_LOW_SPEED)
3028:                      #warning "For low speed USB applications, read the function comments for the USBIncrement1msInternalTimers() function, and implement code to call this function periodically."
3029:                  #endif
3030:              
3031:                  //Increment timekeeping 1ms tick counters.  Useful for other APIs/code
3032:                  //that needs a 1ms time base that is active during USB non-suspended operation.
3033:                  USB1msTickCount++;
004B8E  804390     MOV USB1msTickCount, W0
004B90  8043A1     MOV 0x874, W1
004B92  400061     ADD W0, #0x1, W0
004B94  4880E0     ADDC W1, #0x0, W1
004B96  884390     MOV W0, USB1msTickCount
004B98  8843A1     MOV W1, 0x874
3034:                  if(USBIsBusSuspended() == false)
004B9A  E24854     CP0.B USBBusIsSuspended
004B9C  3A0004     BRA NZ, 0x4BA6
3035:                  {
3036:                      USBTicksSinceSuspendEnd++;
004B9E  EC6859     INC.B USBTicksSinceSuspendEnd
3037:                      //Check for 8-bit wraparound.  If so, force it to saturate at 255.
3038:                      if(USBTicksSinceSuspendEnd == 0)
004BA0  E24859     CP0.B USBTicksSinceSuspendEnd
004BA2  3A0001     BRA NZ, 0x4BA6
3039:                      {
3040:                          USBTicksSinceSuspendEnd = 255;
004BA4  EFE859     SETM.B USBTicksSinceSuspendEnd
3041:                      }
3042:                  }
3043:              }
004BA6  060000     RETURN
3044:              
3045:              
3046:              
3047:              
3048:              /**************************************************************************
3049:                  Function:
3050:                      uint32_t USBGet1msTickCount(void)
3051:              
3052:                  Description:
3053:                      This function retrieves a 32-bit unsigned integer that normally increments by
3054:                      one every one millisecond.  The count value starts from zero when the
3055:                      USBDeviceInit() function is first called.  See the remarks section for
3056:                      details on special circumstances where the tick count will not increment.
3057:              
3058:                  Precondition:
3059:                      This function should be called only after USBDeviceInit() has been
3060:                      called (at least once at the start of the application).
3061:              
3062:                  Parameters:
3063:                      None
3064:              
3065:                  Return Values:
3066:                      uint32_t representing the approximate millisecond count, since the time the
3067:                      USBDeviceInit() function was first called.
3068:              
3069:                  Remarks:
3070:                      On 8-bit USB full speed devices, the internal counter is incremented on
3071:                      every SOF packet detected.  Therefore, it will not increment during suspend
3072:                      or when the USB cable is detached.  However, on 16-bit devices, the T1MSECIF
3073:                      hardware interrupt source is used to increment the internal counter.  Therefore,
3074:                      on 16-bit devices, the count continue to increment during USB suspend or
3075:                      detach events, so long as the application code has not put the microcontroller
3076:                      to sleep during these events, and the application firmware is regularly
3077:                      calling the USBDeviceTasks() function (or allowing it to execute, if using
3078:                      USB_INTERRUPT mode operation).
3079:              
3080:                      In USB low speed applications, the host does not broadcast SOF packets to
3081:                      the device, so the application firmware becomes responsible for calling
3082:                      USBIncrement1msInternalTimers() periodically (ex: from a general purpose
3083:                      timer interrupt handler), or else the returned value from this function will
3084:                      not increment.
3085:                      
3086:                      Prior to calling USBDeviceInit() for the first time the returned value will
3087:                      be unpredictable.
3088:              
3089:                      This function is USB_INTERRUPT mode safe and may be called from main loop
3090:                      code without risk of retrieving a partially updated 32-bit number.
3091:              
3092:                      However, this value only increments when the USBDeviceTasks() function is allowed
3093:                      to execute.  If USB_INTERRUPT mode is used, it is allowable to block on this
3094:                      function.  If however USB_POLLING mode is used, one must not block on this
3095:                      function without also calling USBDeviceTasks() continuously for the blocking
3096:                      duration (since the USB stack must still be allowed to execute, and the USB
3097:                      stack is also responsible for updating the tick counter internally).
3098:              
3099:                      If the application is operating in USB_POLLING mode, this function should
3100:                      only be called from the main loop context, and not from an interrupt handler,
3101:                      as the returned value could be incorrect, if the main loop context code was in
3102:                      the process of updating the internal count at the moment of the interrupt event.
3103:                 ***************************************************************************/
3104:              uint32_t USBGet1msTickCount(void)
3105:              {
3106:                  #if defined (USB_INTERRUPT)
3107:                      uint32_t localContextValue;
3108:              
3109:                      //Repeatedly read the interrupt context variable, until we get a stable/unchanging
3110:                      //value.  This ensures that the complete 32-bit value got read without
3111:                      //getting interrupted in between bytes.
3112:                      do
3113:                      {
3114:                          localContextValue = USB1msTickCount;
004CB6  804390     MOV USB1msTickCount, W0
004CB8  8043A1     MOV 0x874, W1
3115:                      }while(localContextValue != USB1msTickCount);
004CBA  804392     MOV USB1msTickCount, W2
004CBC  8043A3     MOV 0x874, W3
004CBE  500F82     SUB W0, W2, [W15]
004CC0  588F83     SUBB W1, W3, [W15]
004CC2  3AFFF9     BRA NZ, USBGet1msTickCount
3116:              
3117:                      return localContextValue;    
3118:                  
3119:                  #else
3120:                      return USB1msTickCount;
3121:                  #endif
3122:              }
004CC4  060000     RETURN
3123:              
3124:              
3125:              
3126:              
3127:              
3128:              
3129:              /** EOF USBDevice.c *****************************************************/
---  /home/pele/src/Auto_02/Usb/app_device_custom_hid.c  ------------------------------------------------
1:                 #include "usb.h"
2:                 #include "usb_device_hid.h"
3:                 #include "system.h"
4:                 #include "Timers.h"
5:                 #include "Memory.h"
6:                 #include	"Gsm.h"
7:                 #include	"Gps.h"
8:                 #include	"Wifi.h"
9:                 #include	"Uart1.h"
10:                #include	"Uart4.h"
11:                #include <string.h>
12:                #include <stdio.h>
13:                
14:                extern void BootFlashInit	(void);
15:                extern U8	BootFlashNew	(void);
16:                
17:                #define	USB_OK					0x0C
18:                #define	USB_ERROR				0xEE
19:                #define	USB_COM_NONE			0x00
20:                #define	USB_COM_RESET			0x01
21:                #define	USB_COM_FLASH			0x02
22:                #define	USB_COM_SERVICE			0x03
23:                
24:                #define	USB_COM_MEM_GET_ADDR	0x10
25:                #define	USB_COM_MEM_SET_ADDR	0x11
26:                #define	USB_COM_MEM_WRITE		0x12
27:                #define	USB_COM_MEM_READ		0x13
28:                #define	USB_COM_MEM_CLOSE		0x14
29:                #define	USB_COM_MEM_S_ERASE		0x15
30:                #define	USB_COM_MEM_B_ERASE		0x16
31:                #define	USB_COM_MEM_BOOT_ADDR	0x1A
32:                #define	USB_COM_MEM_FEEL		0x1E
33:                #define	USB_COM_MEM_STATUS		0x1F
34:                
35:                #define	USB_COM_TEXT			0xFC
36:                #define	USB_COM_DEV_INFO		0xFD
37:                #define	USB_COM_DEV_STATUS		0xFE
38:                #define	USB_COM_TEST			0xFF
39:                
40:                #define	USB_PACKET_SIZE			USB_EP0_BUFF_SIZE
41:                #define	USB_PACKET_DATA_SIZE	(USB_PACKET_SIZE - 2)
42:                #define	USB_WAIT_TX_READY()		if (HIDTxHandleBusy(USBInHandle))	UsbWaitTxReady()
43:                #define	USB_SEND_PACKET()		USB_WAIT_TX_READY(); USBInHandle = HIDTxPacket(CUSTOM_DEVICE_HID_EP, Out->buf,USB_PACKET_SIZE)
44:                #define	SWITCH_OUT_BUF()		Out = (NextOutBuf)?	&Out2: &Out1; NextOutBuf ^= 1
45:                
46:                #define	OUT_PACKET				Out->buf
47:                #define	OUT_COMMAND				Out->UsbCommand
48:                #define	OUT_COM					Out->READwrite
49:                #define	OUT_DATA				Out->Data
50:                #define	OUT_DATA_LEN			Out->PackedDateLen
51:                #define	OUT_ADDRESS				Out->Address
52:                #define	OUT_READ_LEN			Out->PageSize
53:                
54:                /** VARIABLES ******************************************************/
55:                typedef union	//      1                2               3-64
56:                {				// UsbCommand | ReadAddr/WriteLen | data/Address/ReadLen/...
57:                	U8	buf[USB_PACKET_SIZE];
58:                	struct
59:                	{
60:                		U8			UsbCommand;			// Usb main command
61:                		union
62:                		{
63:                			U8		READwrite;			// 1 - Set Read Address; 0 - Set Address to write
64:                			U8		PackedDateLen;		// size of bytes to write in current package (or read bytes in sendBuffer)
65:                			U8		com;				// 
66:                		};
67:                		union
68:                		{
69:                			U8		Data[62];			// data buffer for read/write bytes
70:                			struct
71:                			{
72:                				U32	Address;			// Address / size of data etc
73:                				U16	PageSize;			// to device: size of bytes to read;	from: calculated rows in bmp page
74:                				U16	BmpWithPix;			// to device: set row width pix;		from: get saved/calculated width
75:                				U16	BmpPage;			// to device: awaited Page nr.;			from: device: Page count
76:                				U16	CharRowSize;		// Hight of character row (to calculate rows in bmp page)
77:                				U32	Percent_0_1;		// size of 0.1% of available memory
78:                			};
79:                		};
80:                	};
81:                } USB_PACKET;
82:                
83:                static	USB_PACKET			In, Out1, Out2, Text;
84:                static	USB_PACKET*			Out;
85:                static	U8					NextOutBuf = 0;
86:                extern	U32					Percent_10;
87:                extern	U16					BmpPage, BmpPageHi;
88:                extern	U16					resCom, resAddr;
89:                
90:                //static	unsigned int	UsbTimeout	= 0;
91:                
92:                typedef union	//      1                2               3-64
93:                {				// UsbCommand | ReadAddr/WriteLen | data/Address/ReadLen
94:                	U8				DataBuffer[64];
95:                	struct
96:                	{
97:                		U8			UsbCommand;				// Usb main command
98:                		union
99:                		{
100:               			U8		READwrite;				// 1 - Set Read Address; 0 - Set Address to write
101:               			U8		PackedDateLen;			// size of bytes to write in current package (or read bytes in sendBuffer)
102:               		};
103:               		union
104:               		{
105:               			U8		Data[62];				// data buffer for read/write bytes
106:               			struct
107:               			{
108:               				U32	Address;				// read/write address to set
109:               				U16	PageSize;				// size of bytes to read from mem
110:               			};
111:               		};
112:               	};
113:               } USB2MEM_CAST;
114:               
115:               typedef struct
116:               {
117:               	U8		UsbCommand;					// Usb main command
118:               	U8		led;
119:               	U16		pot;
120:               	U32		Raddr;
121:               	U32		Waddr;
122:               //	U8		MemId;
123:               	U16		MemType;
124:               	U8		MemCapacity;
125:               } DEV_STATUS;
126:               
127:               volatile USB_HANDLE USBOutHandle;    
128:               volatile USB_HANDLE USBInHandle;
129:               
130:               void UsbWaitTxReady			(void);
131:               void UsbAckOk				(void);
132:               void UsbAckError			(void);
133:               void Usb_SendText			(char* str);
134:               
135:               void UsbFunctNone			(void);
136:               void UsbCommandReset		(void);		// Command 0x01
137:               void UsbCommandFlash		(void);		// Command 0x02
138:               void UsbCommandService		(void);		// Command 0x03
139:               void UsbCommandService_f	(void);
140:               void UsbCommandService_1	(void);
141:               void UsbCommandService_2	(void);
142:               void UsbCommandService_3	(void);
143:               void UsbCommandService_4	(void);
144:               void UsbCommandService_5	(void);
145:               void UsbCommandService_6	(void);
146:               void UsbCommandService_7	(void);
147:               void UsbCommandService_8	(void);
148:               void UsbMemGetAddress		(void);		// Command 0x10
149:               void UsbMemSetAddress		(void);		// Command 0x11
150:               void UsbMemWrite			(void);		// Command 0x12
151:               void UsbMemRead				(void);		// Command 0x13
152:               void UsbMemClose			(void);		// Command 0x14
153:               void UsbMemSecErase			(void);		// Command 0x15
154:               void UsbMemBulkErase		(void);		// Command 0x16
155:               void UsbMemSetBootAddress	(void);		// Command 0x1A
156:               void UsbMemFeel				(void);		// Command 0x1E
157:               void UsbMemStatus			(void);		// Command 0x1F
158:               void UsbDeviceText			(void);		// Command 0xFC
159:               void UsbDeviceInfo			(void);		// Command 0xFD
160:               void UsbDeviceStatus		(void);		// Command 0xFE
161:               void UsbCommandTest			(void);		// Command 0xFF
162:               
163:               void UsbPrintRecBuf			(void);
164:               
165:               void (*UsbFunct[256])(void) =
166:               {
167:               	UsbFunctNone,			// 0x00
168:               	UsbCommandReset,		// 0x01	Ok
169:               	UsbCommandFlash,		// 0x02	Ok
170:               	UsbCommandService,		// 0x03	Ok
171:               	UsbFunctNone,			// 0x04
172:               	UsbFunctNone,			// 0x05
173:               	UsbFunctNone,			// 0x06
174:               	UsbFunctNone,			// 0x07
175:               	UsbFunctNone,			// 0x08
176:               	UsbFunctNone,			// 0x09
177:               	UsbFunctNone,			// 0x0A
178:               	UsbFunctNone,			// 0x0B
179:               	UsbFunctNone,			// 0x0C
180:               	UsbFunctNone,			// 0x0D
181:               	UsbFunctNone,			// 0x0E
182:               	UsbFunctNone,			// 0x0F
183:               	UsbMemGetAddress,		// 0x10 Ok
184:               	UsbMemSetAddress,		// 0x11	Ok
185:               	UsbMemWrite,			// 0x12	Ok
186:               	UsbMemRead,				// 0x13	Ok
187:               	UsbMemClose,			// 0x14	Ok
188:               	UsbMemSecErase,			// 0x15 Ok
189:               	UsbMemBulkErase,		// 0x16	Ok
190:               	UsbFunctNone,			// 0x17
191:               	UsbFunctNone,			// 0x18
192:               	UsbFunctNone,			// 0x19
193:               	UsbMemSetBootAddress,	// 0x1A	Ok
194:               	UsbFunctNone,			// 0x1B
195:               	UsbFunctNone,			// 0x1C
196:               	UsbFunctNone,			// 0x1D
197:               	UsbMemFeel,				// 0x1E	Ok
198:               	UsbMemStatus,			// 0x1F	Ok
199:               	UsbFunctNone,			// 0x20
200:               	UsbFunctNone,			// 0x21
201:               	UsbFunctNone,			// 0x22
202:               	UsbFunctNone,			// 0x23
203:               	UsbFunctNone,			// 0x24
204:               	UsbFunctNone,			// 0x25
205:               	UsbFunctNone,			// 0x26
206:               	UsbFunctNone,			// 0x27
207:               	UsbFunctNone,			// 0x28
208:               	UsbFunctNone,			// 0x29
209:               	UsbFunctNone,			// 0x2A
210:               	UsbFunctNone,			// 0x2B
211:               	UsbFunctNone,			// 0x2C
212:               	UsbFunctNone,			// 0x2D
213:               	UsbFunctNone,			// 0x2E
214:               	UsbFunctNone,			// 0x2F
215:               	UsbFunctNone,			// 0x30
216:               	UsbFunctNone,			// 0x31
217:               	UsbFunctNone,			// 0x32
218:               	UsbFunctNone,			// 0x33
219:               	UsbFunctNone,			// 0x34
220:               	UsbFunctNone,			// 0x35
221:               	UsbFunctNone,			// 0x36
222:               	UsbFunctNone,			// 0x37
223:               	UsbFunctNone,			// 0x38
224:               	UsbFunctNone,			// 0x39
225:               	UsbFunctNone,			// 0x3A
226:               	UsbFunctNone,			// 0x3B
227:               	UsbFunctNone,			// 0x3C
228:               	UsbFunctNone,			// 0x3D
229:               	UsbFunctNone,			// 0x3E
230:               	UsbFunctNone,			// 0x3F
231:               	UsbFunctNone,			// 0x40
232:               	UsbFunctNone,			// 0x41
233:               	UsbFunctNone,			// 0x42
234:               	UsbFunctNone,			// 0x43
235:               	UsbFunctNone,			// 0x44
236:               	UsbFunctNone,			// 0x45
237:               	UsbFunctNone,			// 0x46
238:               	UsbFunctNone,			// 0x47
239:               	UsbFunctNone,			// 0x48
240:               	UsbFunctNone,			// 0x49
241:               	UsbFunctNone,			// 0x4A
242:               	UsbFunctNone,			// 0x4B
243:               	UsbFunctNone,			// 0x4C
244:               	UsbFunctNone,			// 0x4D
245:               	UsbFunctNone,			// 0x4E
246:               	UsbFunctNone,			// 0x4F
247:               	UsbFunctNone,			// 0x50
248:               	UsbFunctNone,			// 0x51
249:               	UsbFunctNone,			// 0x52
250:               	UsbFunctNone,			// 0x53
251:               	UsbFunctNone,			// 0x54
252:               	UsbFunctNone,			// 0x55
253:               	UsbFunctNone,			// 0x56
254:               	UsbFunctNone,			// 0x57
255:               	UsbFunctNone,			// 0x58
256:               	UsbFunctNone,			// 0x59
257:               	UsbFunctNone,			// 0x5A
258:               	UsbFunctNone,			// 0x5B
259:               	UsbFunctNone,			// 0x5C
260:               	UsbFunctNone,			// 0x5D
261:               	UsbFunctNone,			// 0x5E
262:               	UsbFunctNone,			// 0x5F
263:               	UsbFunctNone,			// 0x60
264:               	UsbFunctNone,			// 0x61
265:               	UsbFunctNone,			// 0x62
266:               	UsbFunctNone,			// 0x63
267:               	UsbFunctNone,			// 0x64
268:               	UsbFunctNone,			// 0x65
269:               	UsbFunctNone,			// 0x66
270:               	UsbFunctNone,			// 0x67
271:               	UsbFunctNone,			// 0x68
272:               	UsbFunctNone,			// 0x69
273:               	UsbFunctNone,			// 0x6A
274:               	UsbFunctNone,			// 0x6B
275:               	UsbFunctNone,			// 0x6C
276:               	UsbFunctNone,			// 0x6D
277:               	UsbFunctNone,			// 0x6E
278:               	UsbFunctNone,			// 0x6F
279:               	UsbFunctNone,			// 0x70
280:               	UsbFunctNone,			// 0x71
281:               	UsbFunctNone,			// 0x72
282:               	UsbFunctNone,			// 0x73
283:               	UsbFunctNone,			// 0x74
284:               	UsbFunctNone,			// 0x75
285:               	UsbFunctNone,			// 0x76
286:               	UsbFunctNone,			// 0x77
287:               	UsbFunctNone,			// 0x78
288:               	UsbFunctNone,			// 0x79
289:               	UsbFunctNone,			// 0x7A
290:               	UsbFunctNone,			// 0x7B
291:               	UsbFunctNone,			// 0x7C
292:               	UsbFunctNone,			// 0x7D
293:               	UsbFunctNone,			// 0x7E
294:               	UsbFunctNone,			// 0x7F
295:               	UsbFunctNone,			// 0x80
296:               	UsbFunctNone,			// 0x81
297:               	UsbFunctNone,			// 0x82
298:               	UsbFunctNone,			// 0x83
299:               	UsbFunctNone,			// 0x84
300:               	UsbFunctNone,			// 0x85
301:               	UsbFunctNone,			// 0x86
302:               	UsbFunctNone,			// 0x87
303:               	UsbFunctNone,			// 0x88
304:               	UsbFunctNone,			// 0x89
305:               	UsbFunctNone,			// 0x8A
306:               	UsbFunctNone,			// 0x8B
307:               	UsbFunctNone,			// 0x8C
308:               	UsbFunctNone,			// 0x8D
309:               	UsbFunctNone,			// 0x8E
310:               	UsbFunctNone,			// 0x8F
311:               	UsbFunctNone,			// 0x90
312:               	UsbFunctNone,			// 0x91
313:               	UsbFunctNone,			// 0x92
314:               	UsbFunctNone,			// 0x93
315:               	UsbFunctNone,			// 0x94
316:               	UsbFunctNone,			// 0x95
317:               	UsbFunctNone,			// 0x96
318:               	UsbFunctNone,			// 0x97
319:               	UsbFunctNone,			// 0x98
320:               	UsbFunctNone,			// 0x99
321:               	UsbFunctNone,			// 0x9A
322:               	UsbFunctNone,			// 0x9B
323:               	UsbFunctNone,			// 0x9C
324:               	UsbFunctNone,			// 0x9D
325:               	UsbFunctNone,			// 0x9E
326:               	UsbFunctNone,			// 0x9F
327:               	UsbFunctNone,			// 0xA0
328:               	UsbFunctNone,			// 0xA1
329:               	UsbFunctNone,			// 0xA2
330:               	UsbFunctNone,			// 0xA3
331:               	UsbFunctNone,			// 0xA4
332:               	UsbFunctNone,			// 0xA5
333:               	UsbFunctNone,			// 0xA6
334:               	UsbFunctNone,			// 0xA7
335:               	UsbFunctNone,			// 0xA8
336:               	UsbFunctNone,			// 0xA9
337:               	UsbFunctNone,			// 0xAA
338:               	UsbFunctNone,			// 0xAB
339:               	UsbFunctNone,			// 0xAC
340:               	UsbFunctNone,			// 0xAD
341:               	UsbFunctNone,			// 0xAE
342:               	UsbFunctNone,			// 0xAF
343:               	UsbFunctNone,			// 0xB0
344:               	UsbFunctNone,			// 0xB1
345:               	UsbFunctNone,			// 0xB2
346:               	UsbFunctNone,			// 0xB3
347:               	UsbFunctNone,			// 0xB4
348:               	UsbFunctNone,			// 0xB5
349:               	UsbFunctNone,			// 0xB6
350:               	UsbFunctNone,			// 0xB7
351:               	UsbFunctNone,			// 0xB8
352:               	UsbFunctNone,			// 0xB9
353:               	UsbFunctNone,			// 0xBA
354:               	UsbFunctNone,			// 0xBB
355:               	UsbFunctNone,			// 0xBC
356:               	UsbFunctNone,			// 0xBD
357:               	UsbFunctNone,			// 0xBE
358:               	UsbFunctNone,			// 0xBF
359:               	UsbFunctNone,			// 0xC0
360:               	UsbFunctNone,			// 0xC1
361:               	UsbFunctNone,			// 0xC2
362:               	UsbFunctNone,			// 0xC3
363:               	UsbFunctNone,			// 0xC4
364:               	UsbFunctNone,			// 0xC5
365:               	UsbFunctNone,			// 0xC6
366:               	UsbFunctNone,			// 0xC7
367:               	UsbFunctNone,			// 0xC8
368:               	UsbFunctNone,			// 0xC9
369:               	UsbFunctNone,			// 0xCA
370:               	UsbFunctNone,			// 0xCB
371:               	UsbFunctNone,			// 0xCC
372:               	UsbFunctNone,			// 0xCD
373:               	UsbFunctNone,			// 0xCE
374:               	UsbFunctNone,			// 0xCF
375:               	UsbFunctNone,			// 0xD0
376:               	UsbFunctNone,			// 0xD1
377:               	UsbFunctNone,			// 0xD2
378:               	UsbFunctNone,			// 0xD3
379:               	UsbFunctNone,			// 0xD4
380:               	UsbFunctNone,			// 0xD5
381:               	UsbFunctNone,			// 0xD6
382:               	UsbFunctNone,			// 0xD7
383:               	UsbFunctNone,			// 0xD8
384:               	UsbFunctNone,			// 0xD9
385:               	UsbFunctNone,			// 0xDA
386:               	UsbFunctNone,			// 0xDB
387:               	UsbFunctNone,			// 0xDC
388:               	UsbFunctNone,			// 0xDD
389:               	UsbFunctNone,			// 0xDE
390:               	UsbFunctNone,			// 0xDF
391:               	UsbFunctNone,			// 0xE0
392:               	UsbFunctNone,			// 0xE1
393:               	UsbFunctNone,			// 0xE2
394:               	UsbFunctNone,			// 0xE3
395:               	UsbFunctNone,			// 0xE4
396:               	UsbFunctNone,			// 0xE5
397:               	UsbFunctNone,			// 0xE6
398:               	UsbFunctNone,			// 0xE7
399:               	UsbFunctNone,			// 0xE8
400:               	UsbFunctNone,			// 0xE9
401:               	UsbFunctNone,			// 0xEA
402:               	UsbFunctNone,			// 0xEB
403:               	UsbFunctNone,			// 0xEC
404:               	UsbFunctNone,			// 0xED
405:               	UsbFunctNone,			// 0xEE
406:               	UsbFunctNone,			// 0xEF
407:               	UsbFunctNone,			// 0xF0
408:               	UsbFunctNone,			// 0xF1
409:               	UsbFunctNone,			// 0xF2
410:               	UsbFunctNone,			// 0xF3
411:               	UsbFunctNone,			// 0xF4
412:               	UsbFunctNone,			// 0xF5
413:               	UsbFunctNone,			// 0xF6
414:               	UsbFunctNone,			// 0xF7
415:               	UsbFunctNone,			// 0xF8
416:               	UsbFunctNone,			// 0xF9
417:               	UsbFunctNone,			// 0xFA
418:               	UsbFunctNone,			// 0xFB
419:               	UsbDeviceText,			// 0xFC
420:               	UsbDeviceInfo,			// 0xFD
421:               	UsbDeviceStatus,		// 0xFE
422:               	UsbCommandTest,			// 0xFF
423:               };
424:               
425:               /** FUNCTIONS ******************************************************/
426:               
427:               void APP_DeviceCustomHIDInitialize()
428:               {	//initialize the variable holding the handle for the last transmission
429:               	USBInHandle = 0;
004CC8  EF2902     CLR USBInHandle
430:               	SWITCH_OUT_BUF();
004CCA  BFC904     MOV.B NextOutBuf, WREG
004CCC  236141     MOV #0x3614, W1
004CCE  320001     BRA Z, 0x4CD2
004CD0  235D41     MOV #0x35D4, W1
004CD2  884831     MOV W1, Out
004CD4  A20400     BTG.B W0, #0
004CD6  B7E904     MOV.B WREG, NextOutBuf
431:               
432:               	//enable the HID endpoint
433:               	USBEnableEndpoint(CUSTOM_DEVICE_HID_EP, USB_IN_ENABLED|USB_OUT_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
004CD8  B3C1D1     MOV.B #0x1D, W1
004CDA  B3C010     MOV.B #0x1, W0
004CDC  07FD48     RCALL USBEnableEndpoint
434:               
435:               	//Re-arm the OUT endpoint for the next packet
436:               	USBOutHandle = (volatile USB_HANDLE)HIDRxPacket(CUSTOM_DEVICE_HID_EP, In.buf, USB_PACKET_SIZE);
004CDE  B3C403     MOV.B #0x40, W3
004CE0  235942     MOV #0x3594, W2
004CE2  EB4080     CLR.B W1
004CE4  B3C010     MOV.B #0x1, W0
004CE6  07FD59     RCALL USBTransferOnePacket
004CE8  884800     MOV W0, USBOutHandle
437:               }
004CEA  060000     RETURN
438:               
439:               #define USB_TIMEOUT_MS		20
440:               inline void UsbMsTimer (void)
441:               {
442:               	static U8 i = USB_TIMEOUT_MS;
443:               	if (!--i)
004CEC  ED4930     DEC.B 0x930, WREG
004CEE  B7E930     MOV.B WREG, 0x930
004CF0  3A0002     BRA NZ, 0x4CF6
444:               	{
445:               		i = USB_TIMEOUT_MS;
004CF2  B3C140     MOV.B #0x14, W0
004CF4  B7E930     MOV.B WREG, 0x930
446:               //		UsbTimeout++;
447:               	}
448:               }
004CF6  060000     RETURN
449:               
450:               /*********************************************************************
451:               * PreCondition: The demo should have been initialized and started via
452:               *   the APP_DeviceCustomHIDInitialize() and APP_DeviceCustomHIDStart() demos
453:               *   respectively.
454:               ********************************************************************/
455:               void APP_DeviceCustomHIDTasks()
456:               {
004CF8  781F88     MOV W8, [W15++]
457:               	if(HIDRxHandleBusy(USBOutHandle) == false)
004CFA  804800     MOV USBOutHandle, W0
004CFC  E00000     CP0 W0
004CFE  320002     BRA Z, 0x4D04
004D00  E00010     CP0 [W0]
004D02  35000C     BRA LT, 0x4D1C
458:               	{
459:               		UsbFunct[In.UsbCommand]();													// execute function according to received command
004D04  235948     MOV #0x3594, W8
004D06  FB8018     ZE [W8], W0
004D08  400000     ADD W0, W0, W0
004D0A  233941     MOV #0x3394, W1
004D0C  780061     MOV [W1+W0], W0
004D0E  010000     CALL W0
460:               		USBOutHandle = HIDRxPacket(CUSTOM_DEVICE_HID_EP, In.buf, USB_PACKET_SIZE);	// init next receive
004D10  B3C403     MOV.B #0x40, W3
004D12  780108     MOV W8, W2
004D14  EB4080     CLR.B W1
004D16  B3C010     MOV.B #0x1, W0
004D18  07FD40     RCALL USBTransferOnePacket
004D1A  884800     MOV W0, USBOutHandle
461:               	}
462:               }
004D1C  78044F     MOV [--W15], W8
004D1E  060000     RETURN
463:               
464:               void UsbWaitTxReady			(void)
465:               {
466:               //	while (HIDTxHandleBusy(USBInHandle));
467:               	unsigned int i = 0xFFFF;
004D26  EB8000     SETM W0
468:               	while ((HIDTxHandleBusy(USBInHandle)) && i--);
004D20  804812     MOV USBInHandle, W2
004D22  E00002     CP0 W2
004D24  320008     BRA Z, 0x4D36
004D28  280003     MOV #0x8000, W3
004D2A  618092     AND W3, [W2], W1
004D2C  320004     BRA Z, 0x4D36
004D2E  E00000     CP0 W0
004D30  320002     BRA Z, 0x4D36
004D32  E90000     DEC W0, W0
004D34  37FFFA     BRA 0x4D2A
469:               }
004D36  060000     RETURN
470:               
471:               void UsbAckError			(void)
472:               {
473:               //	SWITCH_OUT_BUF();
474:               	Out = &Out1;
005138  236141     MOV #0x3614, W1
00513A  884831     MOV W1, Out
475:               //	Out = (NextOutBuf)?	Out2:Out1;
476:               	NextOutBuf ^= 1;
00513C  AA0904     BTG NextOutBuf, #0
477:               	OUT_COMMAND		= USB_ERROR;
00513E  B3CEE0     MOV.B #0xEE, W0
005140  784880     MOV.B W0, [W1]
478:               	OUT_COM			= USB_ERROR;
005142  E80081     INC W1, W1
005144  784880     MOV.B W0, [W1]
479:               	USB_SEND_PACKET();
005146  804810     MOV USBInHandle, W0
005148  E00000     CP0 W0
00514A  320003     BRA Z, 0x5152
00514C  E00010     CP0 [W0]
00514E  3D0001     BRA GE, 0x5152
005150  07FDE7     RCALL UsbWaitTxReady
005152  B3C403     MOV.B #0x40, W3
005154  804832     MOV Out, W2
005156  B3C011     MOV.B #0x1, W1
005158  784001     MOV.B W1, W0
00515A  07FB1F     RCALL USBTransferOnePacket
00515C  884810     MOV W0, USBInHandle
480:               }
00515E  060000     RETURN
481:               
482:               void UsbAckOk			(void)
483:               {
484:               	SWITCH_OUT_BUF();
005160  209041     MOV #0x904, W1
005162  784091     MOV.B [W1], W1
005164  236140     MOV #0x3614, W0
005166  E00401     CP0.B W1
005168  320001     BRA Z, 0x516C
00516A  235D40     MOV #0x35D4, W0
00516C  884830     MOV W0, Out
00516E  A20401     BTG.B W1, #0
005170  784181     MOV.B W1, W3
005172  209042     MOV #0x904, W2
005174  784903     MOV.B W3, [W2]
485:               	OUT_COMMAND		= USB_OK;
005176  B3C0C1     MOV.B #0xC, W1
005178  784801     MOV.B W1, [W0]
486:               	OUT_COM			= USB_OK;
00517A  984011     MOV.B W1, [W0+1]
487:               	USB_SEND_PACKET();
00517C  804810     MOV USBInHandle, W0
00517E  E00000     CP0 W0
005180  320003     BRA Z, 0x5188
005182  E00010     CP0 [W0]
005184  3D0001     BRA GE, 0x5188
005186  07FDCC     RCALL UsbWaitTxReady
005188  B3C403     MOV.B #0x40, W3
00518A  804832     MOV Out, W2
00518C  B3C011     MOV.B #0x1, W1
00518E  784001     MOV.B W1, W0
005190  07FB04     RCALL USBTransferOnePacket
005192  884810     MOV W0, USBInHandle
488:               }
005194  060000     RETURN
489:               
490:               void UsbFunctNone			(void)
491:               {
492:               	Usb_SendText("Uncnown USB command - not implemented");
00543C  2B4140     MOV #0xB414, W0
00543E  07FF3F     RCALL Usb_SendText
493:               	LED_HID = LED_STATUS_ERROR;
005440  2AAAA0     MOV #0xAAAA, W0
005442  8844D0     MOV W0, LedStatus4
494:               }
005444  060000     RETURN
495:               
496:               void UsbCommandReset		(void)
497:               {
498:               	SWITCH_OUT_BUF();
0050CA  209041     MOV #0x904, W1
0050CC  784091     MOV.B [W1], W1
0050CE  236140     MOV #0x3614, W0
0050D0  E00401     CP0.B W1
0050D2  320001     BRA Z, 0x50D6
0050D4  235D40     MOV #0x35D4, W0
0050D6  884830     MOV W0, Out
0050D8  A20401     BTG.B W1, #0
0050DA  784181     MOV.B W1, W3
0050DC  209042     MOV #0x904, W2
0050DE  784903     MOV.B W3, [W2]
499:               	OUT_COMMAND		= USB_COM_RESET;
0050E0  B3C011     MOV.B #0x1, W1
0050E2  784801     MOV.B W1, [W0]
500:               	if (In.com == (0xFF - USB_COM_RESET))
0050E4  235951     MOV #0x3595, W1
0050E6  B3CFE2     MOV.B #0xFE, W2
0050E8  114F91     SUBR.B W2, [W1], [W15]
0050EA  3A0017     BRA NZ, 0x511A
501:               	{
502:               		LED_HID = LED_STATUS_ERROR;
0050EC  2AAAA1     MOV #0xAAAA, W1
0050EE  8844D1     MOV W1, LedStatus4
503:               		OUT_COM		= USB_OK;
0050F0  B3C0C1     MOV.B #0xC, W1
0050F2  984011     MOV.B W1, [W0+1]
504:               		USB_SEND_PACKET();				// Send Ack
0050F4  804810     MOV USBInHandle, W0
0050F6  E00000     CP0 W0
0050F8  320003     BRA Z, 0x5100
0050FA  E00010     CP0 [W0]
0050FC  3D0001     BRA GE, 0x5100
0050FE  07FE10     RCALL UsbWaitTxReady
005100  B3C403     MOV.B #0x40, W3
005102  804832     MOV Out, W2
005104  B3C011     MOV.B #0x1, W1
005106  784001     MOV.B W1, W0
005108  07FB48     RCALL USBTransferOnePacket
00510A  884810     MOV W0, USBInHandle
505:               		USB_WAIT_TX_READY();			// & wait while packet sent
00510C  E00000     CP0 W0
00510E  320003     BRA Z, 0x5116
005110  E00010     CP0 [W0]
005112  3D0001     BRA GE, 0x5116
005114  07FE05     RCALL UsbWaitTxReady
506:               
507:               		__asm__ ("RESET");
005116  FE0000     RESET
005118  37FFFF     BRA 0x5118
508:               		while(1);
509:               	}
510:               	else
511:               		OUT_COM		= USB_ERROR;
00511A  B3CEE1     MOV.B #0xEE, W1
00511C  984011     MOV.B W1, [W0+1]
512:               	USB_SEND_PACKET();
00511E  804810     MOV USBInHandle, W0
005120  E00000     CP0 W0
005122  320003     BRA Z, 0x512A
005124  E00010     CP0 [W0]
005126  3D0001     BRA GE, 0x512A
005128  07FDFB     RCALL UsbWaitTxReady
00512A  B3C403     MOV.B #0x40, W3
00512C  804832     MOV Out, W2
00512E  B3C011     MOV.B #0x1, W1
005130  784001     MOV.B W1, W0
005132  07FB33     RCALL USBTransferOnePacket
005134  884810     MOV W0, USBInHandle
513:               }
005136  060000     RETURN
514:               
515:               void UsbCommandFlash		(void)
516:               {
517:               	SWITCH_OUT_BUF();
005080  209041     MOV #0x904, W1
005082  784091     MOV.B [W1], W1
005084  236140     MOV #0x3614, W0
005086  E00401     CP0.B W1
005088  320001     BRA Z, 0x508C
00508A  235D40     MOV #0x35D4, W0
00508C  884830     MOV W0, Out
00508E  A20401     BTG.B W1, #0
005090  784181     MOV.B W1, W3
005092  209042     MOV #0x904, W2
005094  784903     MOV.B W3, [W2]
518:               	OUT_COMMAND	= USB_COM_FLASH;
005096  B3C021     MOV.B #0x2, W1
005098  784801     MOV.B W1, [W0]
519:               	if (In.com	== (0xFF - USB_COM_FLASH))
00509A  235951     MOV #0x3595, W1
00509C  B3CFD2     MOV.B #0xFD, W2
00509E  114F91     SUBR.B W2, [W1], [W15]
0050A0  3A0005     BRA NZ, 0x50AC
520:               	{
521:               		BootFlashInit();
0050A2  0714DF     RCALL BootFlashInit
522:               		OUT_COM		= USB_OK;
0050A4  B3C0C1     MOV.B #0xC, W1
0050A6  804830     MOV Out, W0
0050A8  984011     MOV.B W1, [W0+1]
0050AA  370002     BRA 0x50B0
523:               	}
524:               	else
525:               		OUT_COM		= USB_ERROR;
0050AC  B3CEE1     MOV.B #0xEE, W1
0050AE  984011     MOV.B W1, [W0+1]
526:               	USB_SEND_PACKET();
0050B0  804810     MOV USBInHandle, W0
0050B2  E00000     CP0 W0
0050B4  320003     BRA Z, 0x50BC
0050B6  E00010     CP0 [W0]
0050B8  3D0001     BRA GE, 0x50BC
0050BA  07FE32     RCALL UsbWaitTxReady
0050BC  B3C403     MOV.B #0x40, W3
0050BE  804832     MOV Out, W2
0050C0  B3C011     MOV.B #0x1, W1
0050C2  784001     MOV.B W1, W0
0050C4  07FB6A     RCALL USBTransferOnePacket
0050C6  884810     MOV W0, USBInHandle
527:               }
0050C8  060000     RETURN
528:               
529:               void UsbCommandService		(void)
530:               {
531:               	SWITCH_OUT_BUF();
00522C  BFC904     MOV.B NextOutBuf, WREG
00522E  236141     MOV #0x3614, W1
005230  320001     BRA Z, 0x5234
005232  235D41     MOV #0x35D4, W1
005234  884831     MOV W1, Out
005236  A20400     BTG.B W0, #0
005238  B7E904     MOV.B WREG, NextOutBuf
532:               	OUT_COMMAND		= USB_COM_SERVICE;
00523A  B3C030     MOV.B #0x3, W0
00523C  784880     MOV.B W0, [W1]
533:               	switch (In.com)
00523E  235950     MOV #0x3595, W0
005240  784010     MOV.B [W0], W0
005242  B3C352     MOV.B #0x35, W2
005244  504F82     SUB.B W0, W2, [W15]
005246  320024     BRA Z, 0x5290
005248  3E000F     BRA GTU, 0x5268
00524A  514163     SUB.B W2, #0x3, W2
00524C  504F82     SUB.B W0, W2, [W15]
00524E  32001A     BRA Z, 0x5284
005250  3E0004     BRA GTU, 0x525A
005252  E94102     DEC.B W2, W2
005254  504F82     SUB.B W0, W2, [W15]
005256  3A0024     BRA NZ, 0x52A0
005258  370013     BRA 0x5280
00525A  B3C332     MOV.B #0x33, W2
00525C  504F82     SUB.B W0, W2, [W15]
00525E  320014     BRA Z, 0x5288
005260  E84102     INC.B W2, W2
005262  504F82     SUB.B W0, W2, [W15]
005264  3A001D     BRA NZ, 0x52A0
005266  370012     BRA 0x528C
005268  B3C372     MOV.B #0x37, W2
00526A  504F82     SUB.B W0, W2, [W15]
00526C  320015     BRA Z, 0x5298
00526E  390012     BRA NC, 0x5294
005270  E84102     INC.B W2, W2
005272  504F82     SUB.B W0, W2, [W15]
005274  320013     BRA Z, 0x529C
005276  B3C662     MOV.B #0x66, W2
005278  504F82     SUB.B W0, W2, [W15]
00527A  3A0012     BRA NZ, 0x52A0
534:               	{
535:               	case 'f':	UsbCommandService_f();	break;
00527C  07FF8C     RCALL UsbCommandService_f
00527E  370012     BRA 0x52A4
536:               	case '1':	UsbCommandService_1();	break;
005280  07FF98     RCALL UsbCommandService_1
005282  370010     BRA 0x52A4
537:               	case '2':	UsbCommandService_2();	break;
005284  07FFA0     RCALL UsbCommandService_2
005286  37000E     BRA 0x52A4
538:               	case '3':	UsbCommandService_3();	break;
005288  07FFA5     RCALL UsbCommandService_3
00528A  37000C     BRA 0x52A4
539:               	case '4':	UsbCommandService_4();	break;
00528C  07FFAA     RCALL UsbCommandService_4
00528E  37000A     BRA 0x52A4
540:               	case '5':	UsbCommandService_5();	break;
005290  07FFAF     RCALL UsbCommandService_5
005292  370008     BRA 0x52A4
541:               	case '6':	UsbCommandService_6();	break;
005294  07FFB5     RCALL UsbCommandService_6
005296  370006     BRA 0x52A4
542:               	case '7':	UsbCommandService_7();	break;
005298  07FFBA     RCALL UsbCommandService_7
00529A  370004     BRA 0x52A4
543:               	case '8':	UsbCommandService_8();	break;
00529C  07FFC0     RCALL UsbCommandService_8
00529E  370002     BRA 0x52A4
544:               	default:	OUT_DATA_LEN	= 0;	break;
0052A0  EB4000     CLR.B W0
0052A2  984090     MOV.B W0, [W1+1]
545:               	}
546:               	USB_SEND_PACKET();
0052A4  804810     MOV USBInHandle, W0
0052A6  E00000     CP0 W0
0052A8  320003     BRA Z, 0x52B0
0052AA  E00010     CP0 [W0]
0052AC  3D0001     BRA GE, 0x52B0
0052AE  07FD38     RCALL UsbWaitTxReady
0052B0  B3C403     MOV.B #0x40, W3
0052B2  804832     MOV Out, W2
0052B4  B3C011     MOV.B #0x1, W1
0052B6  784001     MOV.B W1, W0
0052B8  07FA70     RCALL USBTransferOnePacket
0052BA  884810     MOV W0, USBInHandle
547:               }
0052BC  060000     RETURN
548:               
549:               //extern	UNI32	testVal;
550:               //extern	U8		testBuf[20];
551:               void UsbCommandService_f	(void)
552:               {
553:               /*	{	//	Boot_ReadReset();
554:               		register unsigned int	offset	asm ("w6") = 0x000100;
555:               		TBLPAG	= 0;
556:               		resCom	= __builtin_tblrdh(offset);
557:               		resAddr	= __builtin_tblrdl(offset);
558:               	}
559:               */
560:               	*(U16*)&OUT_DATA[0] = resCom;
005196  804831     MOV Out, W1
005198  780001     MOV W1, W0
00519A  811042     MOV resCom, W2
00519C  782802     MOV W2, [++W0]
561:               	*(U16*)&OUT_DATA[2] = resAddr;
00519E  811052     MOV resAddr, W2
0051A0  980012     MOV W2, [W0+2]
562:               	*(U16*)&OUT_DATA[4] = 0x1234;       //testVal.u16h;	// 0x1234;
0051A2  212342     MOV #0x1234, W2
0051A4  980022     MOV W2, [W0+4]
563:               	*(U16*)&OUT_DATA[6] = 0x5678;       // testVal.u16l;	// 0x5678;
0051A6  256782     MOV #0x5678, W2
0051A8  980032     MOV W2, [W0+6]
564:               //	*(U16*)&OUT_DATA[8] = (U16)(&resCom);
565:               //	*(U16*)&OUT_DATA[10] = (U16)(&resAddr);
566:               //	memcpy(&OUT_DATA[8], testBuf, 20);
567:               	OUT_DATA_LEN	= 62;
0051AA  B3C3E0     MOV.B #0x3E, W0
0051AC  984090     MOV.B W0, [W1+1]
568:               	BootFlashNew();
0051AE  071475     RCALL BootFlashNew
569:               }
0051B0  060000     RETURN
570:               
571:               void UsbCommandService_1	(void)
572:               {
573:               	#if		(TEST == GSM_TEST)
574:               		Gsm_On();
0051B2  07F272     RCALL Gsm_On
575:               	#elif	(TEST == GPS_TEST)
576:               		GPS_IE = !GPS_IE;
577:               	#elif	(TEST == WIFI_TEST)
578:               		Wifi_On();
579:               	#endif
580:               	OUT_DATA_LEN	= 1;
0051B4  804830     MOV Out, W0
0051B6  B3C011     MOV.B #0x1, W1
0051B8  984011     MOV.B W1, [W0+1]
581:               	OUT_DATA[0]		= (GSM_IE)?	'1':'0';
0051BA  B3C301     MOV.B #0x30, W1
0051BC  AB0096     BTST IEC1, #0
0051BE  320001     BRA Z, 0x51C2
0051C0  E84081     INC.B W1, W1
0051C2  984021     MOV.B W1, [W0+2]
582:               }
0051C4  060000     RETURN
583:               
584:               void UsbCommandService_2	(void)
585:               {
586:               	#if		(TEST == GSM_TEST)
587:               		Gsm_PwrOn();
0051C6  07F28B     RCALL Gsm_PwrOn
588:               	#elif	(TEST == GPS_TEST)
589:               		Gps_On();
590:               	#elif	(TEST == WIFI_TEST)
591:               		Wifi_Reset();
592:               	#endif
593:               	OUT_DATA_LEN	= 1;
0051C8  804830     MOV Out, W0
0051CA  B3C011     MOV.B #0x1, W1
0051CC  984011     MOV.B W1, [W0+1]
594:               	OUT_DATA[0]		= 'P';
0051CE  B3C501     MOV.B #0x50, W1
0051D0  984021     MOV.B W1, [W0+2]
595:               }
0051D2  060000     RETURN
596:               
597:               void UsbCommandService_3	(void)
598:               {
599:               	#if		(TEST == GSM_TEST)
600:               		Gsm_PwrKey();
0051D4  07F295     RCALL Gsm_PwrKey
601:               	#elif	(TEST == WIFI_TEST)
602:               		Wifi_BaudrateChange();
603:               	#endif
604:               	OUT_DATA_LEN	= 1;
0051D6  804830     MOV Out, W0
0051D8  B3C011     MOV.B #0x1, W1
0051DA  984011     MOV.B W1, [W0+1]
605:               	OUT_DATA[0]		= 'K';
0051DC  B3C4B1     MOV.B #0x4B, W1
0051DE  984021     MOV.B W1, [W0+2]
606:               }
0051E0  060000     RETURN
607:               
608:               void UsbCommandService_4	(void)
609:               {
610:               	#if		(TEST == GSM_TEST)
611:               		Gsm_AT();
0051E2  07F2A0     RCALL Gsm_AT
612:               	#endif
613:               	OUT_DATA_LEN	= 1;
0051E4  804830     MOV Out, W0
0051E6  B3C011     MOV.B #0x1, W1
0051E8  984011     MOV.B W1, [W0+1]
614:               	OUT_DATA[0]		= 'A';
0051EA  B3C411     MOV.B #0x41, W1
0051EC  984021     MOV.B W1, [W0+2]
615:               }
0051EE  060000     RETURN
616:               
617:               void UsbCommandService_5	(void)
618:               {
619:               	#if		(TEST == GSM_TEST)
620:               		Gsm_AtCommand((char*)In.Data);
0051F0  235960     MOV #0x3596, W0
0051F2  07F29D     RCALL Gsm_AtCommand
621:               	#elif	(TEST == GPS_TEST)
622:               		Uart1_SendData((char*)In.Data, In.PackedDateLen);
623:               	#elif	(TEST == WIFI_TEST)
624:               		Wifi_SendCommand((char*)In.Data);
625:               	#endif
626:               	OUT_DATA_LEN	= 1;
0051F4  804830     MOV Out, W0
0051F6  B3C011     MOV.B #0x1, W1
0051F8  984011     MOV.B W1, [W0+1]
627:               	OUT_DATA[0]		= 'C';
0051FA  B3C431     MOV.B #0x43, W1
0051FC  984021     MOV.B W1, [W0+2]
628:               }
0051FE  060000     RETURN
629:               
630:               void UsbCommandService_6	(void)
631:               {
632:               	#if		(TEST == GSM_TEST)
633:               		Gsm_DTR();
005200  07F2A7     RCALL Gsm_DTR
634:               	#endif
635:               	OUT_DATA_LEN	= 1;
005202  804830     MOV Out, W0
005204  B3C011     MOV.B #0x1, W1
005206  984011     MOV.B W1, [W0+1]
636:               	OUT_DATA[0]		= 'A';
005208  B3C411     MOV.B #0x41, W1
00520A  984021     MOV.B W1, [W0+2]
637:               }
00520C  060000     RETURN
638:               
639:               void UsbCommandService_7	(void)
640:               {
00520E  781F88     MOV W8, [W15++]
641:               	OUT_DATA_LEN	= 2;
005210  804838     MOV Out, W8
005212  B3C020     MOV.B #0x2, W0
005214  984410     MOV.B W0, [W8+1]
642:               	#if		(TEST == GSM_TEST)
643:               		*(U16*)&OUT_DATA[0] = Gsm_AUTO();
005216  07F2AD     RCALL Gsm_AUTO
005218  980410     MOV W0, [W8+2]
644:               	#elif	(TEST == WIFI_TEST)
645:               		*(U16*)&OUT_DATA[0] = Wifi_AUTO();
646:               	#endif
647:               }
00521A  78044F     MOV [--W15], W8
00521C  060000     RETURN
648:               
649:               void UsbCommandService_8	(void)
650:               {
651:               	Gsm_OnLine();
00521E  07F2BB     RCALL Gsm_OnLine
652:               	OUT_DATA_LEN	= 1;
005220  804830     MOV Out, W0
005222  B3C011     MOV.B #0x1, W1
005224  984011     MOV.B W1, [W0+1]
653:               	OUT_DATA[0]		= 'O';
005226  B3C4F1     MOV.B #0x4F, W1
005228  984021     MOV.B W1, [W0+2]
654:               }
00522A  060000     RETURN
655:               
656:               void UsbMemGetAddress		(void)
657:               {
00503C  781F88     MOV W8, [W15++]
658:               	SWITCH_OUT_BUF();
00503E  BFC904     MOV.B NextOutBuf, WREG
005040  236148     MOV #0x3614, W8
005042  320001     BRA Z, 0x5046
005044  235D48     MOV #0x35D4, W8
005046  884838     MOV W8, Out
005048  A20400     BTG.B W0, #0
00504A  B7E904     MOV.B WREG, NextOutBuf
659:               	OUT_COMMAND		= USB_COM_MEM_GET_ADDR;
00504C  B3C100     MOV.B #0x10, W0
00504E  784C00     MOV.B W0, [W8]
660:               	OUT_DATA_LEN	= 4;
005050  B3C040     MOV.B #0x4, W0
005052  984410     MOV.B W0, [W8+1]
661:               	OUT_ADDRESS		= (In.READwrite)?	Mem_GetReadAddress(): Mem_GetWriteAddress();
005054  235950     MOV #0x3595, W0
005056  E00410     CP0.B [W0]
005058  320002     BRA Z, 0x505E
00505A  070942     RCALL Mem_GetReadAddress
00505C  370001     BRA 0x5060
00505E  07093D     RCALL Mem_GetWriteAddress
005060  980410     MOV W0, [W8+2]
005062  980421     MOV W1, [W8+4]
662:               	USB_SEND_PACKET();
005064  804810     MOV USBInHandle, W0
005066  E00000     CP0 W0
005068  320003     BRA Z, 0x5070
00506A  E00010     CP0 [W0]
00506C  3D0001     BRA GE, 0x5070
00506E  07FE58     RCALL UsbWaitTxReady
005070  B3C403     MOV.B #0x40, W3
005072  804832     MOV Out, W2
005074  B3C011     MOV.B #0x1, W1
005076  784001     MOV.B W1, W0
005078  07FB90     RCALL USBTransferOnePacket
00507A  884810     MOV W0, USBInHandle
663:               }
00507C  78044F     MOV [--W15], W8
00507E  060000     RETURN
664:               
665:               void UsbMemSetAddress		(void)
666:               {
667:               //	UsbPrintRecBuf();
668:               	if (In.READwrite)	Mem_SetReadAddress(In.Address);
004FF0  235950     MOV #0x3595, W0
004FF2  E00410     CP0.B [W0]
004FF4  320004     BRA Z, 0x4FFE
004FF6  81ACB0     MOV 0x3596, W0
004FF8  81ACC1     MOV 0x3598, W1
004FFA  070955     RCALL Mem_SetReadAddress
004FFC  370003     BRA 0x5004
669:               	else				Mem_SetWriteAddress(In.Address);
004FFE  81ACB0     MOV 0x3596, W0
005000  81ACC1     MOV 0x3598, W1
005002  070927     RCALL Mem_SetWriteAddress
670:               	SWITCH_OUT_BUF();
005004  209041     MOV #0x904, W1
005006  784091     MOV.B [W1], W1
005008  236140     MOV #0x3614, W0
00500A  E00401     CP0.B W1
00500C  320001     BRA Z, 0x5010
00500E  235D40     MOV #0x35D4, W0
005010  884830     MOV W0, Out
005012  A20401     BTG.B W1, #0
005014  784181     MOV.B W1, W3
005016  209042     MOV #0x904, W2
005018  784903     MOV.B W3, [W2]
671:               	OUT_COMMAND		= USB_COM_MEM_SET_ADDR;
00501A  B3C111     MOV.B #0x11, W1
00501C  784801     MOV.B W1, [W0]
672:               	OUT_COM		= USB_OK;
00501E  B3C0C1     MOV.B #0xC, W1
005020  984011     MOV.B W1, [W0+1]
673:               	USB_SEND_PACKET();
005022  804810     MOV USBInHandle, W0
005024  E00000     CP0 W0
005026  320003     BRA Z, 0x502E
005028  E00010     CP0 [W0]
00502A  3D0001     BRA GE, 0x502E
00502C  07FE79     RCALL UsbWaitTxReady
00502E  B3C403     MOV.B #0x40, W3
005030  804832     MOV Out, W2
005032  B3C011     MOV.B #0x1, W1
005034  784001     MOV.B W1, W0
005036  07FBB1     RCALL USBTransferOnePacket
005038  884810     MOV W0, USBInHandle
674:               }
00503A  060000     RETURN
675:               
676:               void UsbMemWrite			(void)
677:               {
004F94  BE9F88     MOV.D W8, [W15++]
004F96  781F8A     MOV W10, [W15++]
678:               	register U8 i;
679:               	for (i = 0; i < In.PackedDateLen; i++)
004F98  EB4400     CLR.B W8
004F9A  235950     MOV #0x3595, W0
004F9C  E00410     CP0.B [W0]
004F9E  32000B     BRA Z, 0x4FB6
004FA2  780500     MOV W0, W10
004FB0  E84408     INC.B W8, W8
004FB2  144F9A     SUBR.B W8, [W10], [W15]
004FB4  3EFFF7     BRA GTU, 0x4FA4
680:               	{
681:               		while (Mem_WriteByte(In.Data[i]) < 0);
004FA0  E90480     DEC W0, W9
004FA4  FB8008     ZE W8, W0
004FA6  E88000     INC2 W0, W0
004FA8  784069     MOV.B [W9+W0], W0
004FAA  07099F     RCALL Mem_WriteByte
004FAC  E00400     CP0.B W0
004FAE  35FFFA     BRA LT, 0x4FA4
682:               	}
683:               
684:               	SWITCH_OUT_BUF();
004FB6  209041     MOV #0x904, W1
004FB8  784091     MOV.B [W1], W1
004FBA  236140     MOV #0x3614, W0
004FBC  E00401     CP0.B W1
004FBE  320001     BRA Z, 0x4FC2
004FC0  235D40     MOV #0x35D4, W0
004FC2  884830     MOV W0, Out
004FC4  A20401     BTG.B W1, #0
004FC6  784181     MOV.B W1, W3
004FC8  209042     MOV #0x904, W2
004FCA  784903     MOV.B W3, [W2]
685:               	OUT_COMMAND		= USB_COM_MEM_WRITE;
004FCC  B3C121     MOV.B #0x12, W1
004FCE  784801     MOV.B W1, [W0]
686:               	OUT_COM		= i;
004FD0  984018     MOV.B W8, [W0+1]
687:               	USB_SEND_PACKET();
004FD2  804810     MOV USBInHandle, W0
004FD4  E00000     CP0 W0
004FD6  320003     BRA Z, 0x4FDE
004FD8  E00010     CP0 [W0]
004FDA  3D0001     BRA GE, 0x4FDE
004FDC  07FEA1     RCALL UsbWaitTxReady
004FDE  B3C403     MOV.B #0x40, W3
004FE0  804832     MOV Out, W2
004FE2  B3C011     MOV.B #0x1, W1
004FE4  784001     MOV.B W1, W0
004FE6  07FBD9     RCALL USBTransferOnePacket
004FE8  884810     MOV W0, USBInHandle
688:               }
004FEA  78054F     MOV [--W15], W10
004FEC  BE044F     MOV.D [--W15], W8
004FEE  060000     RETURN
689:               
690:               void UsbMemRead				(void)
691:               {
00535A  B0042F     ADD #0x42, W15
00535C  BE9F88     MOV.D W8, [W15++]
00535E  BE9F8A     MOV.D W10, [W15++]
005360  BE9F8C     MOV.D W12, [W15++]
005362  781F8E     MOV W14, [W15++]
692:               	register U16 size	= In.PageSize;
005364  81ACD9     MOV 0x359A, W9
693:               	Mem_SetReadAddress(In.Address);
005366  235968     MOV #0x3596, W8
005368  BE0018     MOV.D [W8], W0
00536A  07079D     RCALL Mem_SetReadAddress
694:               
695:               	#if	(TEST == MEMORY_TEST)
696:               		char tmp[64];
697:               		sprintf(tmp, "Addr = 0x%X%04X; Size = %u ", (U16)(In.Address >> 16), (U16)(In.Address & 0xFFFF), size);
00536C  BE0018     MOV.D [W8], W0
00536E  781F89     MOV W9, [W15++]
005370  781F80     MOV W0, [W15++]
005372  781F81     MOV W1, [W15++]
005374  2B3F80     MOV #0xB3F8, W0
005376  781F80     MOV W0, [W15++]
005378  2FFAA0     MOV #0xFFAA, W0
00537A  40000F     ADD W0, W15, W0
00537C  07E017     RCALL __sprintf_cdnopuxX, __sprintf_s, __sprintf_0, __sprintf_cdnopsuxX
698:               		Usb_SendText(tmp);
00537E  2FFAA0     MOV #0xFFAA, W0
005380  40000F     ADD W0, W15, W0
005382  07FF9D     RCALL Usb_SendText
699:               	#endif
700:               	
701:               	SWITCH_OUT_BUF();
005384  209041     MOV #0x904, W1
005386  784091     MOV.B [W1], W1
005388  5787E8     SUB W15, #0x8, W15
00538A  236140     MOV #0x3614, W0
00538C  E00401     CP0.B W1
00538E  320001     BRA Z, 0x5392
005390  235D40     MOV #0x35D4, W0
005392  884830     MOV W0, Out
005394  A20401     BTG.B W1, #0
005396  784181     MOV.B W1, W3
005398  209042     MOV #0x904, W2
00539A  784903     MOV.B W3, [W2]
702:               	OUT_COMMAND			= USB_COM_MEM_READ;
00539C  B3C131     MOV.B #0x13, W1
00539E  784801     MOV.B W1, [W0]
703:               
704:               //	OUT_COM				= MemDataToUart(In.Address, size);
705:               //	if (OUT_COM)
706:               //	{
707:               //		USB_SEND_PACKET();
708:               //		return;
709:               //	}
710:               	while (size)
0053A0  E00009     CP0 W9
0053A2  320038     BRA Z, 0x5414
005410  E00009     CP0 W9
005412  3AFFCD     BRA NZ, 0x53AE
711:               	{
712:               		register U8 i;
713:               		OUT_DATA_LEN = (size > USB_PACKET_DATA_SIZE)?	USB_PACKET_DATA_SIZE: size;
0053A4  2003EA     MOV #0x3E, W10
0053AE  804831     MOV Out, W1
0053B0  780009     MOV W9, W0
0053B2  548F8A     SUB W9, W10, [W15]
0053B4  360001     BRA LEU, 0x53B8
0053B6  78000A     MOV W10, W0
0053B8  984090     MOV.B W0, [W1+1]
714:               		size -= OUT_DATA_LEN;
0053BA  804830     MOV Out, W0
0053BC  904010     MOV.B [W0+1], W0
0053BE  FB8080     ZE W0, W1
0053C0  548481     SUB W9, W1, W9
715:               
716:               //		Usb_SendText("Read data one packet");
717:               		for (i = 0; i < OUT_DATA_LEN; i++)
0053A6  EB4600     CLR.B W12
0053C2  E00400     CP0.B W0
0053C4  32000C     BRA Z, 0x53DE
0053C6  78440C     MOV.B W12, W8
0053D4  E84408     INC.B W8, W8
0053D6  804830     MOV Out, W0
0053D8  904010     MOV.B [W0+1], W0
0053DA  504F88     SUB.B W0, W8, [W15]
0053DC  3EFFF5     BRA GTU, 0x53C8
718:               		{
719:               			while (Mem_ReadByte(&OUT_DATA[i]) < 0);
0053C8  FB8008     ZE W8, W0
0053CA  E88000     INC2 W0, W0
0053CC  B40906     ADD Out, WREG
0053CE  0708A5     RCALL Mem_ReadByte
0053D0  E00400     CP0.B W0
0053D2  35FFFA     BRA LT, 0x53C8
720:               		}
721:               
722:               		USB_SEND_PACKET();
0053A8  28000D     MOV #0x8000, W13
0053DE  804810     MOV USBInHandle, W0
0053E0  E00000     CP0 W0
0053E2  320003     BRA Z, 0x53EA
0053E4  668010     AND W13, [W0], W0
0053E6  320001     BRA Z, 0x53EA
0053E8  07FC9B     RCALL UsbWaitTxReady
0053EA  B3C403     MOV.B #0x40, W3
0053EC  804832     MOV Out, W2
0053EE  B3C011     MOV.B #0x1, W1
0053F0  784001     MOV.B W1, W0
0053F2  07F9D3     RCALL USBTransferOnePacket
0053F4  884810     MOV W0, USBInHandle
723:               		SWITCH_OUT_BUF();
0053AA  23614B     MOV #0x3614, W11
0053AC  235D4E     MOV #0x35D4, W14
0053F6  209041     MOV #0x904, W1
0053F8  784091     MOV.B [W1], W1
0053FA  78000B     MOV W11, W0
0053FC  E00401     CP0.B W1
0053FE  320001     BRA Z, 0x5402
005400  78000E     MOV W14, W0
005402  884830     MOV W0, Out
005404  A20401     BTG.B W1, #0
005406  784181     MOV.B W1, W3
005408  209042     MOV #0x904, W2
00540A  784903     MOV.B W3, [W2]
724:               		OUT_COMMAND			= USB_COM_MEM_READ;
00540C  B3C131     MOV.B #0x13, W1
00540E  784801     MOV.B W1, [W0]
725:               	}
726:               	OUT_DATA_LEN = (U8)size;
005414  804830     MOV Out, W0
005416  984019     MOV.B W9, [W0+1]
727:               	USB_SEND_PACKET();
005418  804810     MOV USBInHandle, W0
00541A  E00000     CP0 W0
00541C  320003     BRA Z, 0x5424
00541E  E00010     CP0 [W0]
005420  3D0001     BRA GE, 0x5424
005422  07FC7E     RCALL UsbWaitTxReady
005424  B3C403     MOV.B #0x40, W3
005426  804832     MOV Out, W2
005428  B3C011     MOV.B #0x1, W1
00542A  784001     MOV.B W1, W0
00542C  07F9B6     RCALL USBTransferOnePacket
00542E  884810     MOV W0, USBInHandle
728:               }
005430  78074F     MOV [--W15], W14
005432  BE064F     MOV.D [--W15], W12
005434  BE054F     MOV.D [--W15], W10
005436  BE044F     MOV.D [--W15], W8
005438  B1042F     SUB #0x42, W15
00543A  060000     RETURN
729:               
730:               void UsbMemClose			(void)
731:               {
732:               //	Mem_WriteEnd();
733:               	SWITCH_OUT_BUF();
004F5C  209041     MOV #0x904, W1
004F5E  784091     MOV.B [W1], W1
004F60  236140     MOV #0x3614, W0
004F62  E00401     CP0.B W1
004F64  320001     BRA Z, 0x4F68
004F66  235D40     MOV #0x35D4, W0
004F68  884830     MOV W0, Out
004F6A  A20401     BTG.B W1, #0
004F6C  784181     MOV.B W1, W3
004F6E  209042     MOV #0x904, W2
004F70  784903     MOV.B W3, [W2]
734:               	OUT_COMMAND			= USB_COM_MEM_CLOSE;
004F72  B3C141     MOV.B #0x14, W1
004F74  784801     MOV.B W1, [W0]
735:               	OUT_COM				= USB_OK;
004F76  B3C0C1     MOV.B #0xC, W1
004F78  984011     MOV.B W1, [W0+1]
736:               	USB_SEND_PACKET();
004F7A  804810     MOV USBInHandle, W0
004F7C  E00000     CP0 W0
004F7E  320003     BRA Z, 0x4F86
004F80  E00010     CP0 [W0]
004F82  3D0001     BRA GE, 0x4F86
004F84  07FECD     RCALL UsbWaitTxReady
004F86  B3C403     MOV.B #0x40, W3
004F88  804832     MOV Out, W2
004F8A  B3C011     MOV.B #0x1, W1
004F8C  784001     MOV.B W1, W0
004F8E  07FC05     RCALL USBTransferOnePacket
004F90  884810     MOV W0, USBInHandle
737:               }
004F92  060000     RETURN
738:               
739:               void UsbMemSecErase			(void)
740:               {
741:               	Mem_PageErase();
004F22  070B3E     RCALL Mem_PageErase
742:               //	Usb_SendText("Sector Erase command not implemented");
743:               	SWITCH_OUT_BUF();
004F24  209041     MOV #0x904, W1
004F26  784091     MOV.B [W1], W1
004F28  236140     MOV #0x3614, W0
004F2A  E00401     CP0.B W1
004F2C  320001     BRA Z, 0x4F30
004F2E  235D40     MOV #0x35D4, W0
004F30  884830     MOV W0, Out
004F32  A20401     BTG.B W1, #0
004F34  784181     MOV.B W1, W3
004F36  209042     MOV #0x904, W2
004F38  784903     MOV.B W3, [W2]
744:               	OUT_COMMAND			= USB_COM_MEM_S_ERASE;
004F3A  B3C151     MOV.B #0x15, W1
004F3C  784801     MOV.B W1, [W0]
745:               	OUT_COM				= USB_OK;
004F3E  B3C0C1     MOV.B #0xC, W1
004F40  984011     MOV.B W1, [W0+1]
746:               	USB_SEND_PACKET();
004F42  804810     MOV USBInHandle, W0
004F44  E00000     CP0 W0
004F46  320003     BRA Z, 0x4F4E
004F48  E00010     CP0 [W0]
004F4A  3D0001     BRA GE, 0x4F4E
004F4C  07FEE9     RCALL UsbWaitTxReady
004F4E  B3C403     MOV.B #0x40, W3
004F50  804832     MOV Out, W2
004F52  B3C011     MOV.B #0x1, W1
004F54  784001     MOV.B W1, W0
004F56  07FC21     RCALL USBTransferOnePacket
004F58  884810     MOV W0, USBInHandle
747:               }
004F5A  060000     RETURN
748:               
749:               void UsbMemBulkErase		(void)
750:               {
751:               //	MemBulkErase();
752:               	Usb_SendText("Bulk Erase command not implemented jet");
00531E  2B3D10     MOV #0xB3D1, W0
005320  07FFCE     RCALL Usb_SendText
753:               	SWITCH_OUT_BUF();
005322  209041     MOV #0x904, W1
005324  784091     MOV.B [W1], W1
005326  236140     MOV #0x3614, W0
005328  E00401     CP0.B W1
00532A  320001     BRA Z, 0x532E
00532C  235D40     MOV #0x35D4, W0
00532E  884830     MOV W0, Out
005330  A20401     BTG.B W1, #0
005332  784181     MOV.B W1, W3
005334  209042     MOV #0x904, W2
005336  784903     MOV.B W3, [W2]
754:               	OUT_COMMAND			= USB_COM_MEM_B_ERASE;
005338  B3C161     MOV.B #0x16, W1
00533A  784801     MOV.B W1, [W0]
755:               	OUT_COM				= USB_OK;
00533C  B3C0C1     MOV.B #0xC, W1
00533E  984011     MOV.B W1, [W0+1]
756:               	USB_SEND_PACKET();
005340  804810     MOV USBInHandle, W0
005342  E00000     CP0 W0
005344  320003     BRA Z, 0x534C
005346  E00010     CP0 [W0]
005348  3D0001     BRA GE, 0x534C
00534A  07FCEA     RCALL UsbWaitTxReady
00534C  B3C403     MOV.B #0x40, W3
00534E  804832     MOV Out, W2
005350  B3C011     MOV.B #0x1, W1
005352  784001     MOV.B W1, W0
005354  07FA22     RCALL USBTransferOnePacket
005356  884810     MOV W0, USBInHandle
757:               }
005358  060000     RETURN
758:               
759:               void UsbMemSetBootAddress	(void)
760:               {
004EDA  781F88     MOV W8, [W15++]
761:               //	#ifdef		BOOT_LOADER
762:               //		Out->PageSize	= MemSetAddressTo_0_chip();	// 16bit Boot memory chip Type
763:               //	#else
764:               	#ifdef GPS_IE			// if defined GPS interrupt
765:               		GPS_IE = 0;			// switch it off to avoid memory write
004EDC  A9A099     BCLR 0x99, #5
766:               	#endif
767:               		Mem_SetWriteAddress(0);
004EDE  B80060     MUL.UU W0, #0, W0
004EE0  0709B8     RCALL Mem_SetWriteAddress
768:               //		Out->PageSize	= 0;
769:               //	#endif	//	BOOT_LOADER
770:               	SWITCH_OUT_BUF();
004EE2  BFC904     MOV.B NextOutBuf, WREG
004EE4  236148     MOV #0x3614, W8
004EE6  320001     BRA Z, 0x4EEA
004EE8  235D48     MOV #0x35D4, W8
004EEA  884838     MOV W8, Out
004EEC  A20400     BTG.B W0, #0
004EEE  B7E904     MOV.B WREG, NextOutBuf
771:               	OUT_COMMAND			= USB_COM_MEM_BOOT_ADDR;
004EF0  B3C1A0     MOV.B #0x1A, W0
004EF2  784C00     MOV.B W0, [W8]
772:               	Out->PageSize		= Mem_GetType();
004EF4  0709F8     RCALL Mem_GetType
004EF6  980430     MOV W0, [W8+6]
773:               	Out->Address		= Mem_GetWriteAddress();
004EF8  804838     MOV Out, W8
004EFA  0709EF     RCALL Mem_GetWriteAddress
004EFC  980410     MOV W0, [W8+2]
004EFE  980421     MOV W1, [W8+4]
774:               	OUT_DATA_LEN		= 6;
004F00  B3C061     MOV.B #0x6, W1
004F02  804830     MOV Out, W0
004F04  984011     MOV.B W1, [W0+1]
775:               	USB_SEND_PACKET();
004F06  804810     MOV USBInHandle, W0
004F08  E00000     CP0 W0
004F0A  320003     BRA Z, 0x4F12
004F0C  E00010     CP0 [W0]
004F0E  3D0001     BRA GE, 0x4F12
004F10  07FF07     RCALL UsbWaitTxReady
004F12  B3C403     MOV.B #0x40, W3
004F14  804832     MOV Out, W2
004F16  B3C011     MOV.B #0x1, W1
004F18  784001     MOV.B W1, W0
004F1A  07FC3F     RCALL USBTransferOnePacket
004F1C  884810     MOV W0, USBInHandle
776:               }
004F1E  78044F     MOV [--W15], W8
004F20  060000     RETURN
777:               
778:               void UsbMemFeel				(void)
779:               {
004EA0  781F88     MOV W8, [W15++]
780:               	SWITCH_OUT_BUF();
004EA2  BFC904     MOV.B NextOutBuf, WREG
004EA4  236148     MOV #0x3614, W8
004EA6  320001     BRA Z, 0x4EAA
004EA8  235D48     MOV #0x35D4, W8
004EAA  884838     MOV W8, Out
004EAC  A20400     BTG.B W0, #0
004EAE  B7E904     MOV.B WREG, NextOutBuf
781:               	OUT_COMMAND			= USB_COM_MEM_FEEL;
004EB0  B3C1E0     MOV.B #0x1E, W0
004EB2  784C00     MOV.B W0, [W8]
782:               	OUT_COM				= USB_PACKET_DATA_SIZE;	// 62 bytes
004EB4  B3C3E0     MOV.B #0x3E, W0
004EB6  984410     MOV.B W0, [W8+1]
783:               	Out->Address		= Mem_GetWriteAddress();		// writed in memory bytes count
004EB8  070A10     RCALL Mem_GetWriteAddress
004EBA  980410     MOV W0, [W8+2]
004EBC  980421     MOV W1, [W8+4]
784:               //	Out->PageSize		= BmpPageHi;			// 3000	at start
785:               //	Out->BmpWithPix		= Get_BmpWithPix();		// Pix count in row	/0/0xFFFF
786:               //	Out->BmpPage		= BmpPage;				// 0	at start
787:               //	Out->CharRowSize	= GetCharRowWidth();	// byte count in row
788:               //	Out->Percent_0_1	= Percent_10;			// calculated at start 0.1% of available memory (in bytes)
789:               	USB_SEND_PACKET();
004EBE  804810     MOV USBInHandle, W0
004EC0  E00000     CP0 W0
004EC2  320003     BRA Z, 0x4ECA
004EC4  E00010     CP0 [W0]
004EC6  3D0001     BRA GE, 0x4ECA
004EC8  07FF2B     RCALL UsbWaitTxReady
004ECA  B3C403     MOV.B #0x40, W3
004ECC  804832     MOV Out, W2
004ECE  B3C011     MOV.B #0x1, W1
004ED0  784001     MOV.B W1, W0
004ED2  07FC63     RCALL USBTransferOnePacket
004ED4  884810     MOV W0, USBInHandle
790:               }
004ED6  78044F     MOV [--W15], W8
004ED8  060000     RETURN
791:               
792:               void UsbMemStatus			(void)
793:               {
004E6C  781F88     MOV W8, [W15++]
794:               //	Usb_SendText("Status command not implemented");
795:               	SWITCH_OUT_BUF();
004E6E  BFC904     MOV.B NextOutBuf, WREG
004E70  236148     MOV #0x3614, W8
004E72  320001     BRA Z, 0x4E76
004E74  235D48     MOV #0x35D4, W8
004E76  884838     MOV W8, Out
004E78  A20400     BTG.B W0, #0
004E7A  B7E904     MOV.B WREG, NextOutBuf
796:               	OUT_COMMAND			= USB_COM_MEM_STATUS;
004E7C  B3C1F0     MOV.B #0x1F, W0
004E7E  784C00     MOV.B W0, [W8]
797:               	OUT_COM				= MemStatus();
004E80  070A57     RCALL MemStatus
004E82  984410     MOV.B W0, [W8+1]
798:               	USB_SEND_PACKET();
004E84  804810     MOV USBInHandle, W0
004E86  E00000     CP0 W0
004E88  320003     BRA Z, 0x4E90
004E8A  E00010     CP0 [W0]
004E8C  3D0001     BRA GE, 0x4E90
004E8E  07FF48     RCALL UsbWaitTxReady
004E90  B3C403     MOV.B #0x40, W3
004E92  804832     MOV Out, W2
004E94  B3C011     MOV.B #0x1, W1
004E96  784001     MOV.B W1, W0
004E98  07FC80     RCALL USBTransferOnePacket
004E9A  884810     MOV W0, USBInHandle
799:               }
004E9C  78044F     MOV [--W15], W8
004E9E  060000     RETURN
800:               
801:               void UsbCommandTest			(void)
802:               {
803:               	SWITCH_OUT_BUF();
004DF4  209041     MOV #0x904, W1
004DF6  784091     MOV.B [W1], W1
004DF8  236140     MOV #0x3614, W0
004DFA  E00401     CP0.B W1
004DFC  320001     BRA Z, 0x4E00
004DFE  235D40     MOV #0x35D4, W0
004E00  884830     MOV W0, Out
004E02  A20401     BTG.B W1, #0
004E04  784181     MOV.B W1, W3
004E06  209042     MOV #0x904, W2
004E08  784903     MOV.B W3, [W2]
804:               	OUT_COMMAND			= USB_COM_TEST;
004E0A  EBC800     SETM.B [W0]
805:               	OUT_COM				= 0xFE;
004E0C  B3CFE1     MOV.B #0xFE, W1
004E0E  984011     MOV.B W1, [W0+1]
806:               	OUT_ADDRESS			= 0x12345678;
004E10  256782     MOV #0x5678, W2
004E12  212343     MOV #0x1234, W3
004E14  980012     MOV W2, [W0+2]
004E16  980023     MOV W3, [W0+4]
807:               	OUT_READ_LEN		= 0x9ABC;
004E18  29ABC1     MOV #0x9ABC, W1
004E1A  980031     MOV W1, [W0+6]
808:               	USB_SEND_PACKET();
004E1C  804810     MOV USBInHandle, W0
004E1E  E00000     CP0 W0
004E20  320003     BRA Z, 0x4E28
004E22  E00010     CP0 [W0]
004E24  3D0001     BRA GE, 0x4E28
004E26  07FF7C     RCALL UsbWaitTxReady
004E28  B3C403     MOV.B #0x40, W3
004E2A  804832     MOV Out, W2
004E2C  B3C011     MOV.B #0x1, W1
004E2E  784001     MOV.B W1, W0
004E30  07FCB4     RCALL USBTransferOnePacket
004E32  884810     MOV W0, USBInHandle
809:               
810:               	SWITCH_OUT_BUF();
004E34  209041     MOV #0x904, W1
004E36  784091     MOV.B [W1], W1
004E38  236140     MOV #0x3614, W0
004E3A  E00401     CP0.B W1
004E3C  320001     BRA Z, 0x4E40
004E3E  235D40     MOV #0x35D4, W0
004E40  884830     MOV W0, Out
004E42  A20401     BTG.B W1, #0
004E44  784181     MOV.B W1, W3
004E46  209042     MOV #0x904, W2
004E48  784903     MOV.B W3, [W2]
811:               	memcpy(OUT_PACKET, In.buf, USB_PACKET_SIZE);
004E4A  235941     MOV #0x3594, W1
004E4C  09001F     REPEAT #0x1F
004E4E  781831     MOV [W1++], [W0++]
004E50  B10400     SUB #0x40, W0
812:               	USB_SEND_PACKET();
004E52  804810     MOV USBInHandle, W0
004E54  E00000     CP0 W0
004E56  320003     BRA Z, 0x4E5E
004E58  E00010     CP0 [W0]
004E5A  3D0001     BRA GE, 0x4E5E
004E5C  07FF61     RCALL UsbWaitTxReady
004E5E  B3C403     MOV.B #0x40, W3
004E60  804832     MOV Out, W2
004E62  B3C011     MOV.B #0x1, W1
004E64  784001     MOV.B W1, W0
004E66  07FC99     RCALL USBTransferOnePacket
004E68  884810     MOV W0, USBInHandle
813:               }
004E6A  060000     RETURN
814:               
815:               void Usb_SendText			(char* str)
816:               {
0052BE  781F88     MOV W8, [W15++]
0052C0  780400     MOV W0, W8
817:               	USB_WAIT_TX_READY();
0052C2  804810     MOV USBInHandle, W0
0052C4  E00000     CP0 W0
0052C6  320003     BRA Z, 0x52CE
0052C8  E00010     CP0 [W0]
0052CA  3D0001     BRA GE, 0x52CE
0052CC  07FD29     RCALL UsbWaitTxReady
818:               	Text.UsbCommand	= USB_COM_TEXT;		// USB Command ID
0052CE  B3CFC1     MOV.B #0xFC, W1
0052D0  236540     MOV #0x3654, W0
0052D2  784801     MOV.B W1, [W0]
819:               	register U8 i;
820:               	for (i = 0; i < 61; i++)			// String width \0 must not exceed 62
0052D6  EB4000     CLR.B W0
0052E6  E84000     INC.B W0, W0
0052E8  504F83     SUB.B W0, W3, [W15]
0052EA  3AFFF9     BRA NZ, 0x52DE
005318  B3C010     MOV.B #0x1, W0
00531A  B3C3D3     MOV.B #0x3D, W3
00531C  37FFE0     BRA 0x52DE
821:               	{
822:               		register U8 a	= str[i];
0052D4  784098     MOV.B [W8], W1
0052DE  7840D8     MOV.B [++W8], W1
823:               		if (!a)	break;					// test \0
0052D8  E00401     CP0.B W1
0052DA  3A001C     BRA NZ, 0x5314
0052DC  370007     BRA 0x52EC
0052E0  E00401     CP0.B W1
0052E2  320004     BRA Z, 0x52EC
824:               		Text.Data[i]	= a;			// copy data
0052E4  786901     MOV.B W1, [++W2]
005314  236562     MOV #0x3656, W2
005316  784901     MOV.B W1, [W2]
825:               	}
826:               	Text.Data[i]		= 0;			// \0
0052EC  FB8080     ZE W0, W1
0052EE  EB4180     CLR.B W3
0052F0  236562     MOV #0x3656, W2
0052F2  78F103     MOV.B W3, [W2+W1]
827:               	Text.PackedDateLen	= i;			// save data size
0052F4  E90082     DEC W2, W1
0052F6  784880     MOV.B W0, [W1]
828:               	USB_WAIT_TX_READY();
0052F8  804810     MOV USBInHandle, W0
0052FA  E00000     CP0 W0
0052FC  320003     BRA Z, 0x5304
0052FE  E00010     CP0 [W0]
005300  3D0001     BRA GE, 0x5304
005302  07FD0E     RCALL UsbWaitTxReady
829:               	USBInHandle = HIDTxPacket(CUSTOM_DEVICE_HID_EP, Text.buf, USB_PACKET_SIZE);
005304  B3C403     MOV.B #0x40, W3
005306  236542     MOV #0x3654, W2
005308  B3C011     MOV.B #0x1, W1
00530A  784001     MOV.B W1, W0
00530C  07FA46     RCALL USBTransferOnePacket
00530E  884810     MOV W0, USBInHandle
830:               }
005310  78044F     MOV [--W15], W8
005312  060000     RETURN
005314  236562     MOV #0x3656, W2
005316  784901     MOV.B W1, [W2]
005318  B3C010     MOV.B #0x1, W0
00531A  B3C3D3     MOV.B #0x3D, W3
00531C  37FFE0     BRA 0x52DE
831:               
832:               void UsbDeviceText			(void)
833:               {
834:               	
835:               }
004CC6  060000     RETURN
836:               
837:               void UsbDeviceInfo			(void)
838:               {
839:               	SWITCH_OUT_BUF();
004D8C  209041     MOV #0x904, W1
004D8E  784091     MOV.B [W1], W1
004D90  236140     MOV #0x3614, W0
004D92  E00401     CP0.B W1
004D94  320001     BRA Z, 0x4D98
004D96  235D40     MOV #0x35D4, W0
004D98  884830     MOV W0, Out
004D9A  A20401     BTG.B W1, #0
004D9C  784181     MOV.B W1, W3
004D9E  209042     MOV #0x904, W2
004DA0  784903     MOV.B W3, [W2]
840:               	OUT_COMMAND				= USB_COM_DEV_INFO;
004DA2  B3CFD1     MOV.B #0xFD, W1
004DA4  784801     MOV.B W1, [W0]
841:               	OUT_COM					= 1;
004DA6  B3C011     MOV.B #0x1, W1
004DA8  984011     MOV.B W1, [W0+1]
842:               	sprintf((char*)OUT_DATA, "%s %s %s %s \r", DEVICE, VERSION, Build_Date, Build_Time);
004DAA  E88000     INC2 W0, W0
004DAC  2B6431     MOV #0xB643, W1
004DAE  781F81     MOV W1, [W15++]
004DB0  2B6371     MOV #0xB637, W1
004DB2  781F81     MOV W1, [W15++]
004DB4  2B3B81     MOV #0xB3B8, W1
004DB6  781F81     MOV W1, [W15++]
004DB8  2B3BB1     MOV #0xB3BB, W1
004DBA  781F81     MOV W1, [W15++]
004DBC  2B3C31     MOV #0xB3C3, W1
004DBE  781F81     MOV W1, [W15++]
004DC0  07E2F5     RCALL __sprintf_cdnopuxX, __sprintf_s, __sprintf_0, __sprintf_cdnopsuxX
843:               	U8* ptr = OUT_DATA;
004DC2  804830     MOV Out, W0
844:               	while (*ptr++ != '\r')
004DC4  5787EA     SUB W15, #0xA, W15
004DC6  9040A0     MOV.B [W0+2], W1
004DC8  50CFED     SUB.B W1, #0xD, [W15]
004DCA  320007     BRA Z, 0x4DDA
004DCC  4000E3     ADD W0, #0x3, W1
004DD4  B3C0D2     MOV.B #0xD, W2
004DD6  114FB1     SUBR.B W2, [W1++], [W15]
004DD8  3AFFFA     BRA NZ, 0x4DCE
845:               		OUT_COM++;
004DCE  904110     MOV.B [W0+1], W2
004DD0  E84102     INC.B W2, W2
004DD2  984012     MOV.B W2, [W0+1]
846:               	USB_SEND_PACKET();
004DDA  804810     MOV USBInHandle, W0
004DDC  E00000     CP0 W0
004DDE  320003     BRA Z, 0x4DE6
004DE0  E00010     CP0 [W0]
004DE2  3D0001     BRA GE, 0x4DE6
004DE4  07FF9D     RCALL UsbWaitTxReady
004DE6  B3C403     MOV.B #0x40, W3
004DE8  804832     MOV Out, W2
004DEA  B3C011     MOV.B #0x1, W1
004DEC  784001     MOV.B W1, W0
004DEE  07FCD5     RCALL USBTransferOnePacket
004DF0  884810     MOV W0, USBInHandle
847:               }
004DF2  060000     RETURN
848:               
849:               //extern	U8		ManufacturerId, MemoryType, MemoryCapacity;
850:               void UsbDeviceStatus		(void)
851:               {
004D38  781F88     MOV W8, [W15++]
852:               	SWITCH_OUT_BUF();
004D3A  BFC904     MOV.B NextOutBuf, WREG
004D3C  236148     MOV #0x3614, W8
004D3E  320001     BRA Z, 0x4D42
004D40  235D48     MOV #0x35D4, W8
004D42  884838     MOV W8, Out
004D44  A20400     BTG.B W0, #0
004D46  B7E904     MOV.B WREG, NextOutBuf
853:               	OUT_COMMAND				= USB_COM_DEV_STATUS;
004D48  B3CFE0     MOV.B #0xFE, W0
004D4A  784C00     MOV.B W0, [W8]
854:               	DEV_STATUS* devStatus	= (DEV_STATUS*)&OUT_PACKET[0];
855:               //	DEV_STATUS* devStatus = (DEV_STATUS*)&ToSendDataBuffer[0];
856:               	devStatus->led			= (LED_HID == LED_STATUS_1_I)?	0:1;
004D4C  8044D1     MOV LedStatus4, W1
004D4E  23FFF0     MOV #0x3FFF, W0
004D50  688000     XOR W1, W0, W0
004D52  A7F000     BTSC W0, #15
004D54  EA0000     NEG W0, W0
004D56  EA0000     NEG W0, W0
004D58  DE004F     LSR W0, #15, W0
004D5A  984410     MOV.B W0, [W8+1]
857:               	devStatus->pot			= 1;
004D5C  200010     MOV #0x1, W0
004D5E  980410     MOV W0, [W8+2]
858:               	devStatus->Raddr		= Mem_GetReadAddress();
004D60  070ABF     RCALL Mem_GetReadAddress
004D62  980420     MOV W0, [W8+4]
004D64  980431     MOV W1, [W8+6]
859:               	devStatus->Waddr		= Mem_GetWriteAddress();
004D66  070AB9     RCALL Mem_GetWriteAddress
004D68  980440     MOV W0, [W8+8]
004D6A  980451     MOV W1, [W8+10]
860:               //	devStatus->MemId		= 1;
861:               	devStatus->MemType		= Mem_GetType();
004D6C  070ABC     RCALL Mem_GetType
004D6E  980460     MOV W0, [W8+12]
862:               //	devStatus->MemCapacity	= 1;
863:               	
864:               	USB_SEND_PACKET();
004D70  804810     MOV USBInHandle, W0
004D72  E00000     CP0 W0
004D74  320003     BRA Z, 0x4D7C
004D76  E00010     CP0 [W0]
004D78  3D0001     BRA GE, 0x4D7C
004D7A  07FFD2     RCALL UsbWaitTxReady
004D7C  B3C403     MOV.B #0x40, W3
004D7E  804832     MOV Out, W2
004D80  B3C011     MOV.B #0x1, W1
004D82  784001     MOV.B W1, W0
004D84  07FD0A     RCALL USBTransferOnePacket
004D86  884810     MOV W0, USBInHandle
865:               }
004D88  78044F     MOV [--W15], W8
004D8A  060000     RETURN
866:               
867:               void UsbPrintRecBuf			(void)
868:               {
005446  FA003E     LNK #0x3E
869:               	char tmp[62];
870:               	sprintf(tmp, "%02X,%02X,%02X,%02X,%02X,%02X,%02X,%02X,%02X,%02X",
00544A  FB8010     ZE [W0], W0
00544C  781F80     MOV W0, [W15++]
005450  FB8010     ZE [W0], W0
005452  781F80     MOV W0, [W15++]
005456  FB8010     ZE [W0], W0
005458  781F80     MOV W0, [W15++]
00545C  FB8010     ZE [W0], W0
00545E  781F80     MOV W0, [W15++]
005462  FB8010     ZE [W0], W0
005464  781F80     MOV W0, [W15++]
005468  FB8010     ZE [W0], W0
00546A  781F80     MOV W0, [W15++]
00546E  FB8010     ZE [W0], W0
005470  781F80     MOV W0, [W15++]
005474  FB8010     ZE [W0], W0
005476  781F80     MOV W0, [W15++]
00547A  FB8010     ZE [W0], W0
00547C  781F80     MOV W0, [W15++]
005480  FB8010     ZE [W0], W0
005482  781F80     MOV W0, [W15++]
005484  2B43A0     MOV #0xB43A, W0
005486  781F80     MOV W0, [W15++]
005488  2FFAC0     MOV #0xFFAC, W0
00548A  40000F     ADD W0, W15, W0
00548C  07DF8F     RCALL __sprintf_cdnopuxX, __sprintf_s, __sprintf_0, __sprintf_cdnopsuxX
871:               			In.buf[0],In.buf[1],In.buf[2],In.buf[3],In.buf[4],In.buf[5],In.buf[6],In.buf[7],In.buf[8],In.buf[9]);
005448  2359D0     MOV #0x359D, W0
00544E  2359C0     MOV #0x359C, W0
005454  2359B0     MOV #0x359B, W0
00545A  2359A0     MOV #0x359A, W0
005460  235990     MOV #0x3599, W0
005466  235980     MOV #0x3598, W0
00546C  235970     MOV #0x3597, W0
005472  235960     MOV #0x3596, W0
005478  235950     MOV #0x3595, W0
00547E  235940     MOV #0x3594, W0
872:               	Usb_SendText(tmp);
00548E  2FFAC0     MOV #0xFFAC, W0
005490  40000F     ADD W0, W15, W0
005492  07FF15     RCALL Usb_SendText
005494  5787F6     SUB W15, #0x16, W15
873:               }
005496  FA8000     ULNK
005498  060000     RETURN
874:               
